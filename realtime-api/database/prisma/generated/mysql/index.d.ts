
/**
 * Client
**/

import * as runtime from './runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model costumer
 * 
 */
export type costumer = {
  id: number
  name: string
  email: string
  password_hash: string
  picture_uri: string | null
  created_at: Date
  updated_at: Date
  genderId: number
  birthday: string
  cpf: string | null
}

/**
 * Model deliveryman
 * 
 */
export type deliveryman = {
  id: number
  name: string
  email: string
  password_hash: string
  picture_uri: string
  locationId: number
  online: boolean
  created_at: Date
  updated_at: Date
  genderId: number
  birthday: string
}

/**
 * Model veicule_deliveryman
 * 
 */
export type veicule_deliveryman = {
  id: number
  veiculeId: number
  deliverymanId: number
  created_at: Date
  updated_at: Date
}

/**
 * Model payment
 * 
 */
export type payment = {
  id: number
  status: boolean
  details: string
  payment_methodId: number
  orderId: number
  created_at: Date
  updated_at: Date
}

/**
 * Model order
 * 
 */
export type order = {
  id: number
  accepted_status: boolean
  delivered_status_for_client: boolean
  retreat_products_status: boolean
  deliverymanId: number | null
  shopping_listId: number
  created_at: Date
  updated_at: Date
  costumer_addressesId: number
  intent_payment_id: string
}

/**
 * Model shopping_list
 * 
 */
export type shopping_list = {
  id: number
  freight: number | null
  total: number
  costumerId: number
  created_at: Date
  updated_at: Date
}

/**
 * Model products_in_shopping_list
 * 
 */
export type products_in_shopping_list = {
  id: number
  shopping_listId: number
  productId: number
  created_at: Date
  updated_at: Date
}

/**
 * Model product
 * 
 */
export type product = {
  id: number
  name: string
  price: number
  quantity: number | null
  review: number
  active_for_selling: boolean
  available_quantity: number
  marketerId: number
  created_at: Date
  updated_at: Date
  description: string
  category_of_productId: number
  type_of_productId: number
}

/**
 * Model marketer
 * 
 */
export type marketer = {
  id: number
  name: string
  email: string
  password_hash: string
  picture_uri: string | null
  review: number
  online: boolean
  locationId: number
  created_at: Date
  birthday: string
  updated_at: Date
  genderId: number
  cnpj: string | null
  cpf: string | null
  phone: string
  tent_name: string
}

/**
 * Model fair
 * 
 */
export type fair = {
  name: string
  id: number
  review: number
  addressId: number
  created_at: Date
  updated_at: Date
  locationId: number
}

/**
 * Model fair_marketers
 * 
 */
export type fair_marketers = {
  id: number
  fairId: number
  marketerId: number
  created_at: Date
  updated_at: Date
}

/**
 * Model costumer_addresses
 * 
 */
export type costumer_addresses = {
  id: number
  addressId: number
  costumerId: number
  created_at: Date
  updated_at: Date
}

/**
 * Model location
 * 
 */
export type location = {
  id: number
  longitude: number
  latitude: number
  created_at: Date
  updated_at: Date
}

/**
 * Model address
 * 
 */
export type address = {
  id: number
  cep: string
  logradouro: string
  number: number
  created_at: Date
  updated_at: Date
  address_typeId: number
  complemento: string
  cityId: number
  uFId: number
  neighborhoodId: number
  locationId: number
}

/**
 * Model address_type
 * 
 */
export type address_type = {
  id: number
  name: string
  created_at: Date
  updated_at: Date
}

/**
 * Model veicule
 * 
 */
export type veicule = {
  id: number
  name: string
  created_at: Date
  updated_at: Date
}

/**
 * Model image_of_product
 * 
 */
export type image_of_product = {
  id: number
  imageId: number
  productId: number
  created_at: Date
  updated_at: Date
}

/**
 * Model image
 * 
 */
export type image = {
  id: number
  uri: string
  created_at: Date
  updated_at: Date
  fairId: number | null
}

/**
 * Model payment_method
 * 
 */
export type payment_method = {
  id: number
  name: string
  created_at: Date
  updated_at: Date
}

/**
 * Model fair_date_hour_of_work
 * 
 */
export type fair_date_hour_of_work = {
  id: number
  fairId: number
  date_and_hour_of_workId: number
  created_at: Date
  updated_at: Date
}

/**
 * Model date_and_hour_of_work
 * 
 */
export type date_and_hour_of_work = {
  id: number
  open_datetime: Date
  close_datetime: Date
  created_at: Date
  updated_at: Date
  day_of_weekId: number
}

/**
 * Model day_of_week
 * 
 */
export type day_of_week = {
  id: number
  name: string
  created_at: Date
  updated_at: Date
}

/**
 * Model gender
 * 
 */
export type gender = {
  id: number
  name: string
  created_at: Date
  updated_at: Date
}

/**
 * Model city
 * 
 */
export type city = {
  id: number
  name: string
}

/**
 * Model neighborhood
 * 
 */
export type neighborhood = {
  id: number
  name: string
}

/**
 * Model uf
 * 
 */
export type uf = {
  id: number
  name: string
}

/**
 * Model category_of_product
 * 
 */
export type category_of_product = {
  id: number
  imageId: number
  name: string
}

/**
 * Model sale_off
 * 
 */
export type sale_off = {
  id: number
  value: number
  productId: number
}

/**
 * Model type_of_price
 * 
 */
export type type_of_price = {
  id: number
  name: string
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Costumers
 * const costumers = await prisma.costumer.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Costumers
   * const costumers = await prisma.costumer.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.costumer`: Exposes CRUD operations for the **costumer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Costumers
    * const costumers = await prisma.costumer.findMany()
    * ```
    */
  get costumer(): Prisma.costumerDelegate<GlobalReject>;

  /**
   * `prisma.deliveryman`: Exposes CRUD operations for the **deliveryman** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deliverymen
    * const deliverymen = await prisma.deliveryman.findMany()
    * ```
    */
  get deliveryman(): Prisma.deliverymanDelegate<GlobalReject>;

  /**
   * `prisma.veicule_deliveryman`: Exposes CRUD operations for the **veicule_deliveryman** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Veicule_deliverymen
    * const veicule_deliverymen = await prisma.veicule_deliveryman.findMany()
    * ```
    */
  get veicule_deliveryman(): Prisma.veicule_deliverymanDelegate<GlobalReject>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.paymentDelegate<GlobalReject>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.orderDelegate<GlobalReject>;

  /**
   * `prisma.shopping_list`: Exposes CRUD operations for the **shopping_list** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shopping_lists
    * const shopping_lists = await prisma.shopping_list.findMany()
    * ```
    */
  get shopping_list(): Prisma.shopping_listDelegate<GlobalReject>;

  /**
   * `prisma.products_in_shopping_list`: Exposes CRUD operations for the **products_in_shopping_list** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products_in_shopping_lists
    * const products_in_shopping_lists = await prisma.products_in_shopping_list.findMany()
    * ```
    */
  get products_in_shopping_list(): Prisma.products_in_shopping_listDelegate<GlobalReject>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.productDelegate<GlobalReject>;

  /**
   * `prisma.marketer`: Exposes CRUD operations for the **marketer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Marketers
    * const marketers = await prisma.marketer.findMany()
    * ```
    */
  get marketer(): Prisma.marketerDelegate<GlobalReject>;

  /**
   * `prisma.fair`: Exposes CRUD operations for the **fair** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fairs
    * const fairs = await prisma.fair.findMany()
    * ```
    */
  get fair(): Prisma.fairDelegate<GlobalReject>;

  /**
   * `prisma.fair_marketers`: Exposes CRUD operations for the **fair_marketers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fair_marketers
    * const fair_marketers = await prisma.fair_marketers.findMany()
    * ```
    */
  get fair_marketers(): Prisma.fair_marketersDelegate<GlobalReject>;

  /**
   * `prisma.costumer_addresses`: Exposes CRUD operations for the **costumer_addresses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Costumer_addresses
    * const costumer_addresses = await prisma.costumer_addresses.findMany()
    * ```
    */
  get costumer_addresses(): Prisma.costumer_addressesDelegate<GlobalReject>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.locationDelegate<GlobalReject>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.addressDelegate<GlobalReject>;

  /**
   * `prisma.address_type`: Exposes CRUD operations for the **address_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Address_types
    * const address_types = await prisma.address_type.findMany()
    * ```
    */
  get address_type(): Prisma.address_typeDelegate<GlobalReject>;

  /**
   * `prisma.veicule`: Exposes CRUD operations for the **veicule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Veicules
    * const veicules = await prisma.veicule.findMany()
    * ```
    */
  get veicule(): Prisma.veiculeDelegate<GlobalReject>;

  /**
   * `prisma.image_of_product`: Exposes CRUD operations for the **image_of_product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Image_of_products
    * const image_of_products = await prisma.image_of_product.findMany()
    * ```
    */
  get image_of_product(): Prisma.image_of_productDelegate<GlobalReject>;

  /**
   * `prisma.image`: Exposes CRUD operations for the **image** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Images
    * const images = await prisma.image.findMany()
    * ```
    */
  get image(): Prisma.imageDelegate<GlobalReject>;

  /**
   * `prisma.payment_method`: Exposes CRUD operations for the **payment_method** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payment_methods
    * const payment_methods = await prisma.payment_method.findMany()
    * ```
    */
  get payment_method(): Prisma.payment_methodDelegate<GlobalReject>;

  /**
   * `prisma.fair_date_hour_of_work`: Exposes CRUD operations for the **fair_date_hour_of_work** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fair_date_hour_of_works
    * const fair_date_hour_of_works = await prisma.fair_date_hour_of_work.findMany()
    * ```
    */
  get fair_date_hour_of_work(): Prisma.fair_date_hour_of_workDelegate<GlobalReject>;

  /**
   * `prisma.date_and_hour_of_work`: Exposes CRUD operations for the **date_and_hour_of_work** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Date_and_hour_of_works
    * const date_and_hour_of_works = await prisma.date_and_hour_of_work.findMany()
    * ```
    */
  get date_and_hour_of_work(): Prisma.date_and_hour_of_workDelegate<GlobalReject>;

  /**
   * `prisma.day_of_week`: Exposes CRUD operations for the **day_of_week** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Day_of_weeks
    * const day_of_weeks = await prisma.day_of_week.findMany()
    * ```
    */
  get day_of_week(): Prisma.day_of_weekDelegate<GlobalReject>;

  /**
   * `prisma.gender`: Exposes CRUD operations for the **gender** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Genders
    * const genders = await prisma.gender.findMany()
    * ```
    */
  get gender(): Prisma.genderDelegate<GlobalReject>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **city** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.cityDelegate<GlobalReject>;

  /**
   * `prisma.neighborhood`: Exposes CRUD operations for the **neighborhood** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Neighborhoods
    * const neighborhoods = await prisma.neighborhood.findMany()
    * ```
    */
  get neighborhood(): Prisma.neighborhoodDelegate<GlobalReject>;

  /**
   * `prisma.uf`: Exposes CRUD operations for the **uf** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ufs
    * const ufs = await prisma.uf.findMany()
    * ```
    */
  get uf(): Prisma.ufDelegate<GlobalReject>;

  /**
   * `prisma.category_of_product`: Exposes CRUD operations for the **category_of_product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Category_of_products
    * const category_of_products = await prisma.category_of_product.findMany()
    * ```
    */
  get category_of_product(): Prisma.category_of_productDelegate<GlobalReject>;

  /**
   * `prisma.sale_off`: Exposes CRUD operations for the **sale_off** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sale_offs
    * const sale_offs = await prisma.sale_off.findMany()
    * ```
    */
  get sale_off(): Prisma.sale_offDelegate<GlobalReject>;

  /**
   * `prisma.type_of_price`: Exposes CRUD operations for the **type_of_price** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Type_of_prices
    * const type_of_prices = await prisma.type_of_price.findMany()
    * ```
    */
  get type_of_price(): Prisma.type_of_priceDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.12.0
   * Query Engine version: 659ef412370fa3b41cd7bf6e94587c1dfb7f67e7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    costumer: 'costumer',
    deliveryman: 'deliveryman',
    veicule_deliveryman: 'veicule_deliveryman',
    payment: 'payment',
    order: 'order',
    shopping_list: 'shopping_list',
    products_in_shopping_list: 'products_in_shopping_list',
    product: 'product',
    marketer: 'marketer',
    fair: 'fair',
    fair_marketers: 'fair_marketers',
    costumer_addresses: 'costumer_addresses',
    location: 'location',
    address: 'address',
    address_type: 'address_type',
    veicule: 'veicule',
    image_of_product: 'image_of_product',
    image: 'image',
    payment_method: 'payment_method',
    fair_date_hour_of_work: 'fair_date_hour_of_work',
    date_and_hour_of_work: 'date_and_hour_of_work',
    day_of_week: 'day_of_week',
    gender: 'gender',
    city: 'city',
    neighborhood: 'neighborhood',
    uf: 'uf',
    category_of_product: 'category_of_product',
    sale_off: 'sale_off',
    type_of_price: 'type_of_price'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CostumerCountOutputType
   */


  export type CostumerCountOutputType = {
    costumer_addresses: number
    shopping_lists: number
  }

  export type CostumerCountOutputTypeSelect = {
    costumer_addresses?: boolean
    shopping_lists?: boolean
  }

  export type CostumerCountOutputTypeGetPayload<S extends boolean | null | undefined | CostumerCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CostumerCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CostumerCountOutputTypeArgs)
    ? CostumerCountOutputType 
    : S extends { select: any } & (CostumerCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CostumerCountOutputType ? CostumerCountOutputType[P] : never
  } 
      : CostumerCountOutputType




  // Custom InputTypes

  /**
   * CostumerCountOutputType without action
   */
  export type CostumerCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CostumerCountOutputType
     */
    select?: CostumerCountOutputTypeSelect | null
  }



  /**
   * Count Type DeliverymanCountOutputType
   */


  export type DeliverymanCountOutputType = {
    order: number
    veicule_deliveryman: number
  }

  export type DeliverymanCountOutputTypeSelect = {
    order?: boolean
    veicule_deliveryman?: boolean
  }

  export type DeliverymanCountOutputTypeGetPayload<S extends boolean | null | undefined | DeliverymanCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DeliverymanCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (DeliverymanCountOutputTypeArgs)
    ? DeliverymanCountOutputType 
    : S extends { select: any } & (DeliverymanCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof DeliverymanCountOutputType ? DeliverymanCountOutputType[P] : never
  } 
      : DeliverymanCountOutputType




  // Custom InputTypes

  /**
   * DeliverymanCountOutputType without action
   */
  export type DeliverymanCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DeliverymanCountOutputType
     */
    select?: DeliverymanCountOutputTypeSelect | null
  }



  /**
   * Count Type Shopping_listCountOutputType
   */


  export type Shopping_listCountOutputType = {
    products_in_shopping_list: number
  }

  export type Shopping_listCountOutputTypeSelect = {
    products_in_shopping_list?: boolean
  }

  export type Shopping_listCountOutputTypeGetPayload<S extends boolean | null | undefined | Shopping_listCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Shopping_listCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Shopping_listCountOutputTypeArgs)
    ? Shopping_listCountOutputType 
    : S extends { select: any } & (Shopping_listCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Shopping_listCountOutputType ? Shopping_listCountOutputType[P] : never
  } 
      : Shopping_listCountOutputType




  // Custom InputTypes

  /**
   * Shopping_listCountOutputType without action
   */
  export type Shopping_listCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Shopping_listCountOutputType
     */
    select?: Shopping_listCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductCountOutputType
   */


  export type ProductCountOutputType = {
    image_of_product: number
    products_in_shopping_list: number
    sale_off: number
  }

  export type ProductCountOutputTypeSelect = {
    image_of_product?: boolean
    products_in_shopping_list?: boolean
    sale_off?: boolean
  }

  export type ProductCountOutputTypeGetPayload<S extends boolean | null | undefined | ProductCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProductCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ProductCountOutputTypeArgs)
    ? ProductCountOutputType 
    : S extends { select: any } & (ProductCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ProductCountOutputType ? ProductCountOutputType[P] : never
  } 
      : ProductCountOutputType




  // Custom InputTypes

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect | null
  }



  /**
   * Count Type MarketerCountOutputType
   */


  export type MarketerCountOutputType = {
    fair_marketers: number
    products: number
  }

  export type MarketerCountOutputTypeSelect = {
    fair_marketers?: boolean
    products?: boolean
  }

  export type MarketerCountOutputTypeGetPayload<S extends boolean | null | undefined | MarketerCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MarketerCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MarketerCountOutputTypeArgs)
    ? MarketerCountOutputType 
    : S extends { select: any } & (MarketerCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MarketerCountOutputType ? MarketerCountOutputType[P] : never
  } 
      : MarketerCountOutputType




  // Custom InputTypes

  /**
   * MarketerCountOutputType without action
   */
  export type MarketerCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MarketerCountOutputType
     */
    select?: MarketerCountOutputTypeSelect | null
  }



  /**
   * Count Type FairCountOutputType
   */


  export type FairCountOutputType = {
    fair_date_hour_of_work: number
    fair_marketers: number
    image: number
  }

  export type FairCountOutputTypeSelect = {
    fair_date_hour_of_work?: boolean
    fair_marketers?: boolean
    image?: boolean
  }

  export type FairCountOutputTypeGetPayload<S extends boolean | null | undefined | FairCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FairCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (FairCountOutputTypeArgs)
    ? FairCountOutputType 
    : S extends { select: any } & (FairCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FairCountOutputType ? FairCountOutputType[P] : never
  } 
      : FairCountOutputType




  // Custom InputTypes

  /**
   * FairCountOutputType without action
   */
  export type FairCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FairCountOutputType
     */
    select?: FairCountOutputTypeSelect | null
  }



  /**
   * Count Type Costumer_addressesCountOutputType
   */


  export type Costumer_addressesCountOutputType = {
    order: number
  }

  export type Costumer_addressesCountOutputTypeSelect = {
    order?: boolean
  }

  export type Costumer_addressesCountOutputTypeGetPayload<S extends boolean | null | undefined | Costumer_addressesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Costumer_addressesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Costumer_addressesCountOutputTypeArgs)
    ? Costumer_addressesCountOutputType 
    : S extends { select: any } & (Costumer_addressesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Costumer_addressesCountOutputType ? Costumer_addressesCountOutputType[P] : never
  } 
      : Costumer_addressesCountOutputType




  // Custom InputTypes

  /**
   * Costumer_addressesCountOutputType without action
   */
  export type Costumer_addressesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Costumer_addressesCountOutputType
     */
    select?: Costumer_addressesCountOutputTypeSelect | null
  }



  /**
   * Count Type LocationCountOutputType
   */


  export type LocationCountOutputType = {
    address: number
    fair: number
  }

  export type LocationCountOutputTypeSelect = {
    address?: boolean
    fair?: boolean
  }

  export type LocationCountOutputTypeGetPayload<S extends boolean | null | undefined | LocationCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? LocationCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (LocationCountOutputTypeArgs)
    ? LocationCountOutputType 
    : S extends { select: any } & (LocationCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof LocationCountOutputType ? LocationCountOutputType[P] : never
  } 
      : LocationCountOutputType




  // Custom InputTypes

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect | null
  }



  /**
   * Count Type AddressCountOutputType
   */


  export type AddressCountOutputType = {
    costumer_addresses: number
  }

  export type AddressCountOutputTypeSelect = {
    costumer_addresses?: boolean
  }

  export type AddressCountOutputTypeGetPayload<S extends boolean | null | undefined | AddressCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AddressCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (AddressCountOutputTypeArgs)
    ? AddressCountOutputType 
    : S extends { select: any } & (AddressCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof AddressCountOutputType ? AddressCountOutputType[P] : never
  } 
      : AddressCountOutputType




  // Custom InputTypes

  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AddressCountOutputType
     */
    select?: AddressCountOutputTypeSelect | null
  }



  /**
   * Count Type Address_typeCountOutputType
   */


  export type Address_typeCountOutputType = {
    address: number
  }

  export type Address_typeCountOutputTypeSelect = {
    address?: boolean
  }

  export type Address_typeCountOutputTypeGetPayload<S extends boolean | null | undefined | Address_typeCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Address_typeCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Address_typeCountOutputTypeArgs)
    ? Address_typeCountOutputType 
    : S extends { select: any } & (Address_typeCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Address_typeCountOutputType ? Address_typeCountOutputType[P] : never
  } 
      : Address_typeCountOutputType




  // Custom InputTypes

  /**
   * Address_typeCountOutputType without action
   */
  export type Address_typeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Address_typeCountOutputType
     */
    select?: Address_typeCountOutputTypeSelect | null
  }



  /**
   * Count Type VeiculeCountOutputType
   */


  export type VeiculeCountOutputType = {
    veicule_deliveryman: number
  }

  export type VeiculeCountOutputTypeSelect = {
    veicule_deliveryman?: boolean
  }

  export type VeiculeCountOutputTypeGetPayload<S extends boolean | null | undefined | VeiculeCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? VeiculeCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (VeiculeCountOutputTypeArgs)
    ? VeiculeCountOutputType 
    : S extends { select: any } & (VeiculeCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof VeiculeCountOutputType ? VeiculeCountOutputType[P] : never
  } 
      : VeiculeCountOutputType




  // Custom InputTypes

  /**
   * VeiculeCountOutputType without action
   */
  export type VeiculeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the VeiculeCountOutputType
     */
    select?: VeiculeCountOutputTypeSelect | null
  }



  /**
   * Count Type ImageCountOutputType
   */


  export type ImageCountOutputType = {
    category_of_product: number
    image_of_product: number
  }

  export type ImageCountOutputTypeSelect = {
    category_of_product?: boolean
    image_of_product?: boolean
  }

  export type ImageCountOutputTypeGetPayload<S extends boolean | null | undefined | ImageCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ImageCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ImageCountOutputTypeArgs)
    ? ImageCountOutputType 
    : S extends { select: any } & (ImageCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ImageCountOutputType ? ImageCountOutputType[P] : never
  } 
      : ImageCountOutputType




  // Custom InputTypes

  /**
   * ImageCountOutputType without action
   */
  export type ImageCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ImageCountOutputType
     */
    select?: ImageCountOutputTypeSelect | null
  }



  /**
   * Count Type Payment_methodCountOutputType
   */


  export type Payment_methodCountOutputType = {
    payment: number
  }

  export type Payment_methodCountOutputTypeSelect = {
    payment?: boolean
  }

  export type Payment_methodCountOutputTypeGetPayload<S extends boolean | null | undefined | Payment_methodCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Payment_methodCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Payment_methodCountOutputTypeArgs)
    ? Payment_methodCountOutputType 
    : S extends { select: any } & (Payment_methodCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Payment_methodCountOutputType ? Payment_methodCountOutputType[P] : never
  } 
      : Payment_methodCountOutputType




  // Custom InputTypes

  /**
   * Payment_methodCountOutputType without action
   */
  export type Payment_methodCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Payment_methodCountOutputType
     */
    select?: Payment_methodCountOutputTypeSelect | null
  }



  /**
   * Count Type Date_and_hour_of_workCountOutputType
   */


  export type Date_and_hour_of_workCountOutputType = {
    fair_date_hour_of_work: number
  }

  export type Date_and_hour_of_workCountOutputTypeSelect = {
    fair_date_hour_of_work?: boolean
  }

  export type Date_and_hour_of_workCountOutputTypeGetPayload<S extends boolean | null | undefined | Date_and_hour_of_workCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Date_and_hour_of_workCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Date_and_hour_of_workCountOutputTypeArgs)
    ? Date_and_hour_of_workCountOutputType 
    : S extends { select: any } & (Date_and_hour_of_workCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Date_and_hour_of_workCountOutputType ? Date_and_hour_of_workCountOutputType[P] : never
  } 
      : Date_and_hour_of_workCountOutputType




  // Custom InputTypes

  /**
   * Date_and_hour_of_workCountOutputType without action
   */
  export type Date_and_hour_of_workCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Date_and_hour_of_workCountOutputType
     */
    select?: Date_and_hour_of_workCountOutputTypeSelect | null
  }



  /**
   * Count Type Day_of_weekCountOutputType
   */


  export type Day_of_weekCountOutputType = {
    date_and_hour_of_work: number
  }

  export type Day_of_weekCountOutputTypeSelect = {
    date_and_hour_of_work?: boolean
  }

  export type Day_of_weekCountOutputTypeGetPayload<S extends boolean | null | undefined | Day_of_weekCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Day_of_weekCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Day_of_weekCountOutputTypeArgs)
    ? Day_of_weekCountOutputType 
    : S extends { select: any } & (Day_of_weekCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Day_of_weekCountOutputType ? Day_of_weekCountOutputType[P] : never
  } 
      : Day_of_weekCountOutputType




  // Custom InputTypes

  /**
   * Day_of_weekCountOutputType without action
   */
  export type Day_of_weekCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Day_of_weekCountOutputType
     */
    select?: Day_of_weekCountOutputTypeSelect | null
  }



  /**
   * Count Type GenderCountOutputType
   */


  export type GenderCountOutputType = {
    costumer: number
    deliveryman: number
    marketer: number
  }

  export type GenderCountOutputTypeSelect = {
    costumer?: boolean
    deliveryman?: boolean
    marketer?: boolean
  }

  export type GenderCountOutputTypeGetPayload<S extends boolean | null | undefined | GenderCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? GenderCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (GenderCountOutputTypeArgs)
    ? GenderCountOutputType 
    : S extends { select: any } & (GenderCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof GenderCountOutputType ? GenderCountOutputType[P] : never
  } 
      : GenderCountOutputType




  // Custom InputTypes

  /**
   * GenderCountOutputType without action
   */
  export type GenderCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the GenderCountOutputType
     */
    select?: GenderCountOutputTypeSelect | null
  }



  /**
   * Count Type CityCountOutputType
   */


  export type CityCountOutputType = {
    address: number
  }

  export type CityCountOutputTypeSelect = {
    address?: boolean
  }

  export type CityCountOutputTypeGetPayload<S extends boolean | null | undefined | CityCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CityCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CityCountOutputTypeArgs)
    ? CityCountOutputType 
    : S extends { select: any } & (CityCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CityCountOutputType ? CityCountOutputType[P] : never
  } 
      : CityCountOutputType




  // Custom InputTypes

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CityCountOutputType
     */
    select?: CityCountOutputTypeSelect | null
  }



  /**
   * Count Type NeighborhoodCountOutputType
   */


  export type NeighborhoodCountOutputType = {
    address: number
  }

  export type NeighborhoodCountOutputTypeSelect = {
    address?: boolean
  }

  export type NeighborhoodCountOutputTypeGetPayload<S extends boolean | null | undefined | NeighborhoodCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? NeighborhoodCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (NeighborhoodCountOutputTypeArgs)
    ? NeighborhoodCountOutputType 
    : S extends { select: any } & (NeighborhoodCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof NeighborhoodCountOutputType ? NeighborhoodCountOutputType[P] : never
  } 
      : NeighborhoodCountOutputType




  // Custom InputTypes

  /**
   * NeighborhoodCountOutputType without action
   */
  export type NeighborhoodCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the NeighborhoodCountOutputType
     */
    select?: NeighborhoodCountOutputTypeSelect | null
  }



  /**
   * Count Type UfCountOutputType
   */


  export type UfCountOutputType = {
    address: number
  }

  export type UfCountOutputTypeSelect = {
    address?: boolean
  }

  export type UfCountOutputTypeGetPayload<S extends boolean | null | undefined | UfCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UfCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UfCountOutputTypeArgs)
    ? UfCountOutputType 
    : S extends { select: any } & (UfCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UfCountOutputType ? UfCountOutputType[P] : never
  } 
      : UfCountOutputType




  // Custom InputTypes

  /**
   * UfCountOutputType without action
   */
  export type UfCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UfCountOutputType
     */
    select?: UfCountOutputTypeSelect | null
  }



  /**
   * Count Type Category_of_productCountOutputType
   */


  export type Category_of_productCountOutputType = {
    product: number
  }

  export type Category_of_productCountOutputTypeSelect = {
    product?: boolean
  }

  export type Category_of_productCountOutputTypeGetPayload<S extends boolean | null | undefined | Category_of_productCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Category_of_productCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Category_of_productCountOutputTypeArgs)
    ? Category_of_productCountOutputType 
    : S extends { select: any } & (Category_of_productCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Category_of_productCountOutputType ? Category_of_productCountOutputType[P] : never
  } 
      : Category_of_productCountOutputType




  // Custom InputTypes

  /**
   * Category_of_productCountOutputType without action
   */
  export type Category_of_productCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Category_of_productCountOutputType
     */
    select?: Category_of_productCountOutputTypeSelect | null
  }



  /**
   * Count Type Type_of_priceCountOutputType
   */


  export type Type_of_priceCountOutputType = {
    product: number
  }

  export type Type_of_priceCountOutputTypeSelect = {
    product?: boolean
  }

  export type Type_of_priceCountOutputTypeGetPayload<S extends boolean | null | undefined | Type_of_priceCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Type_of_priceCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Type_of_priceCountOutputTypeArgs)
    ? Type_of_priceCountOutputType 
    : S extends { select: any } & (Type_of_priceCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Type_of_priceCountOutputType ? Type_of_priceCountOutputType[P] : never
  } 
      : Type_of_priceCountOutputType




  // Custom InputTypes

  /**
   * Type_of_priceCountOutputType without action
   */
  export type Type_of_priceCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Type_of_priceCountOutputType
     */
    select?: Type_of_priceCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model costumer
   */


  export type AggregateCostumer = {
    _count: CostumerCountAggregateOutputType | null
    _avg: CostumerAvgAggregateOutputType | null
    _sum: CostumerSumAggregateOutputType | null
    _min: CostumerMinAggregateOutputType | null
    _max: CostumerMaxAggregateOutputType | null
  }

  export type CostumerAvgAggregateOutputType = {
    id: number | null
    genderId: number | null
  }

  export type CostumerSumAggregateOutputType = {
    id: number | null
    genderId: number | null
  }

  export type CostumerMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password_hash: string | null
    picture_uri: string | null
    created_at: Date | null
    updated_at: Date | null
    genderId: number | null
    birthday: string | null
    cpf: string | null
  }

  export type CostumerMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password_hash: string | null
    picture_uri: string | null
    created_at: Date | null
    updated_at: Date | null
    genderId: number | null
    birthday: string | null
    cpf: string | null
  }

  export type CostumerCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password_hash: number
    picture_uri: number
    created_at: number
    updated_at: number
    genderId: number
    birthday: number
    cpf: number
    _all: number
  }


  export type CostumerAvgAggregateInputType = {
    id?: true
    genderId?: true
  }

  export type CostumerSumAggregateInputType = {
    id?: true
    genderId?: true
  }

  export type CostumerMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password_hash?: true
    picture_uri?: true
    created_at?: true
    updated_at?: true
    genderId?: true
    birthday?: true
    cpf?: true
  }

  export type CostumerMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password_hash?: true
    picture_uri?: true
    created_at?: true
    updated_at?: true
    genderId?: true
    birthday?: true
    cpf?: true
  }

  export type CostumerCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password_hash?: true
    picture_uri?: true
    created_at?: true
    updated_at?: true
    genderId?: true
    birthday?: true
    cpf?: true
    _all?: true
  }

  export type CostumerAggregateArgs = {
    /**
     * Filter which costumer to aggregate.
     */
    where?: costumerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of costumers to fetch.
     */
    orderBy?: Enumerable<costumerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: costumerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` costumers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` costumers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned costumers
    **/
    _count?: true | CostumerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CostumerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CostumerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CostumerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CostumerMaxAggregateInputType
  }

  export type GetCostumerAggregateType<T extends CostumerAggregateArgs> = {
        [P in keyof T & keyof AggregateCostumer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCostumer[P]>
      : GetScalarType<T[P], AggregateCostumer[P]>
  }




  export type CostumerGroupByArgs = {
    where?: costumerWhereInput
    orderBy?: Enumerable<costumerOrderByWithAggregationInput>
    by: CostumerScalarFieldEnum[]
    having?: costumerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CostumerCountAggregateInputType | true
    _avg?: CostumerAvgAggregateInputType
    _sum?: CostumerSumAggregateInputType
    _min?: CostumerMinAggregateInputType
    _max?: CostumerMaxAggregateInputType
  }


  export type CostumerGroupByOutputType = {
    id: number
    name: string
    email: string
    password_hash: string
    picture_uri: string | null
    created_at: Date
    updated_at: Date
    genderId: number
    birthday: string
    cpf: string | null
    _count: CostumerCountAggregateOutputType | null
    _avg: CostumerAvgAggregateOutputType | null
    _sum: CostumerSumAggregateOutputType | null
    _min: CostumerMinAggregateOutputType | null
    _max: CostumerMaxAggregateOutputType | null
  }

  type GetCostumerGroupByPayload<T extends CostumerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CostumerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CostumerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CostumerGroupByOutputType[P]>
            : GetScalarType<T[P], CostumerGroupByOutputType[P]>
        }
      >
    >


  export type costumerSelect = {
    id?: boolean
    name?: boolean
    email?: boolean
    password_hash?: boolean
    picture_uri?: boolean
    created_at?: boolean
    updated_at?: boolean
    genderId?: boolean
    birthday?: boolean
    cpf?: boolean
    gender?: boolean | genderArgs
    costumer_addresses?: boolean | costumer$costumer_addressesArgs
    shopping_lists?: boolean | costumer$shopping_listsArgs
    _count?: boolean | CostumerCountOutputTypeArgs
  }


  export type costumerInclude = {
    gender?: boolean | genderArgs
    costumer_addresses?: boolean | costumer$costumer_addressesArgs
    shopping_lists?: boolean | costumer$shopping_listsArgs
    _count?: boolean | CostumerCountOutputTypeArgs
  }

  export type costumerGetPayload<S extends boolean | null | undefined | costumerArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? costumer :
    S extends undefined ? never :
    S extends { include: any } & (costumerArgs | costumerFindManyArgs)
    ? costumer  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'gender' ? genderGetPayload<S['include'][P]> :
        P extends 'costumer_addresses' ? Array < costumer_addressesGetPayload<S['include'][P]>>  :
        P extends 'shopping_lists' ? Array < shopping_listGetPayload<S['include'][P]>>  :
        P extends '_count' ? CostumerCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (costumerArgs | costumerFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'gender' ? genderGetPayload<S['select'][P]> :
        P extends 'costumer_addresses' ? Array < costumer_addressesGetPayload<S['select'][P]>>  :
        P extends 'shopping_lists' ? Array < shopping_listGetPayload<S['select'][P]>>  :
        P extends '_count' ? CostumerCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof costumer ? costumer[P] : never
  } 
      : costumer


  type costumerCountArgs = 
    Omit<costumerFindManyArgs, 'select' | 'include'> & {
      select?: CostumerCountAggregateInputType | true
    }

  export interface costumerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Costumer that matches the filter.
     * @param {costumerFindUniqueArgs} args - Arguments to find a Costumer
     * @example
     * // Get one Costumer
     * const costumer = await prisma.costumer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends costumerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, costumerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'costumer'> extends True ? Prisma__costumerClient<costumerGetPayload<T>> : Prisma__costumerClient<costumerGetPayload<T> | null, null>

    /**
     * Find one Costumer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {costumerFindUniqueOrThrowArgs} args - Arguments to find a Costumer
     * @example
     * // Get one Costumer
     * const costumer = await prisma.costumer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends costumerFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, costumerFindUniqueOrThrowArgs>
    ): Prisma__costumerClient<costumerGetPayload<T>>

    /**
     * Find the first Costumer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costumerFindFirstArgs} args - Arguments to find a Costumer
     * @example
     * // Get one Costumer
     * const costumer = await prisma.costumer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends costumerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, costumerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'costumer'> extends True ? Prisma__costumerClient<costumerGetPayload<T>> : Prisma__costumerClient<costumerGetPayload<T> | null, null>

    /**
     * Find the first Costumer that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costumerFindFirstOrThrowArgs} args - Arguments to find a Costumer
     * @example
     * // Get one Costumer
     * const costumer = await prisma.costumer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends costumerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, costumerFindFirstOrThrowArgs>
    ): Prisma__costumerClient<costumerGetPayload<T>>

    /**
     * Find zero or more Costumers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costumerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Costumers
     * const costumers = await prisma.costumer.findMany()
     * 
     * // Get first 10 Costumers
     * const costumers = await prisma.costumer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const costumerWithIdOnly = await prisma.costumer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends costumerFindManyArgs>(
      args?: SelectSubset<T, costumerFindManyArgs>
    ): Prisma.PrismaPromise<Array<costumerGetPayload<T>>>

    /**
     * Create a Costumer.
     * @param {costumerCreateArgs} args - Arguments to create a Costumer.
     * @example
     * // Create one Costumer
     * const Costumer = await prisma.costumer.create({
     *   data: {
     *     // ... data to create a Costumer
     *   }
     * })
     * 
    **/
    create<T extends costumerCreateArgs>(
      args: SelectSubset<T, costumerCreateArgs>
    ): Prisma__costumerClient<costumerGetPayload<T>>

    /**
     * Create many Costumers.
     *     @param {costumerCreateManyArgs} args - Arguments to create many Costumers.
     *     @example
     *     // Create many Costumers
     *     const costumer = await prisma.costumer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends costumerCreateManyArgs>(
      args?: SelectSubset<T, costumerCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Costumer.
     * @param {costumerDeleteArgs} args - Arguments to delete one Costumer.
     * @example
     * // Delete one Costumer
     * const Costumer = await prisma.costumer.delete({
     *   where: {
     *     // ... filter to delete one Costumer
     *   }
     * })
     * 
    **/
    delete<T extends costumerDeleteArgs>(
      args: SelectSubset<T, costumerDeleteArgs>
    ): Prisma__costumerClient<costumerGetPayload<T>>

    /**
     * Update one Costumer.
     * @param {costumerUpdateArgs} args - Arguments to update one Costumer.
     * @example
     * // Update one Costumer
     * const costumer = await prisma.costumer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends costumerUpdateArgs>(
      args: SelectSubset<T, costumerUpdateArgs>
    ): Prisma__costumerClient<costumerGetPayload<T>>

    /**
     * Delete zero or more Costumers.
     * @param {costumerDeleteManyArgs} args - Arguments to filter Costumers to delete.
     * @example
     * // Delete a few Costumers
     * const { count } = await prisma.costumer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends costumerDeleteManyArgs>(
      args?: SelectSubset<T, costumerDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Costumers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costumerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Costumers
     * const costumer = await prisma.costumer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends costumerUpdateManyArgs>(
      args: SelectSubset<T, costumerUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Costumer.
     * @param {costumerUpsertArgs} args - Arguments to update or create a Costumer.
     * @example
     * // Update or create a Costumer
     * const costumer = await prisma.costumer.upsert({
     *   create: {
     *     // ... data to create a Costumer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Costumer we want to update
     *   }
     * })
    **/
    upsert<T extends costumerUpsertArgs>(
      args: SelectSubset<T, costumerUpsertArgs>
    ): Prisma__costumerClient<costumerGetPayload<T>>

    /**
     * Count the number of Costumers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costumerCountArgs} args - Arguments to filter Costumers to count.
     * @example
     * // Count the number of Costumers
     * const count = await prisma.costumer.count({
     *   where: {
     *     // ... the filter for the Costumers we want to count
     *   }
     * })
    **/
    count<T extends costumerCountArgs>(
      args?: Subset<T, costumerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CostumerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Costumer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostumerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CostumerAggregateArgs>(args: Subset<T, CostumerAggregateArgs>): Prisma.PrismaPromise<GetCostumerAggregateType<T>>

    /**
     * Group by Costumer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostumerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CostumerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CostumerGroupByArgs['orderBy'] }
        : { orderBy?: CostumerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CostumerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostumerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for costumer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__costumerClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    gender<T extends genderArgs= {}>(args?: Subset<T, genderArgs>): Prisma__genderClient<genderGetPayload<T> | Null>;

    costumer_addresses<T extends costumer$costumer_addressesArgs= {}>(args?: Subset<T, costumer$costumer_addressesArgs>): Prisma.PrismaPromise<Array<costumer_addressesGetPayload<T>>| Null>;

    shopping_lists<T extends costumer$shopping_listsArgs= {}>(args?: Subset<T, costumer$shopping_listsArgs>): Prisma.PrismaPromise<Array<shopping_listGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * costumer base type for findUnique actions
   */
  export type costumerFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the costumer
     */
    select?: costumerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: costumerInclude | null
    /**
     * Filter, which costumer to fetch.
     */
    where: costumerWhereUniqueInput
  }

  /**
   * costumer findUnique
   */
  export interface costumerFindUniqueArgs extends costumerFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * costumer findUniqueOrThrow
   */
  export type costumerFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the costumer
     */
    select?: costumerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: costumerInclude | null
    /**
     * Filter, which costumer to fetch.
     */
    where: costumerWhereUniqueInput
  }


  /**
   * costumer base type for findFirst actions
   */
  export type costumerFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the costumer
     */
    select?: costumerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: costumerInclude | null
    /**
     * Filter, which costumer to fetch.
     */
    where?: costumerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of costumers to fetch.
     */
    orderBy?: Enumerable<costumerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for costumers.
     */
    cursor?: costumerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` costumers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` costumers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of costumers.
     */
    distinct?: Enumerable<CostumerScalarFieldEnum>
  }

  /**
   * costumer findFirst
   */
  export interface costumerFindFirstArgs extends costumerFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * costumer findFirstOrThrow
   */
  export type costumerFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the costumer
     */
    select?: costumerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: costumerInclude | null
    /**
     * Filter, which costumer to fetch.
     */
    where?: costumerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of costumers to fetch.
     */
    orderBy?: Enumerable<costumerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for costumers.
     */
    cursor?: costumerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` costumers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` costumers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of costumers.
     */
    distinct?: Enumerable<CostumerScalarFieldEnum>
  }


  /**
   * costumer findMany
   */
  export type costumerFindManyArgs = {
    /**
     * Select specific fields to fetch from the costumer
     */
    select?: costumerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: costumerInclude | null
    /**
     * Filter, which costumers to fetch.
     */
    where?: costumerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of costumers to fetch.
     */
    orderBy?: Enumerable<costumerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing costumers.
     */
    cursor?: costumerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` costumers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` costumers.
     */
    skip?: number
    distinct?: Enumerable<CostumerScalarFieldEnum>
  }


  /**
   * costumer create
   */
  export type costumerCreateArgs = {
    /**
     * Select specific fields to fetch from the costumer
     */
    select?: costumerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: costumerInclude | null
    /**
     * The data needed to create a costumer.
     */
    data: XOR<costumerCreateInput, costumerUncheckedCreateInput>
  }


  /**
   * costumer createMany
   */
  export type costumerCreateManyArgs = {
    /**
     * The data used to create many costumers.
     */
    data: Enumerable<costumerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * costumer update
   */
  export type costumerUpdateArgs = {
    /**
     * Select specific fields to fetch from the costumer
     */
    select?: costumerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: costumerInclude | null
    /**
     * The data needed to update a costumer.
     */
    data: XOR<costumerUpdateInput, costumerUncheckedUpdateInput>
    /**
     * Choose, which costumer to update.
     */
    where: costumerWhereUniqueInput
  }


  /**
   * costumer updateMany
   */
  export type costumerUpdateManyArgs = {
    /**
     * The data used to update costumers.
     */
    data: XOR<costumerUpdateManyMutationInput, costumerUncheckedUpdateManyInput>
    /**
     * Filter which costumers to update
     */
    where?: costumerWhereInput
  }


  /**
   * costumer upsert
   */
  export type costumerUpsertArgs = {
    /**
     * Select specific fields to fetch from the costumer
     */
    select?: costumerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: costumerInclude | null
    /**
     * The filter to search for the costumer to update in case it exists.
     */
    where: costumerWhereUniqueInput
    /**
     * In case the costumer found by the `where` argument doesn't exist, create a new costumer with this data.
     */
    create: XOR<costumerCreateInput, costumerUncheckedCreateInput>
    /**
     * In case the costumer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<costumerUpdateInput, costumerUncheckedUpdateInput>
  }


  /**
   * costumer delete
   */
  export type costumerDeleteArgs = {
    /**
     * Select specific fields to fetch from the costumer
     */
    select?: costumerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: costumerInclude | null
    /**
     * Filter which costumer to delete.
     */
    where: costumerWhereUniqueInput
  }


  /**
   * costumer deleteMany
   */
  export type costumerDeleteManyArgs = {
    /**
     * Filter which costumers to delete
     */
    where?: costumerWhereInput
  }


  /**
   * costumer.costumer_addresses
   */
  export type costumer$costumer_addressesArgs = {
    /**
     * Select specific fields to fetch from the costumer_addresses
     */
    select?: costumer_addressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: costumer_addressesInclude | null
    where?: costumer_addressesWhereInput
    orderBy?: Enumerable<costumer_addressesOrderByWithRelationInput>
    cursor?: costumer_addressesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Costumer_addressesScalarFieldEnum>
  }


  /**
   * costumer.shopping_lists
   */
  export type costumer$shopping_listsArgs = {
    /**
     * Select specific fields to fetch from the shopping_list
     */
    select?: shopping_listSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shopping_listInclude | null
    where?: shopping_listWhereInput
    orderBy?: Enumerable<shopping_listOrderByWithRelationInput>
    cursor?: shopping_listWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Shopping_listScalarFieldEnum>
  }


  /**
   * costumer without action
   */
  export type costumerArgs = {
    /**
     * Select specific fields to fetch from the costumer
     */
    select?: costumerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: costumerInclude | null
  }



  /**
   * Model deliveryman
   */


  export type AggregateDeliveryman = {
    _count: DeliverymanCountAggregateOutputType | null
    _avg: DeliverymanAvgAggregateOutputType | null
    _sum: DeliverymanSumAggregateOutputType | null
    _min: DeliverymanMinAggregateOutputType | null
    _max: DeliverymanMaxAggregateOutputType | null
  }

  export type DeliverymanAvgAggregateOutputType = {
    id: number | null
    locationId: number | null
    genderId: number | null
  }

  export type DeliverymanSumAggregateOutputType = {
    id: number | null
    locationId: number | null
    genderId: number | null
  }

  export type DeliverymanMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password_hash: string | null
    picture_uri: string | null
    locationId: number | null
    online: boolean | null
    created_at: Date | null
    updated_at: Date | null
    genderId: number | null
    birthday: string | null
  }

  export type DeliverymanMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password_hash: string | null
    picture_uri: string | null
    locationId: number | null
    online: boolean | null
    created_at: Date | null
    updated_at: Date | null
    genderId: number | null
    birthday: string | null
  }

  export type DeliverymanCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password_hash: number
    picture_uri: number
    locationId: number
    online: number
    created_at: number
    updated_at: number
    genderId: number
    birthday: number
    _all: number
  }


  export type DeliverymanAvgAggregateInputType = {
    id?: true
    locationId?: true
    genderId?: true
  }

  export type DeliverymanSumAggregateInputType = {
    id?: true
    locationId?: true
    genderId?: true
  }

  export type DeliverymanMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password_hash?: true
    picture_uri?: true
    locationId?: true
    online?: true
    created_at?: true
    updated_at?: true
    genderId?: true
    birthday?: true
  }

  export type DeliverymanMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password_hash?: true
    picture_uri?: true
    locationId?: true
    online?: true
    created_at?: true
    updated_at?: true
    genderId?: true
    birthday?: true
  }

  export type DeliverymanCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password_hash?: true
    picture_uri?: true
    locationId?: true
    online?: true
    created_at?: true
    updated_at?: true
    genderId?: true
    birthday?: true
    _all?: true
  }

  export type DeliverymanAggregateArgs = {
    /**
     * Filter which deliveryman to aggregate.
     */
    where?: deliverymanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deliverymen to fetch.
     */
    orderBy?: Enumerable<deliverymanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: deliverymanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deliverymen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deliverymen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned deliverymen
    **/
    _count?: true | DeliverymanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliverymanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliverymanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliverymanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliverymanMaxAggregateInputType
  }

  export type GetDeliverymanAggregateType<T extends DeliverymanAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryman]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryman[P]>
      : GetScalarType<T[P], AggregateDeliveryman[P]>
  }




  export type DeliverymanGroupByArgs = {
    where?: deliverymanWhereInput
    orderBy?: Enumerable<deliverymanOrderByWithAggregationInput>
    by: DeliverymanScalarFieldEnum[]
    having?: deliverymanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliverymanCountAggregateInputType | true
    _avg?: DeliverymanAvgAggregateInputType
    _sum?: DeliverymanSumAggregateInputType
    _min?: DeliverymanMinAggregateInputType
    _max?: DeliverymanMaxAggregateInputType
  }


  export type DeliverymanGroupByOutputType = {
    id: number
    name: string
    email: string
    password_hash: string
    picture_uri: string
    locationId: number
    online: boolean
    created_at: Date
    updated_at: Date
    genderId: number
    birthday: string
    _count: DeliverymanCountAggregateOutputType | null
    _avg: DeliverymanAvgAggregateOutputType | null
    _sum: DeliverymanSumAggregateOutputType | null
    _min: DeliverymanMinAggregateOutputType | null
    _max: DeliverymanMaxAggregateOutputType | null
  }

  type GetDeliverymanGroupByPayload<T extends DeliverymanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DeliverymanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliverymanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliverymanGroupByOutputType[P]>
            : GetScalarType<T[P], DeliverymanGroupByOutputType[P]>
        }
      >
    >


  export type deliverymanSelect = {
    id?: boolean
    name?: boolean
    email?: boolean
    password_hash?: boolean
    picture_uri?: boolean
    locationId?: boolean
    online?: boolean
    created_at?: boolean
    updated_at?: boolean
    genderId?: boolean
    birthday?: boolean
    gender?: boolean | genderArgs
    location?: boolean | locationArgs
    order?: boolean | deliveryman$orderArgs
    veicule_deliveryman?: boolean | deliveryman$veicule_deliverymanArgs
    _count?: boolean | DeliverymanCountOutputTypeArgs
  }


  export type deliverymanInclude = {
    gender?: boolean | genderArgs
    location?: boolean | locationArgs
    order?: boolean | deliveryman$orderArgs
    veicule_deliveryman?: boolean | deliveryman$veicule_deliverymanArgs
    _count?: boolean | DeliverymanCountOutputTypeArgs
  }

  export type deliverymanGetPayload<S extends boolean | null | undefined | deliverymanArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? deliveryman :
    S extends undefined ? never :
    S extends { include: any } & (deliverymanArgs | deliverymanFindManyArgs)
    ? deliveryman  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'gender' ? genderGetPayload<S['include'][P]> :
        P extends 'location' ? locationGetPayload<S['include'][P]> :
        P extends 'order' ? Array < orderGetPayload<S['include'][P]>>  :
        P extends 'veicule_deliveryman' ? Array < veicule_deliverymanGetPayload<S['include'][P]>>  :
        P extends '_count' ? DeliverymanCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (deliverymanArgs | deliverymanFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'gender' ? genderGetPayload<S['select'][P]> :
        P extends 'location' ? locationGetPayload<S['select'][P]> :
        P extends 'order' ? Array < orderGetPayload<S['select'][P]>>  :
        P extends 'veicule_deliveryman' ? Array < veicule_deliverymanGetPayload<S['select'][P]>>  :
        P extends '_count' ? DeliverymanCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof deliveryman ? deliveryman[P] : never
  } 
      : deliveryman


  type deliverymanCountArgs = 
    Omit<deliverymanFindManyArgs, 'select' | 'include'> & {
      select?: DeliverymanCountAggregateInputType | true
    }

  export interface deliverymanDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Deliveryman that matches the filter.
     * @param {deliverymanFindUniqueArgs} args - Arguments to find a Deliveryman
     * @example
     * // Get one Deliveryman
     * const deliveryman = await prisma.deliveryman.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends deliverymanFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, deliverymanFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'deliveryman'> extends True ? Prisma__deliverymanClient<deliverymanGetPayload<T>> : Prisma__deliverymanClient<deliverymanGetPayload<T> | null, null>

    /**
     * Find one Deliveryman that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {deliverymanFindUniqueOrThrowArgs} args - Arguments to find a Deliveryman
     * @example
     * // Get one Deliveryman
     * const deliveryman = await prisma.deliveryman.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends deliverymanFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, deliverymanFindUniqueOrThrowArgs>
    ): Prisma__deliverymanClient<deliverymanGetPayload<T>>

    /**
     * Find the first Deliveryman that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deliverymanFindFirstArgs} args - Arguments to find a Deliveryman
     * @example
     * // Get one Deliveryman
     * const deliveryman = await prisma.deliveryman.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends deliverymanFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, deliverymanFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'deliveryman'> extends True ? Prisma__deliverymanClient<deliverymanGetPayload<T>> : Prisma__deliverymanClient<deliverymanGetPayload<T> | null, null>

    /**
     * Find the first Deliveryman that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deliverymanFindFirstOrThrowArgs} args - Arguments to find a Deliveryman
     * @example
     * // Get one Deliveryman
     * const deliveryman = await prisma.deliveryman.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends deliverymanFindFirstOrThrowArgs>(
      args?: SelectSubset<T, deliverymanFindFirstOrThrowArgs>
    ): Prisma__deliverymanClient<deliverymanGetPayload<T>>

    /**
     * Find zero or more Deliverymen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deliverymanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deliverymen
     * const deliverymen = await prisma.deliveryman.findMany()
     * 
     * // Get first 10 Deliverymen
     * const deliverymen = await prisma.deliveryman.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliverymanWithIdOnly = await prisma.deliveryman.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends deliverymanFindManyArgs>(
      args?: SelectSubset<T, deliverymanFindManyArgs>
    ): Prisma.PrismaPromise<Array<deliverymanGetPayload<T>>>

    /**
     * Create a Deliveryman.
     * @param {deliverymanCreateArgs} args - Arguments to create a Deliveryman.
     * @example
     * // Create one Deliveryman
     * const Deliveryman = await prisma.deliveryman.create({
     *   data: {
     *     // ... data to create a Deliveryman
     *   }
     * })
     * 
    **/
    create<T extends deliverymanCreateArgs>(
      args: SelectSubset<T, deliverymanCreateArgs>
    ): Prisma__deliverymanClient<deliverymanGetPayload<T>>

    /**
     * Create many Deliverymen.
     *     @param {deliverymanCreateManyArgs} args - Arguments to create many Deliverymen.
     *     @example
     *     // Create many Deliverymen
     *     const deliveryman = await prisma.deliveryman.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends deliverymanCreateManyArgs>(
      args?: SelectSubset<T, deliverymanCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Deliveryman.
     * @param {deliverymanDeleteArgs} args - Arguments to delete one Deliveryman.
     * @example
     * // Delete one Deliveryman
     * const Deliveryman = await prisma.deliveryman.delete({
     *   where: {
     *     // ... filter to delete one Deliveryman
     *   }
     * })
     * 
    **/
    delete<T extends deliverymanDeleteArgs>(
      args: SelectSubset<T, deliverymanDeleteArgs>
    ): Prisma__deliverymanClient<deliverymanGetPayload<T>>

    /**
     * Update one Deliveryman.
     * @param {deliverymanUpdateArgs} args - Arguments to update one Deliveryman.
     * @example
     * // Update one Deliveryman
     * const deliveryman = await prisma.deliveryman.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends deliverymanUpdateArgs>(
      args: SelectSubset<T, deliverymanUpdateArgs>
    ): Prisma__deliverymanClient<deliverymanGetPayload<T>>

    /**
     * Delete zero or more Deliverymen.
     * @param {deliverymanDeleteManyArgs} args - Arguments to filter Deliverymen to delete.
     * @example
     * // Delete a few Deliverymen
     * const { count } = await prisma.deliveryman.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends deliverymanDeleteManyArgs>(
      args?: SelectSubset<T, deliverymanDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deliverymen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deliverymanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deliverymen
     * const deliveryman = await prisma.deliveryman.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends deliverymanUpdateManyArgs>(
      args: SelectSubset<T, deliverymanUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Deliveryman.
     * @param {deliverymanUpsertArgs} args - Arguments to update or create a Deliveryman.
     * @example
     * // Update or create a Deliveryman
     * const deliveryman = await prisma.deliveryman.upsert({
     *   create: {
     *     // ... data to create a Deliveryman
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deliveryman we want to update
     *   }
     * })
    **/
    upsert<T extends deliverymanUpsertArgs>(
      args: SelectSubset<T, deliverymanUpsertArgs>
    ): Prisma__deliverymanClient<deliverymanGetPayload<T>>

    /**
     * Count the number of Deliverymen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deliverymanCountArgs} args - Arguments to filter Deliverymen to count.
     * @example
     * // Count the number of Deliverymen
     * const count = await prisma.deliveryman.count({
     *   where: {
     *     // ... the filter for the Deliverymen we want to count
     *   }
     * })
    **/
    count<T extends deliverymanCountArgs>(
      args?: Subset<T, deliverymanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliverymanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deliveryman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliverymanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliverymanAggregateArgs>(args: Subset<T, DeliverymanAggregateArgs>): Prisma.PrismaPromise<GetDeliverymanAggregateType<T>>

    /**
     * Group by Deliveryman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliverymanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliverymanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliverymanGroupByArgs['orderBy'] }
        : { orderBy?: DeliverymanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliverymanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliverymanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for deliveryman.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__deliverymanClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    gender<T extends genderArgs= {}>(args?: Subset<T, genderArgs>): Prisma__genderClient<genderGetPayload<T> | Null>;

    location<T extends locationArgs= {}>(args?: Subset<T, locationArgs>): Prisma__locationClient<locationGetPayload<T> | Null>;

    order<T extends deliveryman$orderArgs= {}>(args?: Subset<T, deliveryman$orderArgs>): Prisma.PrismaPromise<Array<orderGetPayload<T>>| Null>;

    veicule_deliveryman<T extends deliveryman$veicule_deliverymanArgs= {}>(args?: Subset<T, deliveryman$veicule_deliverymanArgs>): Prisma.PrismaPromise<Array<veicule_deliverymanGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * deliveryman base type for findUnique actions
   */
  export type deliverymanFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the deliveryman
     */
    select?: deliverymanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: deliverymanInclude | null
    /**
     * Filter, which deliveryman to fetch.
     */
    where: deliverymanWhereUniqueInput
  }

  /**
   * deliveryman findUnique
   */
  export interface deliverymanFindUniqueArgs extends deliverymanFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * deliveryman findUniqueOrThrow
   */
  export type deliverymanFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the deliveryman
     */
    select?: deliverymanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: deliverymanInclude | null
    /**
     * Filter, which deliveryman to fetch.
     */
    where: deliverymanWhereUniqueInput
  }


  /**
   * deliveryman base type for findFirst actions
   */
  export type deliverymanFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the deliveryman
     */
    select?: deliverymanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: deliverymanInclude | null
    /**
     * Filter, which deliveryman to fetch.
     */
    where?: deliverymanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deliverymen to fetch.
     */
    orderBy?: Enumerable<deliverymanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for deliverymen.
     */
    cursor?: deliverymanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deliverymen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deliverymen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of deliverymen.
     */
    distinct?: Enumerable<DeliverymanScalarFieldEnum>
  }

  /**
   * deliveryman findFirst
   */
  export interface deliverymanFindFirstArgs extends deliverymanFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * deliveryman findFirstOrThrow
   */
  export type deliverymanFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the deliveryman
     */
    select?: deliverymanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: deliverymanInclude | null
    /**
     * Filter, which deliveryman to fetch.
     */
    where?: deliverymanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deliverymen to fetch.
     */
    orderBy?: Enumerable<deliverymanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for deliverymen.
     */
    cursor?: deliverymanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deliverymen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deliverymen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of deliverymen.
     */
    distinct?: Enumerable<DeliverymanScalarFieldEnum>
  }


  /**
   * deliveryman findMany
   */
  export type deliverymanFindManyArgs = {
    /**
     * Select specific fields to fetch from the deliveryman
     */
    select?: deliverymanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: deliverymanInclude | null
    /**
     * Filter, which deliverymen to fetch.
     */
    where?: deliverymanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deliverymen to fetch.
     */
    orderBy?: Enumerable<deliverymanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing deliverymen.
     */
    cursor?: deliverymanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deliverymen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deliverymen.
     */
    skip?: number
    distinct?: Enumerable<DeliverymanScalarFieldEnum>
  }


  /**
   * deliveryman create
   */
  export type deliverymanCreateArgs = {
    /**
     * Select specific fields to fetch from the deliveryman
     */
    select?: deliverymanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: deliverymanInclude | null
    /**
     * The data needed to create a deliveryman.
     */
    data: XOR<deliverymanCreateInput, deliverymanUncheckedCreateInput>
  }


  /**
   * deliveryman createMany
   */
  export type deliverymanCreateManyArgs = {
    /**
     * The data used to create many deliverymen.
     */
    data: Enumerable<deliverymanCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * deliveryman update
   */
  export type deliverymanUpdateArgs = {
    /**
     * Select specific fields to fetch from the deliveryman
     */
    select?: deliverymanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: deliverymanInclude | null
    /**
     * The data needed to update a deliveryman.
     */
    data: XOR<deliverymanUpdateInput, deliverymanUncheckedUpdateInput>
    /**
     * Choose, which deliveryman to update.
     */
    where: deliverymanWhereUniqueInput
  }


  /**
   * deliveryman updateMany
   */
  export type deliverymanUpdateManyArgs = {
    /**
     * The data used to update deliverymen.
     */
    data: XOR<deliverymanUpdateManyMutationInput, deliverymanUncheckedUpdateManyInput>
    /**
     * Filter which deliverymen to update
     */
    where?: deliverymanWhereInput
  }


  /**
   * deliveryman upsert
   */
  export type deliverymanUpsertArgs = {
    /**
     * Select specific fields to fetch from the deliveryman
     */
    select?: deliverymanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: deliverymanInclude | null
    /**
     * The filter to search for the deliveryman to update in case it exists.
     */
    where: deliverymanWhereUniqueInput
    /**
     * In case the deliveryman found by the `where` argument doesn't exist, create a new deliveryman with this data.
     */
    create: XOR<deliverymanCreateInput, deliverymanUncheckedCreateInput>
    /**
     * In case the deliveryman was found with the provided `where` argument, update it with this data.
     */
    update: XOR<deliverymanUpdateInput, deliverymanUncheckedUpdateInput>
  }


  /**
   * deliveryman delete
   */
  export type deliverymanDeleteArgs = {
    /**
     * Select specific fields to fetch from the deliveryman
     */
    select?: deliverymanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: deliverymanInclude | null
    /**
     * Filter which deliveryman to delete.
     */
    where: deliverymanWhereUniqueInput
  }


  /**
   * deliveryman deleteMany
   */
  export type deliverymanDeleteManyArgs = {
    /**
     * Filter which deliverymen to delete
     */
    where?: deliverymanWhereInput
  }


  /**
   * deliveryman.order
   */
  export type deliveryman$orderArgs = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude | null
    where?: orderWhereInput
    orderBy?: Enumerable<orderOrderByWithRelationInput>
    cursor?: orderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * deliveryman.veicule_deliveryman
   */
  export type deliveryman$veicule_deliverymanArgs = {
    /**
     * Select specific fields to fetch from the veicule_deliveryman
     */
    select?: veicule_deliverymanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veicule_deliverymanInclude | null
    where?: veicule_deliverymanWhereInput
    orderBy?: Enumerable<veicule_deliverymanOrderByWithRelationInput>
    cursor?: veicule_deliverymanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Veicule_deliverymanScalarFieldEnum>
  }


  /**
   * deliveryman without action
   */
  export type deliverymanArgs = {
    /**
     * Select specific fields to fetch from the deliveryman
     */
    select?: deliverymanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: deliverymanInclude | null
  }



  /**
   * Model veicule_deliveryman
   */


  export type AggregateVeicule_deliveryman = {
    _count: Veicule_deliverymanCountAggregateOutputType | null
    _avg: Veicule_deliverymanAvgAggregateOutputType | null
    _sum: Veicule_deliverymanSumAggregateOutputType | null
    _min: Veicule_deliverymanMinAggregateOutputType | null
    _max: Veicule_deliverymanMaxAggregateOutputType | null
  }

  export type Veicule_deliverymanAvgAggregateOutputType = {
    id: number | null
    veiculeId: number | null
    deliverymanId: number | null
  }

  export type Veicule_deliverymanSumAggregateOutputType = {
    id: number | null
    veiculeId: number | null
    deliverymanId: number | null
  }

  export type Veicule_deliverymanMinAggregateOutputType = {
    id: number | null
    veiculeId: number | null
    deliverymanId: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Veicule_deliverymanMaxAggregateOutputType = {
    id: number | null
    veiculeId: number | null
    deliverymanId: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Veicule_deliverymanCountAggregateOutputType = {
    id: number
    veiculeId: number
    deliverymanId: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Veicule_deliverymanAvgAggregateInputType = {
    id?: true
    veiculeId?: true
    deliverymanId?: true
  }

  export type Veicule_deliverymanSumAggregateInputType = {
    id?: true
    veiculeId?: true
    deliverymanId?: true
  }

  export type Veicule_deliverymanMinAggregateInputType = {
    id?: true
    veiculeId?: true
    deliverymanId?: true
    created_at?: true
    updated_at?: true
  }

  export type Veicule_deliverymanMaxAggregateInputType = {
    id?: true
    veiculeId?: true
    deliverymanId?: true
    created_at?: true
    updated_at?: true
  }

  export type Veicule_deliverymanCountAggregateInputType = {
    id?: true
    veiculeId?: true
    deliverymanId?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Veicule_deliverymanAggregateArgs = {
    /**
     * Filter which veicule_deliveryman to aggregate.
     */
    where?: veicule_deliverymanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of veicule_deliverymen to fetch.
     */
    orderBy?: Enumerable<veicule_deliverymanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: veicule_deliverymanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` veicule_deliverymen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` veicule_deliverymen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned veicule_deliverymen
    **/
    _count?: true | Veicule_deliverymanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Veicule_deliverymanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Veicule_deliverymanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Veicule_deliverymanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Veicule_deliverymanMaxAggregateInputType
  }

  export type GetVeicule_deliverymanAggregateType<T extends Veicule_deliverymanAggregateArgs> = {
        [P in keyof T & keyof AggregateVeicule_deliveryman]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVeicule_deliveryman[P]>
      : GetScalarType<T[P], AggregateVeicule_deliveryman[P]>
  }




  export type Veicule_deliverymanGroupByArgs = {
    where?: veicule_deliverymanWhereInput
    orderBy?: Enumerable<veicule_deliverymanOrderByWithAggregationInput>
    by: Veicule_deliverymanScalarFieldEnum[]
    having?: veicule_deliverymanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Veicule_deliverymanCountAggregateInputType | true
    _avg?: Veicule_deliverymanAvgAggregateInputType
    _sum?: Veicule_deliverymanSumAggregateInputType
    _min?: Veicule_deliverymanMinAggregateInputType
    _max?: Veicule_deliverymanMaxAggregateInputType
  }


  export type Veicule_deliverymanGroupByOutputType = {
    id: number
    veiculeId: number
    deliverymanId: number
    created_at: Date
    updated_at: Date
    _count: Veicule_deliverymanCountAggregateOutputType | null
    _avg: Veicule_deliverymanAvgAggregateOutputType | null
    _sum: Veicule_deliverymanSumAggregateOutputType | null
    _min: Veicule_deliverymanMinAggregateOutputType | null
    _max: Veicule_deliverymanMaxAggregateOutputType | null
  }

  type GetVeicule_deliverymanGroupByPayload<T extends Veicule_deliverymanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Veicule_deliverymanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Veicule_deliverymanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Veicule_deliverymanGroupByOutputType[P]>
            : GetScalarType<T[P], Veicule_deliverymanGroupByOutputType[P]>
        }
      >
    >


  export type veicule_deliverymanSelect = {
    id?: boolean
    veiculeId?: boolean
    deliverymanId?: boolean
    created_at?: boolean
    updated_at?: boolean
    owner?: boolean | deliverymanArgs
    veicule?: boolean | veiculeArgs
  }


  export type veicule_deliverymanInclude = {
    owner?: boolean | deliverymanArgs
    veicule?: boolean | veiculeArgs
  }

  export type veicule_deliverymanGetPayload<S extends boolean | null | undefined | veicule_deliverymanArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? veicule_deliveryman :
    S extends undefined ? never :
    S extends { include: any } & (veicule_deliverymanArgs | veicule_deliverymanFindManyArgs)
    ? veicule_deliveryman  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'owner' ? deliverymanGetPayload<S['include'][P]> :
        P extends 'veicule' ? veiculeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (veicule_deliverymanArgs | veicule_deliverymanFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'owner' ? deliverymanGetPayload<S['select'][P]> :
        P extends 'veicule' ? veiculeGetPayload<S['select'][P]> :  P extends keyof veicule_deliveryman ? veicule_deliveryman[P] : never
  } 
      : veicule_deliveryman


  type veicule_deliverymanCountArgs = 
    Omit<veicule_deliverymanFindManyArgs, 'select' | 'include'> & {
      select?: Veicule_deliverymanCountAggregateInputType | true
    }

  export interface veicule_deliverymanDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Veicule_deliveryman that matches the filter.
     * @param {veicule_deliverymanFindUniqueArgs} args - Arguments to find a Veicule_deliveryman
     * @example
     * // Get one Veicule_deliveryman
     * const veicule_deliveryman = await prisma.veicule_deliveryman.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends veicule_deliverymanFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, veicule_deliverymanFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'veicule_deliveryman'> extends True ? Prisma__veicule_deliverymanClient<veicule_deliverymanGetPayload<T>> : Prisma__veicule_deliverymanClient<veicule_deliverymanGetPayload<T> | null, null>

    /**
     * Find one Veicule_deliveryman that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {veicule_deliverymanFindUniqueOrThrowArgs} args - Arguments to find a Veicule_deliveryman
     * @example
     * // Get one Veicule_deliveryman
     * const veicule_deliveryman = await prisma.veicule_deliveryman.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends veicule_deliverymanFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, veicule_deliverymanFindUniqueOrThrowArgs>
    ): Prisma__veicule_deliverymanClient<veicule_deliverymanGetPayload<T>>

    /**
     * Find the first Veicule_deliveryman that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {veicule_deliverymanFindFirstArgs} args - Arguments to find a Veicule_deliveryman
     * @example
     * // Get one Veicule_deliveryman
     * const veicule_deliveryman = await prisma.veicule_deliveryman.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends veicule_deliverymanFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, veicule_deliverymanFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'veicule_deliveryman'> extends True ? Prisma__veicule_deliverymanClient<veicule_deliverymanGetPayload<T>> : Prisma__veicule_deliverymanClient<veicule_deliverymanGetPayload<T> | null, null>

    /**
     * Find the first Veicule_deliveryman that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {veicule_deliverymanFindFirstOrThrowArgs} args - Arguments to find a Veicule_deliveryman
     * @example
     * // Get one Veicule_deliveryman
     * const veicule_deliveryman = await prisma.veicule_deliveryman.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends veicule_deliverymanFindFirstOrThrowArgs>(
      args?: SelectSubset<T, veicule_deliverymanFindFirstOrThrowArgs>
    ): Prisma__veicule_deliverymanClient<veicule_deliverymanGetPayload<T>>

    /**
     * Find zero or more Veicule_deliverymen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {veicule_deliverymanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Veicule_deliverymen
     * const veicule_deliverymen = await prisma.veicule_deliveryman.findMany()
     * 
     * // Get first 10 Veicule_deliverymen
     * const veicule_deliverymen = await prisma.veicule_deliveryman.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const veicule_deliverymanWithIdOnly = await prisma.veicule_deliveryman.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends veicule_deliverymanFindManyArgs>(
      args?: SelectSubset<T, veicule_deliverymanFindManyArgs>
    ): Prisma.PrismaPromise<Array<veicule_deliverymanGetPayload<T>>>

    /**
     * Create a Veicule_deliveryman.
     * @param {veicule_deliverymanCreateArgs} args - Arguments to create a Veicule_deliveryman.
     * @example
     * // Create one Veicule_deliveryman
     * const Veicule_deliveryman = await prisma.veicule_deliveryman.create({
     *   data: {
     *     // ... data to create a Veicule_deliveryman
     *   }
     * })
     * 
    **/
    create<T extends veicule_deliverymanCreateArgs>(
      args: SelectSubset<T, veicule_deliverymanCreateArgs>
    ): Prisma__veicule_deliverymanClient<veicule_deliverymanGetPayload<T>>

    /**
     * Create many Veicule_deliverymen.
     *     @param {veicule_deliverymanCreateManyArgs} args - Arguments to create many Veicule_deliverymen.
     *     @example
     *     // Create many Veicule_deliverymen
     *     const veicule_deliveryman = await prisma.veicule_deliveryman.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends veicule_deliverymanCreateManyArgs>(
      args?: SelectSubset<T, veicule_deliverymanCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Veicule_deliveryman.
     * @param {veicule_deliverymanDeleteArgs} args - Arguments to delete one Veicule_deliveryman.
     * @example
     * // Delete one Veicule_deliveryman
     * const Veicule_deliveryman = await prisma.veicule_deliveryman.delete({
     *   where: {
     *     // ... filter to delete one Veicule_deliveryman
     *   }
     * })
     * 
    **/
    delete<T extends veicule_deliverymanDeleteArgs>(
      args: SelectSubset<T, veicule_deliverymanDeleteArgs>
    ): Prisma__veicule_deliverymanClient<veicule_deliverymanGetPayload<T>>

    /**
     * Update one Veicule_deliveryman.
     * @param {veicule_deliverymanUpdateArgs} args - Arguments to update one Veicule_deliveryman.
     * @example
     * // Update one Veicule_deliveryman
     * const veicule_deliveryman = await prisma.veicule_deliveryman.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends veicule_deliverymanUpdateArgs>(
      args: SelectSubset<T, veicule_deliverymanUpdateArgs>
    ): Prisma__veicule_deliverymanClient<veicule_deliverymanGetPayload<T>>

    /**
     * Delete zero or more Veicule_deliverymen.
     * @param {veicule_deliverymanDeleteManyArgs} args - Arguments to filter Veicule_deliverymen to delete.
     * @example
     * // Delete a few Veicule_deliverymen
     * const { count } = await prisma.veicule_deliveryman.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends veicule_deliverymanDeleteManyArgs>(
      args?: SelectSubset<T, veicule_deliverymanDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Veicule_deliverymen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {veicule_deliverymanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Veicule_deliverymen
     * const veicule_deliveryman = await prisma.veicule_deliveryman.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends veicule_deliverymanUpdateManyArgs>(
      args: SelectSubset<T, veicule_deliverymanUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Veicule_deliveryman.
     * @param {veicule_deliverymanUpsertArgs} args - Arguments to update or create a Veicule_deliveryman.
     * @example
     * // Update or create a Veicule_deliveryman
     * const veicule_deliveryman = await prisma.veicule_deliveryman.upsert({
     *   create: {
     *     // ... data to create a Veicule_deliveryman
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Veicule_deliveryman we want to update
     *   }
     * })
    **/
    upsert<T extends veicule_deliverymanUpsertArgs>(
      args: SelectSubset<T, veicule_deliverymanUpsertArgs>
    ): Prisma__veicule_deliverymanClient<veicule_deliverymanGetPayload<T>>

    /**
     * Count the number of Veicule_deliverymen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {veicule_deliverymanCountArgs} args - Arguments to filter Veicule_deliverymen to count.
     * @example
     * // Count the number of Veicule_deliverymen
     * const count = await prisma.veicule_deliveryman.count({
     *   where: {
     *     // ... the filter for the Veicule_deliverymen we want to count
     *   }
     * })
    **/
    count<T extends veicule_deliverymanCountArgs>(
      args?: Subset<T, veicule_deliverymanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Veicule_deliverymanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Veicule_deliveryman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Veicule_deliverymanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Veicule_deliverymanAggregateArgs>(args: Subset<T, Veicule_deliverymanAggregateArgs>): Prisma.PrismaPromise<GetVeicule_deliverymanAggregateType<T>>

    /**
     * Group by Veicule_deliveryman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Veicule_deliverymanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Veicule_deliverymanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Veicule_deliverymanGroupByArgs['orderBy'] }
        : { orderBy?: Veicule_deliverymanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Veicule_deliverymanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVeicule_deliverymanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for veicule_deliveryman.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__veicule_deliverymanClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    owner<T extends deliverymanArgs= {}>(args?: Subset<T, deliverymanArgs>): Prisma__deliverymanClient<deliverymanGetPayload<T> | Null>;

    veicule<T extends veiculeArgs= {}>(args?: Subset<T, veiculeArgs>): Prisma__veiculeClient<veiculeGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * veicule_deliveryman base type for findUnique actions
   */
  export type veicule_deliverymanFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the veicule_deliveryman
     */
    select?: veicule_deliverymanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veicule_deliverymanInclude | null
    /**
     * Filter, which veicule_deliveryman to fetch.
     */
    where: veicule_deliverymanWhereUniqueInput
  }

  /**
   * veicule_deliveryman findUnique
   */
  export interface veicule_deliverymanFindUniqueArgs extends veicule_deliverymanFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * veicule_deliveryman findUniqueOrThrow
   */
  export type veicule_deliverymanFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the veicule_deliveryman
     */
    select?: veicule_deliverymanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veicule_deliverymanInclude | null
    /**
     * Filter, which veicule_deliveryman to fetch.
     */
    where: veicule_deliverymanWhereUniqueInput
  }


  /**
   * veicule_deliveryman base type for findFirst actions
   */
  export type veicule_deliverymanFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the veicule_deliveryman
     */
    select?: veicule_deliverymanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veicule_deliverymanInclude | null
    /**
     * Filter, which veicule_deliveryman to fetch.
     */
    where?: veicule_deliverymanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of veicule_deliverymen to fetch.
     */
    orderBy?: Enumerable<veicule_deliverymanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for veicule_deliverymen.
     */
    cursor?: veicule_deliverymanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` veicule_deliverymen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` veicule_deliverymen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of veicule_deliverymen.
     */
    distinct?: Enumerable<Veicule_deliverymanScalarFieldEnum>
  }

  /**
   * veicule_deliveryman findFirst
   */
  export interface veicule_deliverymanFindFirstArgs extends veicule_deliverymanFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * veicule_deliveryman findFirstOrThrow
   */
  export type veicule_deliverymanFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the veicule_deliveryman
     */
    select?: veicule_deliverymanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veicule_deliverymanInclude | null
    /**
     * Filter, which veicule_deliveryman to fetch.
     */
    where?: veicule_deliverymanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of veicule_deliverymen to fetch.
     */
    orderBy?: Enumerable<veicule_deliverymanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for veicule_deliverymen.
     */
    cursor?: veicule_deliverymanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` veicule_deliverymen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` veicule_deliverymen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of veicule_deliverymen.
     */
    distinct?: Enumerable<Veicule_deliverymanScalarFieldEnum>
  }


  /**
   * veicule_deliveryman findMany
   */
  export type veicule_deliverymanFindManyArgs = {
    /**
     * Select specific fields to fetch from the veicule_deliveryman
     */
    select?: veicule_deliverymanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veicule_deliverymanInclude | null
    /**
     * Filter, which veicule_deliverymen to fetch.
     */
    where?: veicule_deliverymanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of veicule_deliverymen to fetch.
     */
    orderBy?: Enumerable<veicule_deliverymanOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing veicule_deliverymen.
     */
    cursor?: veicule_deliverymanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` veicule_deliverymen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` veicule_deliverymen.
     */
    skip?: number
    distinct?: Enumerable<Veicule_deliverymanScalarFieldEnum>
  }


  /**
   * veicule_deliveryman create
   */
  export type veicule_deliverymanCreateArgs = {
    /**
     * Select specific fields to fetch from the veicule_deliveryman
     */
    select?: veicule_deliverymanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veicule_deliverymanInclude | null
    /**
     * The data needed to create a veicule_deliveryman.
     */
    data: XOR<veicule_deliverymanCreateInput, veicule_deliverymanUncheckedCreateInput>
  }


  /**
   * veicule_deliveryman createMany
   */
  export type veicule_deliverymanCreateManyArgs = {
    /**
     * The data used to create many veicule_deliverymen.
     */
    data: Enumerable<veicule_deliverymanCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * veicule_deliveryman update
   */
  export type veicule_deliverymanUpdateArgs = {
    /**
     * Select specific fields to fetch from the veicule_deliveryman
     */
    select?: veicule_deliverymanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veicule_deliverymanInclude | null
    /**
     * The data needed to update a veicule_deliveryman.
     */
    data: XOR<veicule_deliverymanUpdateInput, veicule_deliverymanUncheckedUpdateInput>
    /**
     * Choose, which veicule_deliveryman to update.
     */
    where: veicule_deliverymanWhereUniqueInput
  }


  /**
   * veicule_deliveryman updateMany
   */
  export type veicule_deliverymanUpdateManyArgs = {
    /**
     * The data used to update veicule_deliverymen.
     */
    data: XOR<veicule_deliverymanUpdateManyMutationInput, veicule_deliverymanUncheckedUpdateManyInput>
    /**
     * Filter which veicule_deliverymen to update
     */
    where?: veicule_deliverymanWhereInput
  }


  /**
   * veicule_deliveryman upsert
   */
  export type veicule_deliverymanUpsertArgs = {
    /**
     * Select specific fields to fetch from the veicule_deliveryman
     */
    select?: veicule_deliverymanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veicule_deliverymanInclude | null
    /**
     * The filter to search for the veicule_deliveryman to update in case it exists.
     */
    where: veicule_deliverymanWhereUniqueInput
    /**
     * In case the veicule_deliveryman found by the `where` argument doesn't exist, create a new veicule_deliveryman with this data.
     */
    create: XOR<veicule_deliverymanCreateInput, veicule_deliverymanUncheckedCreateInput>
    /**
     * In case the veicule_deliveryman was found with the provided `where` argument, update it with this data.
     */
    update: XOR<veicule_deliverymanUpdateInput, veicule_deliverymanUncheckedUpdateInput>
  }


  /**
   * veicule_deliveryman delete
   */
  export type veicule_deliverymanDeleteArgs = {
    /**
     * Select specific fields to fetch from the veicule_deliveryman
     */
    select?: veicule_deliverymanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veicule_deliverymanInclude | null
    /**
     * Filter which veicule_deliveryman to delete.
     */
    where: veicule_deliverymanWhereUniqueInput
  }


  /**
   * veicule_deliveryman deleteMany
   */
  export type veicule_deliverymanDeleteManyArgs = {
    /**
     * Filter which veicule_deliverymen to delete
     */
    where?: veicule_deliverymanWhereInput
  }


  /**
   * veicule_deliveryman without action
   */
  export type veicule_deliverymanArgs = {
    /**
     * Select specific fields to fetch from the veicule_deliveryman
     */
    select?: veicule_deliverymanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veicule_deliverymanInclude | null
  }



  /**
   * Model payment
   */


  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    payment_methodId: number | null
    orderId: number | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    payment_methodId: number | null
    orderId: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    status: boolean | null
    details: string | null
    payment_methodId: number | null
    orderId: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    status: boolean | null
    details: string | null
    payment_methodId: number | null
    orderId: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    status: number
    details: number
    payment_methodId: number
    orderId: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    payment_methodId?: true
    orderId?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    payment_methodId?: true
    orderId?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    status?: true
    details?: true
    payment_methodId?: true
    orderId?: true
    created_at?: true
    updated_at?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    status?: true
    details?: true
    payment_methodId?: true
    orderId?: true
    created_at?: true
    updated_at?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    status?: true
    details?: true
    payment_methodId?: true
    orderId?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PaymentAggregateArgs = {
    /**
     * Filter which payment to aggregate.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: Enumerable<paymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs = {
    where?: paymentWhereInput
    orderBy?: Enumerable<paymentOrderByWithAggregationInput>
    by: PaymentScalarFieldEnum[]
    having?: paymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }


  export type PaymentGroupByOutputType = {
    id: number
    status: boolean
    details: string
    payment_methodId: number
    orderId: number
    created_at: Date
    updated_at: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type paymentSelect = {
    id?: boolean
    status?: boolean
    details?: boolean
    payment_methodId?: boolean
    orderId?: boolean
    created_at?: boolean
    updated_at?: boolean
    order?: boolean | orderArgs
    payment_method?: boolean | payment_methodArgs
  }


  export type paymentInclude = {
    order?: boolean | orderArgs
    payment_method?: boolean | payment_methodArgs
  }

  export type paymentGetPayload<S extends boolean | null | undefined | paymentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? payment :
    S extends undefined ? never :
    S extends { include: any } & (paymentArgs | paymentFindManyArgs)
    ? payment  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'order' ? orderGetPayload<S['include'][P]> :
        P extends 'payment_method' ? payment_methodGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (paymentArgs | paymentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'order' ? orderGetPayload<S['select'][P]> :
        P extends 'payment_method' ? payment_methodGetPayload<S['select'][P]> :  P extends keyof payment ? payment[P] : never
  } 
      : payment


  type paymentCountArgs = 
    Omit<paymentFindManyArgs, 'select' | 'include'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface paymentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Payment that matches the filter.
     * @param {paymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends paymentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, paymentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'payment'> extends True ? Prisma__paymentClient<paymentGetPayload<T>> : Prisma__paymentClient<paymentGetPayload<T> | null, null>

    /**
     * Find one Payment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {paymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends paymentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, paymentFindUniqueOrThrowArgs>
    ): Prisma__paymentClient<paymentGetPayload<T>>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends paymentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, paymentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'payment'> extends True ? Prisma__paymentClient<paymentGetPayload<T>> : Prisma__paymentClient<paymentGetPayload<T> | null, null>

    /**
     * Find the first Payment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends paymentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, paymentFindFirstOrThrowArgs>
    ): Prisma__paymentClient<paymentGetPayload<T>>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends paymentFindManyArgs>(
      args?: SelectSubset<T, paymentFindManyArgs>
    ): Prisma.PrismaPromise<Array<paymentGetPayload<T>>>

    /**
     * Create a Payment.
     * @param {paymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
    **/
    create<T extends paymentCreateArgs>(
      args: SelectSubset<T, paymentCreateArgs>
    ): Prisma__paymentClient<paymentGetPayload<T>>

    /**
     * Create many Payments.
     *     @param {paymentCreateManyArgs} args - Arguments to create many Payments.
     *     @example
     *     // Create many Payments
     *     const payment = await prisma.payment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends paymentCreateManyArgs>(
      args?: SelectSubset<T, paymentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {paymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
    **/
    delete<T extends paymentDeleteArgs>(
      args: SelectSubset<T, paymentDeleteArgs>
    ): Prisma__paymentClient<paymentGetPayload<T>>

    /**
     * Update one Payment.
     * @param {paymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends paymentUpdateArgs>(
      args: SelectSubset<T, paymentUpdateArgs>
    ): Prisma__paymentClient<paymentGetPayload<T>>

    /**
     * Delete zero or more Payments.
     * @param {paymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends paymentDeleteManyArgs>(
      args?: SelectSubset<T, paymentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends paymentUpdateManyArgs>(
      args: SelectSubset<T, paymentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {paymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
    **/
    upsert<T extends paymentUpsertArgs>(
      args: SelectSubset<T, paymentUpsertArgs>
    ): Prisma__paymentClient<paymentGetPayload<T>>

    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentCountArgs>(
      args?: Subset<T, paymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__paymentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    order<T extends orderArgs= {}>(args?: Subset<T, orderArgs>): Prisma__orderClient<orderGetPayload<T> | Null>;

    payment_method<T extends payment_methodArgs= {}>(args?: Subset<T, payment_methodArgs>): Prisma__payment_methodClient<payment_methodGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * payment base type for findUnique actions
   */
  export type paymentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: paymentInclude | null
    /**
     * Filter, which payment to fetch.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment findUnique
   */
  export interface paymentFindUniqueArgs extends paymentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * payment findUniqueOrThrow
   */
  export type paymentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: paymentInclude | null
    /**
     * Filter, which payment to fetch.
     */
    where: paymentWhereUniqueInput
  }


  /**
   * payment base type for findFirst actions
   */
  export type paymentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: paymentInclude | null
    /**
     * Filter, which payment to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: Enumerable<paymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }

  /**
   * payment findFirst
   */
  export interface paymentFindFirstArgs extends paymentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * payment findFirstOrThrow
   */
  export type paymentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: paymentInclude | null
    /**
     * Filter, which payment to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: Enumerable<paymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * payment findMany
   */
  export type paymentFindManyArgs = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: paymentInclude | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: Enumerable<paymentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * payment create
   */
  export type paymentCreateArgs = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: paymentInclude | null
    /**
     * The data needed to create a payment.
     */
    data: XOR<paymentCreateInput, paymentUncheckedCreateInput>
  }


  /**
   * payment createMany
   */
  export type paymentCreateManyArgs = {
    /**
     * The data used to create many payments.
     */
    data: Enumerable<paymentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * payment update
   */
  export type paymentUpdateArgs = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: paymentInclude | null
    /**
     * The data needed to update a payment.
     */
    data: XOR<paymentUpdateInput, paymentUncheckedUpdateInput>
    /**
     * Choose, which payment to update.
     */
    where: paymentWhereUniqueInput
  }


  /**
   * payment updateMany
   */
  export type paymentUpdateManyArgs = {
    /**
     * The data used to update payments.
     */
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentWhereInput
  }


  /**
   * payment upsert
   */
  export type paymentUpsertArgs = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: paymentInclude | null
    /**
     * The filter to search for the payment to update in case it exists.
     */
    where: paymentWhereUniqueInput
    /**
     * In case the payment found by the `where` argument doesn't exist, create a new payment with this data.
     */
    create: XOR<paymentCreateInput, paymentUncheckedCreateInput>
    /**
     * In case the payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentUpdateInput, paymentUncheckedUpdateInput>
  }


  /**
   * payment delete
   */
  export type paymentDeleteArgs = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: paymentInclude | null
    /**
     * Filter which payment to delete.
     */
    where: paymentWhereUniqueInput
  }


  /**
   * payment deleteMany
   */
  export type paymentDeleteManyArgs = {
    /**
     * Filter which payments to delete
     */
    where?: paymentWhereInput
  }


  /**
   * payment without action
   */
  export type paymentArgs = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: paymentInclude | null
  }



  /**
   * Model order
   */


  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    id: number | null
    deliverymanId: number | null
    shopping_listId: number | null
    costumer_addressesId: number | null
  }

  export type OrderSumAggregateOutputType = {
    id: number | null
    deliverymanId: number | null
    shopping_listId: number | null
    costumer_addressesId: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: number | null
    accepted_status: boolean | null
    delivered_status_for_client: boolean | null
    retreat_products_status: boolean | null
    deliverymanId: number | null
    shopping_listId: number | null
    created_at: Date | null
    updated_at: Date | null
    costumer_addressesId: number | null
    intent_payment_id: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: number | null
    accepted_status: boolean | null
    delivered_status_for_client: boolean | null
    retreat_products_status: boolean | null
    deliverymanId: number | null
    shopping_listId: number | null
    created_at: Date | null
    updated_at: Date | null
    costumer_addressesId: number | null
    intent_payment_id: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    accepted_status: number
    delivered_status_for_client: number
    retreat_products_status: number
    deliverymanId: number
    shopping_listId: number
    created_at: number
    updated_at: number
    costumer_addressesId: number
    intent_payment_id: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    id?: true
    deliverymanId?: true
    shopping_listId?: true
    costumer_addressesId?: true
  }

  export type OrderSumAggregateInputType = {
    id?: true
    deliverymanId?: true
    shopping_listId?: true
    costumer_addressesId?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    accepted_status?: true
    delivered_status_for_client?: true
    retreat_products_status?: true
    deliverymanId?: true
    shopping_listId?: true
    created_at?: true
    updated_at?: true
    costumer_addressesId?: true
    intent_payment_id?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    accepted_status?: true
    delivered_status_for_client?: true
    retreat_products_status?: true
    deliverymanId?: true
    shopping_listId?: true
    created_at?: true
    updated_at?: true
    costumer_addressesId?: true
    intent_payment_id?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    accepted_status?: true
    delivered_status_for_client?: true
    retreat_products_status?: true
    deliverymanId?: true
    shopping_listId?: true
    created_at?: true
    updated_at?: true
    costumer_addressesId?: true
    intent_payment_id?: true
    _all?: true
  }

  export type OrderAggregateArgs = {
    /**
     * Filter which order to aggregate.
     */
    where?: orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: Enumerable<orderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs = {
    where?: orderWhereInput
    orderBy?: Enumerable<orderOrderByWithAggregationInput>
    by: OrderScalarFieldEnum[]
    having?: orderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }


  export type OrderGroupByOutputType = {
    id: number
    accepted_status: boolean
    delivered_status_for_client: boolean
    retreat_products_status: boolean
    deliverymanId: number | null
    shopping_listId: number
    created_at: Date
    updated_at: Date
    costumer_addressesId: number
    intent_payment_id: string
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type orderSelect = {
    id?: boolean
    accepted_status?: boolean
    delivered_status_for_client?: boolean
    retreat_products_status?: boolean
    deliverymanId?: boolean
    shopping_listId?: boolean
    created_at?: boolean
    updated_at?: boolean
    costumer_addressesId?: boolean
    intent_payment_id?: boolean
    costumer_addresses?: boolean | costumer_addressesArgs
    deliveryman?: boolean | deliverymanArgs
    shopping_list?: boolean | shopping_listArgs
    payment?: boolean | paymentArgs
  }


  export type orderInclude = {
    costumer_addresses?: boolean | costumer_addressesArgs
    deliveryman?: boolean | deliverymanArgs
    shopping_list?: boolean | shopping_listArgs
    payment?: boolean | paymentArgs
  }

  export type orderGetPayload<S extends boolean | null | undefined | orderArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? order :
    S extends undefined ? never :
    S extends { include: any } & (orderArgs | orderFindManyArgs)
    ? order  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'costumer_addresses' ? costumer_addressesGetPayload<S['include'][P]> :
        P extends 'deliveryman' ? deliverymanGetPayload<S['include'][P]> | null :
        P extends 'shopping_list' ? shopping_listGetPayload<S['include'][P]> :
        P extends 'payment' ? paymentGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (orderArgs | orderFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'costumer_addresses' ? costumer_addressesGetPayload<S['select'][P]> :
        P extends 'deliveryman' ? deliverymanGetPayload<S['select'][P]> | null :
        P extends 'shopping_list' ? shopping_listGetPayload<S['select'][P]> :
        P extends 'payment' ? paymentGetPayload<S['select'][P]> | null :  P extends keyof order ? order[P] : never
  } 
      : order


  type orderCountArgs = 
    Omit<orderFindManyArgs, 'select' | 'include'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface orderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Order that matches the filter.
     * @param {orderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends orderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, orderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'order'> extends True ? Prisma__orderClient<orderGetPayload<T>> : Prisma__orderClient<orderGetPayload<T> | null, null>

    /**
     * Find one Order that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {orderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends orderFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, orderFindUniqueOrThrowArgs>
    ): Prisma__orderClient<orderGetPayload<T>>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends orderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, orderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'order'> extends True ? Prisma__orderClient<orderGetPayload<T>> : Prisma__orderClient<orderGetPayload<T> | null, null>

    /**
     * Find the first Order that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends orderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, orderFindFirstOrThrowArgs>
    ): Prisma__orderClient<orderGetPayload<T>>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends orderFindManyArgs>(
      args?: SelectSubset<T, orderFindManyArgs>
    ): Prisma.PrismaPromise<Array<orderGetPayload<T>>>

    /**
     * Create a Order.
     * @param {orderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
    **/
    create<T extends orderCreateArgs>(
      args: SelectSubset<T, orderCreateArgs>
    ): Prisma__orderClient<orderGetPayload<T>>

    /**
     * Create many Orders.
     *     @param {orderCreateManyArgs} args - Arguments to create many Orders.
     *     @example
     *     // Create many Orders
     *     const order = await prisma.order.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends orderCreateManyArgs>(
      args?: SelectSubset<T, orderCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {orderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
    **/
    delete<T extends orderDeleteArgs>(
      args: SelectSubset<T, orderDeleteArgs>
    ): Prisma__orderClient<orderGetPayload<T>>

    /**
     * Update one Order.
     * @param {orderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends orderUpdateArgs>(
      args: SelectSubset<T, orderUpdateArgs>
    ): Prisma__orderClient<orderGetPayload<T>>

    /**
     * Delete zero or more Orders.
     * @param {orderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends orderDeleteManyArgs>(
      args?: SelectSubset<T, orderDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends orderUpdateManyArgs>(
      args: SelectSubset<T, orderUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {orderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
    **/
    upsert<T extends orderUpsertArgs>(
      args: SelectSubset<T, orderUpsertArgs>
    ): Prisma__orderClient<orderGetPayload<T>>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends orderCountArgs>(
      args?: Subset<T, orderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__orderClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    costumer_addresses<T extends costumer_addressesArgs= {}>(args?: Subset<T, costumer_addressesArgs>): Prisma__costumer_addressesClient<costumer_addressesGetPayload<T> | Null>;

    deliveryman<T extends deliverymanArgs= {}>(args?: Subset<T, deliverymanArgs>): Prisma__deliverymanClient<deliverymanGetPayload<T> | Null>;

    shopping_list<T extends shopping_listArgs= {}>(args?: Subset<T, shopping_listArgs>): Prisma__shopping_listClient<shopping_listGetPayload<T> | Null>;

    payment<T extends paymentArgs= {}>(args?: Subset<T, paymentArgs>): Prisma__paymentClient<paymentGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * order base type for findUnique actions
   */
  export type orderFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude | null
    /**
     * Filter, which order to fetch.
     */
    where: orderWhereUniqueInput
  }

  /**
   * order findUnique
   */
  export interface orderFindUniqueArgs extends orderFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * order findUniqueOrThrow
   */
  export type orderFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude | null
    /**
     * Filter, which order to fetch.
     */
    where: orderWhereUniqueInput
  }


  /**
   * order base type for findFirst actions
   */
  export type orderFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude | null
    /**
     * Filter, which order to fetch.
     */
    where?: orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: Enumerable<orderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orders.
     */
    cursor?: orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orders.
     */
    distinct?: Enumerable<OrderScalarFieldEnum>
  }

  /**
   * order findFirst
   */
  export interface orderFindFirstArgs extends orderFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * order findFirstOrThrow
   */
  export type orderFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude | null
    /**
     * Filter, which order to fetch.
     */
    where?: orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: Enumerable<orderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orders.
     */
    cursor?: orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orders.
     */
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * order findMany
   */
  export type orderFindManyArgs = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude | null
    /**
     * Filter, which orders to fetch.
     */
    where?: orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: Enumerable<orderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing orders.
     */
    cursor?: orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * order create
   */
  export type orderCreateArgs = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude | null
    /**
     * The data needed to create a order.
     */
    data: XOR<orderCreateInput, orderUncheckedCreateInput>
  }


  /**
   * order createMany
   */
  export type orderCreateManyArgs = {
    /**
     * The data used to create many orders.
     */
    data: Enumerable<orderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * order update
   */
  export type orderUpdateArgs = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude | null
    /**
     * The data needed to update a order.
     */
    data: XOR<orderUpdateInput, orderUncheckedUpdateInput>
    /**
     * Choose, which order to update.
     */
    where: orderWhereUniqueInput
  }


  /**
   * order updateMany
   */
  export type orderUpdateManyArgs = {
    /**
     * The data used to update orders.
     */
    data: XOR<orderUpdateManyMutationInput, orderUncheckedUpdateManyInput>
    /**
     * Filter which orders to update
     */
    where?: orderWhereInput
  }


  /**
   * order upsert
   */
  export type orderUpsertArgs = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude | null
    /**
     * The filter to search for the order to update in case it exists.
     */
    where: orderWhereUniqueInput
    /**
     * In case the order found by the `where` argument doesn't exist, create a new order with this data.
     */
    create: XOR<orderCreateInput, orderUncheckedCreateInput>
    /**
     * In case the order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<orderUpdateInput, orderUncheckedUpdateInput>
  }


  /**
   * order delete
   */
  export type orderDeleteArgs = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude | null
    /**
     * Filter which order to delete.
     */
    where: orderWhereUniqueInput
  }


  /**
   * order deleteMany
   */
  export type orderDeleteManyArgs = {
    /**
     * Filter which orders to delete
     */
    where?: orderWhereInput
  }


  /**
   * order without action
   */
  export type orderArgs = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude | null
  }



  /**
   * Model shopping_list
   */


  export type AggregateShopping_list = {
    _count: Shopping_listCountAggregateOutputType | null
    _avg: Shopping_listAvgAggregateOutputType | null
    _sum: Shopping_listSumAggregateOutputType | null
    _min: Shopping_listMinAggregateOutputType | null
    _max: Shopping_listMaxAggregateOutputType | null
  }

  export type Shopping_listAvgAggregateOutputType = {
    id: number | null
    freight: number | null
    total: number | null
    costumerId: number | null
  }

  export type Shopping_listSumAggregateOutputType = {
    id: number | null
    freight: number | null
    total: number | null
    costumerId: number | null
  }

  export type Shopping_listMinAggregateOutputType = {
    id: number | null
    freight: number | null
    total: number | null
    costumerId: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Shopping_listMaxAggregateOutputType = {
    id: number | null
    freight: number | null
    total: number | null
    costumerId: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Shopping_listCountAggregateOutputType = {
    id: number
    freight: number
    total: number
    costumerId: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Shopping_listAvgAggregateInputType = {
    id?: true
    freight?: true
    total?: true
    costumerId?: true
  }

  export type Shopping_listSumAggregateInputType = {
    id?: true
    freight?: true
    total?: true
    costumerId?: true
  }

  export type Shopping_listMinAggregateInputType = {
    id?: true
    freight?: true
    total?: true
    costumerId?: true
    created_at?: true
    updated_at?: true
  }

  export type Shopping_listMaxAggregateInputType = {
    id?: true
    freight?: true
    total?: true
    costumerId?: true
    created_at?: true
    updated_at?: true
  }

  export type Shopping_listCountAggregateInputType = {
    id?: true
    freight?: true
    total?: true
    costumerId?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Shopping_listAggregateArgs = {
    /**
     * Filter which shopping_list to aggregate.
     */
    where?: shopping_listWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shopping_lists to fetch.
     */
    orderBy?: Enumerable<shopping_listOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: shopping_listWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shopping_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shopping_lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned shopping_lists
    **/
    _count?: true | Shopping_listCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Shopping_listAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Shopping_listSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Shopping_listMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Shopping_listMaxAggregateInputType
  }

  export type GetShopping_listAggregateType<T extends Shopping_listAggregateArgs> = {
        [P in keyof T & keyof AggregateShopping_list]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShopping_list[P]>
      : GetScalarType<T[P], AggregateShopping_list[P]>
  }




  export type Shopping_listGroupByArgs = {
    where?: shopping_listWhereInput
    orderBy?: Enumerable<shopping_listOrderByWithAggregationInput>
    by: Shopping_listScalarFieldEnum[]
    having?: shopping_listScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Shopping_listCountAggregateInputType | true
    _avg?: Shopping_listAvgAggregateInputType
    _sum?: Shopping_listSumAggregateInputType
    _min?: Shopping_listMinAggregateInputType
    _max?: Shopping_listMaxAggregateInputType
  }


  export type Shopping_listGroupByOutputType = {
    id: number
    freight: number | null
    total: number
    costumerId: number
    created_at: Date
    updated_at: Date
    _count: Shopping_listCountAggregateOutputType | null
    _avg: Shopping_listAvgAggregateOutputType | null
    _sum: Shopping_listSumAggregateOutputType | null
    _min: Shopping_listMinAggregateOutputType | null
    _max: Shopping_listMaxAggregateOutputType | null
  }

  type GetShopping_listGroupByPayload<T extends Shopping_listGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Shopping_listGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Shopping_listGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Shopping_listGroupByOutputType[P]>
            : GetScalarType<T[P], Shopping_listGroupByOutputType[P]>
        }
      >
    >


  export type shopping_listSelect = {
    id?: boolean
    freight?: boolean
    total?: boolean
    costumerId?: boolean
    created_at?: boolean
    updated_at?: boolean
    order?: boolean | orderArgs
    products_in_shopping_list?: boolean | shopping_list$products_in_shopping_listArgs
    costumer?: boolean | costumerArgs
    _count?: boolean | Shopping_listCountOutputTypeArgs
  }


  export type shopping_listInclude = {
    order?: boolean | orderArgs
    products_in_shopping_list?: boolean | shopping_list$products_in_shopping_listArgs
    costumer?: boolean | costumerArgs
    _count?: boolean | Shopping_listCountOutputTypeArgs
  }

  export type shopping_listGetPayload<S extends boolean | null | undefined | shopping_listArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? shopping_list :
    S extends undefined ? never :
    S extends { include: any } & (shopping_listArgs | shopping_listFindManyArgs)
    ? shopping_list  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'order' ? orderGetPayload<S['include'][P]> | null :
        P extends 'products_in_shopping_list' ? Array < products_in_shopping_listGetPayload<S['include'][P]>>  :
        P extends 'costumer' ? costumerGetPayload<S['include'][P]> :
        P extends '_count' ? Shopping_listCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (shopping_listArgs | shopping_listFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'order' ? orderGetPayload<S['select'][P]> | null :
        P extends 'products_in_shopping_list' ? Array < products_in_shopping_listGetPayload<S['select'][P]>>  :
        P extends 'costumer' ? costumerGetPayload<S['select'][P]> :
        P extends '_count' ? Shopping_listCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof shopping_list ? shopping_list[P] : never
  } 
      : shopping_list


  type shopping_listCountArgs = 
    Omit<shopping_listFindManyArgs, 'select' | 'include'> & {
      select?: Shopping_listCountAggregateInputType | true
    }

  export interface shopping_listDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Shopping_list that matches the filter.
     * @param {shopping_listFindUniqueArgs} args - Arguments to find a Shopping_list
     * @example
     * // Get one Shopping_list
     * const shopping_list = await prisma.shopping_list.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends shopping_listFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, shopping_listFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'shopping_list'> extends True ? Prisma__shopping_listClient<shopping_listGetPayload<T>> : Prisma__shopping_listClient<shopping_listGetPayload<T> | null, null>

    /**
     * Find one Shopping_list that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {shopping_listFindUniqueOrThrowArgs} args - Arguments to find a Shopping_list
     * @example
     * // Get one Shopping_list
     * const shopping_list = await prisma.shopping_list.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends shopping_listFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, shopping_listFindUniqueOrThrowArgs>
    ): Prisma__shopping_listClient<shopping_listGetPayload<T>>

    /**
     * Find the first Shopping_list that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shopping_listFindFirstArgs} args - Arguments to find a Shopping_list
     * @example
     * // Get one Shopping_list
     * const shopping_list = await prisma.shopping_list.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends shopping_listFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, shopping_listFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'shopping_list'> extends True ? Prisma__shopping_listClient<shopping_listGetPayload<T>> : Prisma__shopping_listClient<shopping_listGetPayload<T> | null, null>

    /**
     * Find the first Shopping_list that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shopping_listFindFirstOrThrowArgs} args - Arguments to find a Shopping_list
     * @example
     * // Get one Shopping_list
     * const shopping_list = await prisma.shopping_list.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends shopping_listFindFirstOrThrowArgs>(
      args?: SelectSubset<T, shopping_listFindFirstOrThrowArgs>
    ): Prisma__shopping_listClient<shopping_listGetPayload<T>>

    /**
     * Find zero or more Shopping_lists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shopping_listFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shopping_lists
     * const shopping_lists = await prisma.shopping_list.findMany()
     * 
     * // Get first 10 Shopping_lists
     * const shopping_lists = await prisma.shopping_list.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shopping_listWithIdOnly = await prisma.shopping_list.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends shopping_listFindManyArgs>(
      args?: SelectSubset<T, shopping_listFindManyArgs>
    ): Prisma.PrismaPromise<Array<shopping_listGetPayload<T>>>

    /**
     * Create a Shopping_list.
     * @param {shopping_listCreateArgs} args - Arguments to create a Shopping_list.
     * @example
     * // Create one Shopping_list
     * const Shopping_list = await prisma.shopping_list.create({
     *   data: {
     *     // ... data to create a Shopping_list
     *   }
     * })
     * 
    **/
    create<T extends shopping_listCreateArgs>(
      args: SelectSubset<T, shopping_listCreateArgs>
    ): Prisma__shopping_listClient<shopping_listGetPayload<T>>

    /**
     * Create many Shopping_lists.
     *     @param {shopping_listCreateManyArgs} args - Arguments to create many Shopping_lists.
     *     @example
     *     // Create many Shopping_lists
     *     const shopping_list = await prisma.shopping_list.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends shopping_listCreateManyArgs>(
      args?: SelectSubset<T, shopping_listCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Shopping_list.
     * @param {shopping_listDeleteArgs} args - Arguments to delete one Shopping_list.
     * @example
     * // Delete one Shopping_list
     * const Shopping_list = await prisma.shopping_list.delete({
     *   where: {
     *     // ... filter to delete one Shopping_list
     *   }
     * })
     * 
    **/
    delete<T extends shopping_listDeleteArgs>(
      args: SelectSubset<T, shopping_listDeleteArgs>
    ): Prisma__shopping_listClient<shopping_listGetPayload<T>>

    /**
     * Update one Shopping_list.
     * @param {shopping_listUpdateArgs} args - Arguments to update one Shopping_list.
     * @example
     * // Update one Shopping_list
     * const shopping_list = await prisma.shopping_list.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends shopping_listUpdateArgs>(
      args: SelectSubset<T, shopping_listUpdateArgs>
    ): Prisma__shopping_listClient<shopping_listGetPayload<T>>

    /**
     * Delete zero or more Shopping_lists.
     * @param {shopping_listDeleteManyArgs} args - Arguments to filter Shopping_lists to delete.
     * @example
     * // Delete a few Shopping_lists
     * const { count } = await prisma.shopping_list.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends shopping_listDeleteManyArgs>(
      args?: SelectSubset<T, shopping_listDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shopping_lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shopping_listUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shopping_lists
     * const shopping_list = await prisma.shopping_list.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends shopping_listUpdateManyArgs>(
      args: SelectSubset<T, shopping_listUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shopping_list.
     * @param {shopping_listUpsertArgs} args - Arguments to update or create a Shopping_list.
     * @example
     * // Update or create a Shopping_list
     * const shopping_list = await prisma.shopping_list.upsert({
     *   create: {
     *     // ... data to create a Shopping_list
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shopping_list we want to update
     *   }
     * })
    **/
    upsert<T extends shopping_listUpsertArgs>(
      args: SelectSubset<T, shopping_listUpsertArgs>
    ): Prisma__shopping_listClient<shopping_listGetPayload<T>>

    /**
     * Count the number of Shopping_lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shopping_listCountArgs} args - Arguments to filter Shopping_lists to count.
     * @example
     * // Count the number of Shopping_lists
     * const count = await prisma.shopping_list.count({
     *   where: {
     *     // ... the filter for the Shopping_lists we want to count
     *   }
     * })
    **/
    count<T extends shopping_listCountArgs>(
      args?: Subset<T, shopping_listCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Shopping_listCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shopping_list.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Shopping_listAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Shopping_listAggregateArgs>(args: Subset<T, Shopping_listAggregateArgs>): Prisma.PrismaPromise<GetShopping_listAggregateType<T>>

    /**
     * Group by Shopping_list.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Shopping_listGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Shopping_listGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Shopping_listGroupByArgs['orderBy'] }
        : { orderBy?: Shopping_listGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Shopping_listGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopping_listGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for shopping_list.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__shopping_listClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    order<T extends orderArgs= {}>(args?: Subset<T, orderArgs>): Prisma__orderClient<orderGetPayload<T> | Null>;

    products_in_shopping_list<T extends shopping_list$products_in_shopping_listArgs= {}>(args?: Subset<T, shopping_list$products_in_shopping_listArgs>): Prisma.PrismaPromise<Array<products_in_shopping_listGetPayload<T>>| Null>;

    costumer<T extends costumerArgs= {}>(args?: Subset<T, costumerArgs>): Prisma__costumerClient<costumerGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * shopping_list base type for findUnique actions
   */
  export type shopping_listFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the shopping_list
     */
    select?: shopping_listSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shopping_listInclude | null
    /**
     * Filter, which shopping_list to fetch.
     */
    where: shopping_listWhereUniqueInput
  }

  /**
   * shopping_list findUnique
   */
  export interface shopping_listFindUniqueArgs extends shopping_listFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * shopping_list findUniqueOrThrow
   */
  export type shopping_listFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the shopping_list
     */
    select?: shopping_listSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shopping_listInclude | null
    /**
     * Filter, which shopping_list to fetch.
     */
    where: shopping_listWhereUniqueInput
  }


  /**
   * shopping_list base type for findFirst actions
   */
  export type shopping_listFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the shopping_list
     */
    select?: shopping_listSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shopping_listInclude | null
    /**
     * Filter, which shopping_list to fetch.
     */
    where?: shopping_listWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shopping_lists to fetch.
     */
    orderBy?: Enumerable<shopping_listOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for shopping_lists.
     */
    cursor?: shopping_listWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shopping_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shopping_lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of shopping_lists.
     */
    distinct?: Enumerable<Shopping_listScalarFieldEnum>
  }

  /**
   * shopping_list findFirst
   */
  export interface shopping_listFindFirstArgs extends shopping_listFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * shopping_list findFirstOrThrow
   */
  export type shopping_listFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the shopping_list
     */
    select?: shopping_listSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shopping_listInclude | null
    /**
     * Filter, which shopping_list to fetch.
     */
    where?: shopping_listWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shopping_lists to fetch.
     */
    orderBy?: Enumerable<shopping_listOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for shopping_lists.
     */
    cursor?: shopping_listWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shopping_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shopping_lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of shopping_lists.
     */
    distinct?: Enumerable<Shopping_listScalarFieldEnum>
  }


  /**
   * shopping_list findMany
   */
  export type shopping_listFindManyArgs = {
    /**
     * Select specific fields to fetch from the shopping_list
     */
    select?: shopping_listSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shopping_listInclude | null
    /**
     * Filter, which shopping_lists to fetch.
     */
    where?: shopping_listWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shopping_lists to fetch.
     */
    orderBy?: Enumerable<shopping_listOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing shopping_lists.
     */
    cursor?: shopping_listWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shopping_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shopping_lists.
     */
    skip?: number
    distinct?: Enumerable<Shopping_listScalarFieldEnum>
  }


  /**
   * shopping_list create
   */
  export type shopping_listCreateArgs = {
    /**
     * Select specific fields to fetch from the shopping_list
     */
    select?: shopping_listSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shopping_listInclude | null
    /**
     * The data needed to create a shopping_list.
     */
    data: XOR<shopping_listCreateInput, shopping_listUncheckedCreateInput>
  }


  /**
   * shopping_list createMany
   */
  export type shopping_listCreateManyArgs = {
    /**
     * The data used to create many shopping_lists.
     */
    data: Enumerable<shopping_listCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * shopping_list update
   */
  export type shopping_listUpdateArgs = {
    /**
     * Select specific fields to fetch from the shopping_list
     */
    select?: shopping_listSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shopping_listInclude | null
    /**
     * The data needed to update a shopping_list.
     */
    data: XOR<shopping_listUpdateInput, shopping_listUncheckedUpdateInput>
    /**
     * Choose, which shopping_list to update.
     */
    where: shopping_listWhereUniqueInput
  }


  /**
   * shopping_list updateMany
   */
  export type shopping_listUpdateManyArgs = {
    /**
     * The data used to update shopping_lists.
     */
    data: XOR<shopping_listUpdateManyMutationInput, shopping_listUncheckedUpdateManyInput>
    /**
     * Filter which shopping_lists to update
     */
    where?: shopping_listWhereInput
  }


  /**
   * shopping_list upsert
   */
  export type shopping_listUpsertArgs = {
    /**
     * Select specific fields to fetch from the shopping_list
     */
    select?: shopping_listSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shopping_listInclude | null
    /**
     * The filter to search for the shopping_list to update in case it exists.
     */
    where: shopping_listWhereUniqueInput
    /**
     * In case the shopping_list found by the `where` argument doesn't exist, create a new shopping_list with this data.
     */
    create: XOR<shopping_listCreateInput, shopping_listUncheckedCreateInput>
    /**
     * In case the shopping_list was found with the provided `where` argument, update it with this data.
     */
    update: XOR<shopping_listUpdateInput, shopping_listUncheckedUpdateInput>
  }


  /**
   * shopping_list delete
   */
  export type shopping_listDeleteArgs = {
    /**
     * Select specific fields to fetch from the shopping_list
     */
    select?: shopping_listSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shopping_listInclude | null
    /**
     * Filter which shopping_list to delete.
     */
    where: shopping_listWhereUniqueInput
  }


  /**
   * shopping_list deleteMany
   */
  export type shopping_listDeleteManyArgs = {
    /**
     * Filter which shopping_lists to delete
     */
    where?: shopping_listWhereInput
  }


  /**
   * shopping_list.products_in_shopping_list
   */
  export type shopping_list$products_in_shopping_listArgs = {
    /**
     * Select specific fields to fetch from the products_in_shopping_list
     */
    select?: products_in_shopping_listSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: products_in_shopping_listInclude | null
    where?: products_in_shopping_listWhereInput
    orderBy?: Enumerable<products_in_shopping_listOrderByWithRelationInput>
    cursor?: products_in_shopping_listWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Products_in_shopping_listScalarFieldEnum>
  }


  /**
   * shopping_list without action
   */
  export type shopping_listArgs = {
    /**
     * Select specific fields to fetch from the shopping_list
     */
    select?: shopping_listSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shopping_listInclude | null
  }



  /**
   * Model products_in_shopping_list
   */


  export type AggregateProducts_in_shopping_list = {
    _count: Products_in_shopping_listCountAggregateOutputType | null
    _avg: Products_in_shopping_listAvgAggregateOutputType | null
    _sum: Products_in_shopping_listSumAggregateOutputType | null
    _min: Products_in_shopping_listMinAggregateOutputType | null
    _max: Products_in_shopping_listMaxAggregateOutputType | null
  }

  export type Products_in_shopping_listAvgAggregateOutputType = {
    id: number | null
    shopping_listId: number | null
    productId: number | null
  }

  export type Products_in_shopping_listSumAggregateOutputType = {
    id: number | null
    shopping_listId: number | null
    productId: number | null
  }

  export type Products_in_shopping_listMinAggregateOutputType = {
    id: number | null
    shopping_listId: number | null
    productId: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Products_in_shopping_listMaxAggregateOutputType = {
    id: number | null
    shopping_listId: number | null
    productId: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Products_in_shopping_listCountAggregateOutputType = {
    id: number
    shopping_listId: number
    productId: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Products_in_shopping_listAvgAggregateInputType = {
    id?: true
    shopping_listId?: true
    productId?: true
  }

  export type Products_in_shopping_listSumAggregateInputType = {
    id?: true
    shopping_listId?: true
    productId?: true
  }

  export type Products_in_shopping_listMinAggregateInputType = {
    id?: true
    shopping_listId?: true
    productId?: true
    created_at?: true
    updated_at?: true
  }

  export type Products_in_shopping_listMaxAggregateInputType = {
    id?: true
    shopping_listId?: true
    productId?: true
    created_at?: true
    updated_at?: true
  }

  export type Products_in_shopping_listCountAggregateInputType = {
    id?: true
    shopping_listId?: true
    productId?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Products_in_shopping_listAggregateArgs = {
    /**
     * Filter which products_in_shopping_list to aggregate.
     */
    where?: products_in_shopping_listWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products_in_shopping_lists to fetch.
     */
    orderBy?: Enumerable<products_in_shopping_listOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: products_in_shopping_listWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products_in_shopping_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products_in_shopping_lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned products_in_shopping_lists
    **/
    _count?: true | Products_in_shopping_listCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Products_in_shopping_listAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Products_in_shopping_listSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Products_in_shopping_listMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Products_in_shopping_listMaxAggregateInputType
  }

  export type GetProducts_in_shopping_listAggregateType<T extends Products_in_shopping_listAggregateArgs> = {
        [P in keyof T & keyof AggregateProducts_in_shopping_list]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducts_in_shopping_list[P]>
      : GetScalarType<T[P], AggregateProducts_in_shopping_list[P]>
  }




  export type Products_in_shopping_listGroupByArgs = {
    where?: products_in_shopping_listWhereInput
    orderBy?: Enumerable<products_in_shopping_listOrderByWithAggregationInput>
    by: Products_in_shopping_listScalarFieldEnum[]
    having?: products_in_shopping_listScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Products_in_shopping_listCountAggregateInputType | true
    _avg?: Products_in_shopping_listAvgAggregateInputType
    _sum?: Products_in_shopping_listSumAggregateInputType
    _min?: Products_in_shopping_listMinAggregateInputType
    _max?: Products_in_shopping_listMaxAggregateInputType
  }


  export type Products_in_shopping_listGroupByOutputType = {
    id: number
    shopping_listId: number
    productId: number
    created_at: Date
    updated_at: Date
    _count: Products_in_shopping_listCountAggregateOutputType | null
    _avg: Products_in_shopping_listAvgAggregateOutputType | null
    _sum: Products_in_shopping_listSumAggregateOutputType | null
    _min: Products_in_shopping_listMinAggregateOutputType | null
    _max: Products_in_shopping_listMaxAggregateOutputType | null
  }

  type GetProducts_in_shopping_listGroupByPayload<T extends Products_in_shopping_listGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Products_in_shopping_listGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Products_in_shopping_listGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Products_in_shopping_listGroupByOutputType[P]>
            : GetScalarType<T[P], Products_in_shopping_listGroupByOutputType[P]>
        }
      >
    >


  export type products_in_shopping_listSelect = {
    id?: boolean
    shopping_listId?: boolean
    productId?: boolean
    created_at?: boolean
    updated_at?: boolean
    product?: boolean | productArgs
    shopping_list?: boolean | shopping_listArgs
  }


  export type products_in_shopping_listInclude = {
    product?: boolean | productArgs
    shopping_list?: boolean | shopping_listArgs
  }

  export type products_in_shopping_listGetPayload<S extends boolean | null | undefined | products_in_shopping_listArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? products_in_shopping_list :
    S extends undefined ? never :
    S extends { include: any } & (products_in_shopping_listArgs | products_in_shopping_listFindManyArgs)
    ? products_in_shopping_list  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'product' ? productGetPayload<S['include'][P]> :
        P extends 'shopping_list' ? shopping_listGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (products_in_shopping_listArgs | products_in_shopping_listFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'product' ? productGetPayload<S['select'][P]> :
        P extends 'shopping_list' ? shopping_listGetPayload<S['select'][P]> :  P extends keyof products_in_shopping_list ? products_in_shopping_list[P] : never
  } 
      : products_in_shopping_list


  type products_in_shopping_listCountArgs = 
    Omit<products_in_shopping_listFindManyArgs, 'select' | 'include'> & {
      select?: Products_in_shopping_listCountAggregateInputType | true
    }

  export interface products_in_shopping_listDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Products_in_shopping_list that matches the filter.
     * @param {products_in_shopping_listFindUniqueArgs} args - Arguments to find a Products_in_shopping_list
     * @example
     * // Get one Products_in_shopping_list
     * const products_in_shopping_list = await prisma.products_in_shopping_list.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends products_in_shopping_listFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, products_in_shopping_listFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'products_in_shopping_list'> extends True ? Prisma__products_in_shopping_listClient<products_in_shopping_listGetPayload<T>> : Prisma__products_in_shopping_listClient<products_in_shopping_listGetPayload<T> | null, null>

    /**
     * Find one Products_in_shopping_list that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {products_in_shopping_listFindUniqueOrThrowArgs} args - Arguments to find a Products_in_shopping_list
     * @example
     * // Get one Products_in_shopping_list
     * const products_in_shopping_list = await prisma.products_in_shopping_list.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends products_in_shopping_listFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, products_in_shopping_listFindUniqueOrThrowArgs>
    ): Prisma__products_in_shopping_listClient<products_in_shopping_listGetPayload<T>>

    /**
     * Find the first Products_in_shopping_list that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {products_in_shopping_listFindFirstArgs} args - Arguments to find a Products_in_shopping_list
     * @example
     * // Get one Products_in_shopping_list
     * const products_in_shopping_list = await prisma.products_in_shopping_list.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends products_in_shopping_listFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, products_in_shopping_listFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'products_in_shopping_list'> extends True ? Prisma__products_in_shopping_listClient<products_in_shopping_listGetPayload<T>> : Prisma__products_in_shopping_listClient<products_in_shopping_listGetPayload<T> | null, null>

    /**
     * Find the first Products_in_shopping_list that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {products_in_shopping_listFindFirstOrThrowArgs} args - Arguments to find a Products_in_shopping_list
     * @example
     * // Get one Products_in_shopping_list
     * const products_in_shopping_list = await prisma.products_in_shopping_list.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends products_in_shopping_listFindFirstOrThrowArgs>(
      args?: SelectSubset<T, products_in_shopping_listFindFirstOrThrowArgs>
    ): Prisma__products_in_shopping_listClient<products_in_shopping_listGetPayload<T>>

    /**
     * Find zero or more Products_in_shopping_lists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {products_in_shopping_listFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products_in_shopping_lists
     * const products_in_shopping_lists = await prisma.products_in_shopping_list.findMany()
     * 
     * // Get first 10 Products_in_shopping_lists
     * const products_in_shopping_lists = await prisma.products_in_shopping_list.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const products_in_shopping_listWithIdOnly = await prisma.products_in_shopping_list.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends products_in_shopping_listFindManyArgs>(
      args?: SelectSubset<T, products_in_shopping_listFindManyArgs>
    ): Prisma.PrismaPromise<Array<products_in_shopping_listGetPayload<T>>>

    /**
     * Create a Products_in_shopping_list.
     * @param {products_in_shopping_listCreateArgs} args - Arguments to create a Products_in_shopping_list.
     * @example
     * // Create one Products_in_shopping_list
     * const Products_in_shopping_list = await prisma.products_in_shopping_list.create({
     *   data: {
     *     // ... data to create a Products_in_shopping_list
     *   }
     * })
     * 
    **/
    create<T extends products_in_shopping_listCreateArgs>(
      args: SelectSubset<T, products_in_shopping_listCreateArgs>
    ): Prisma__products_in_shopping_listClient<products_in_shopping_listGetPayload<T>>

    /**
     * Create many Products_in_shopping_lists.
     *     @param {products_in_shopping_listCreateManyArgs} args - Arguments to create many Products_in_shopping_lists.
     *     @example
     *     // Create many Products_in_shopping_lists
     *     const products_in_shopping_list = await prisma.products_in_shopping_list.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends products_in_shopping_listCreateManyArgs>(
      args?: SelectSubset<T, products_in_shopping_listCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Products_in_shopping_list.
     * @param {products_in_shopping_listDeleteArgs} args - Arguments to delete one Products_in_shopping_list.
     * @example
     * // Delete one Products_in_shopping_list
     * const Products_in_shopping_list = await prisma.products_in_shopping_list.delete({
     *   where: {
     *     // ... filter to delete one Products_in_shopping_list
     *   }
     * })
     * 
    **/
    delete<T extends products_in_shopping_listDeleteArgs>(
      args: SelectSubset<T, products_in_shopping_listDeleteArgs>
    ): Prisma__products_in_shopping_listClient<products_in_shopping_listGetPayload<T>>

    /**
     * Update one Products_in_shopping_list.
     * @param {products_in_shopping_listUpdateArgs} args - Arguments to update one Products_in_shopping_list.
     * @example
     * // Update one Products_in_shopping_list
     * const products_in_shopping_list = await prisma.products_in_shopping_list.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends products_in_shopping_listUpdateArgs>(
      args: SelectSubset<T, products_in_shopping_listUpdateArgs>
    ): Prisma__products_in_shopping_listClient<products_in_shopping_listGetPayload<T>>

    /**
     * Delete zero or more Products_in_shopping_lists.
     * @param {products_in_shopping_listDeleteManyArgs} args - Arguments to filter Products_in_shopping_lists to delete.
     * @example
     * // Delete a few Products_in_shopping_lists
     * const { count } = await prisma.products_in_shopping_list.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends products_in_shopping_listDeleteManyArgs>(
      args?: SelectSubset<T, products_in_shopping_listDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products_in_shopping_lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {products_in_shopping_listUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products_in_shopping_lists
     * const products_in_shopping_list = await prisma.products_in_shopping_list.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends products_in_shopping_listUpdateManyArgs>(
      args: SelectSubset<T, products_in_shopping_listUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Products_in_shopping_list.
     * @param {products_in_shopping_listUpsertArgs} args - Arguments to update or create a Products_in_shopping_list.
     * @example
     * // Update or create a Products_in_shopping_list
     * const products_in_shopping_list = await prisma.products_in_shopping_list.upsert({
     *   create: {
     *     // ... data to create a Products_in_shopping_list
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Products_in_shopping_list we want to update
     *   }
     * })
    **/
    upsert<T extends products_in_shopping_listUpsertArgs>(
      args: SelectSubset<T, products_in_shopping_listUpsertArgs>
    ): Prisma__products_in_shopping_listClient<products_in_shopping_listGetPayload<T>>

    /**
     * Count the number of Products_in_shopping_lists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {products_in_shopping_listCountArgs} args - Arguments to filter Products_in_shopping_lists to count.
     * @example
     * // Count the number of Products_in_shopping_lists
     * const count = await prisma.products_in_shopping_list.count({
     *   where: {
     *     // ... the filter for the Products_in_shopping_lists we want to count
     *   }
     * })
    **/
    count<T extends products_in_shopping_listCountArgs>(
      args?: Subset<T, products_in_shopping_listCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Products_in_shopping_listCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Products_in_shopping_list.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Products_in_shopping_listAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Products_in_shopping_listAggregateArgs>(args: Subset<T, Products_in_shopping_listAggregateArgs>): Prisma.PrismaPromise<GetProducts_in_shopping_listAggregateType<T>>

    /**
     * Group by Products_in_shopping_list.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Products_in_shopping_listGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Products_in_shopping_listGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Products_in_shopping_listGroupByArgs['orderBy'] }
        : { orderBy?: Products_in_shopping_listGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Products_in_shopping_listGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProducts_in_shopping_listGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for products_in_shopping_list.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__products_in_shopping_listClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    product<T extends productArgs= {}>(args?: Subset<T, productArgs>): Prisma__productClient<productGetPayload<T> | Null>;

    shopping_list<T extends shopping_listArgs= {}>(args?: Subset<T, shopping_listArgs>): Prisma__shopping_listClient<shopping_listGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * products_in_shopping_list base type for findUnique actions
   */
  export type products_in_shopping_listFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the products_in_shopping_list
     */
    select?: products_in_shopping_listSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: products_in_shopping_listInclude | null
    /**
     * Filter, which products_in_shopping_list to fetch.
     */
    where: products_in_shopping_listWhereUniqueInput
  }

  /**
   * products_in_shopping_list findUnique
   */
  export interface products_in_shopping_listFindUniqueArgs extends products_in_shopping_listFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * products_in_shopping_list findUniqueOrThrow
   */
  export type products_in_shopping_listFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the products_in_shopping_list
     */
    select?: products_in_shopping_listSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: products_in_shopping_listInclude | null
    /**
     * Filter, which products_in_shopping_list to fetch.
     */
    where: products_in_shopping_listWhereUniqueInput
  }


  /**
   * products_in_shopping_list base type for findFirst actions
   */
  export type products_in_shopping_listFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the products_in_shopping_list
     */
    select?: products_in_shopping_listSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: products_in_shopping_listInclude | null
    /**
     * Filter, which products_in_shopping_list to fetch.
     */
    where?: products_in_shopping_listWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products_in_shopping_lists to fetch.
     */
    orderBy?: Enumerable<products_in_shopping_listOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products_in_shopping_lists.
     */
    cursor?: products_in_shopping_listWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products_in_shopping_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products_in_shopping_lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products_in_shopping_lists.
     */
    distinct?: Enumerable<Products_in_shopping_listScalarFieldEnum>
  }

  /**
   * products_in_shopping_list findFirst
   */
  export interface products_in_shopping_listFindFirstArgs extends products_in_shopping_listFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * products_in_shopping_list findFirstOrThrow
   */
  export type products_in_shopping_listFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the products_in_shopping_list
     */
    select?: products_in_shopping_listSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: products_in_shopping_listInclude | null
    /**
     * Filter, which products_in_shopping_list to fetch.
     */
    where?: products_in_shopping_listWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products_in_shopping_lists to fetch.
     */
    orderBy?: Enumerable<products_in_shopping_listOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products_in_shopping_lists.
     */
    cursor?: products_in_shopping_listWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products_in_shopping_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products_in_shopping_lists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products_in_shopping_lists.
     */
    distinct?: Enumerable<Products_in_shopping_listScalarFieldEnum>
  }


  /**
   * products_in_shopping_list findMany
   */
  export type products_in_shopping_listFindManyArgs = {
    /**
     * Select specific fields to fetch from the products_in_shopping_list
     */
    select?: products_in_shopping_listSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: products_in_shopping_listInclude | null
    /**
     * Filter, which products_in_shopping_lists to fetch.
     */
    where?: products_in_shopping_listWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products_in_shopping_lists to fetch.
     */
    orderBy?: Enumerable<products_in_shopping_listOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing products_in_shopping_lists.
     */
    cursor?: products_in_shopping_listWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products_in_shopping_lists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products_in_shopping_lists.
     */
    skip?: number
    distinct?: Enumerable<Products_in_shopping_listScalarFieldEnum>
  }


  /**
   * products_in_shopping_list create
   */
  export type products_in_shopping_listCreateArgs = {
    /**
     * Select specific fields to fetch from the products_in_shopping_list
     */
    select?: products_in_shopping_listSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: products_in_shopping_listInclude | null
    /**
     * The data needed to create a products_in_shopping_list.
     */
    data: XOR<products_in_shopping_listCreateInput, products_in_shopping_listUncheckedCreateInput>
  }


  /**
   * products_in_shopping_list createMany
   */
  export type products_in_shopping_listCreateManyArgs = {
    /**
     * The data used to create many products_in_shopping_lists.
     */
    data: Enumerable<products_in_shopping_listCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * products_in_shopping_list update
   */
  export type products_in_shopping_listUpdateArgs = {
    /**
     * Select specific fields to fetch from the products_in_shopping_list
     */
    select?: products_in_shopping_listSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: products_in_shopping_listInclude | null
    /**
     * The data needed to update a products_in_shopping_list.
     */
    data: XOR<products_in_shopping_listUpdateInput, products_in_shopping_listUncheckedUpdateInput>
    /**
     * Choose, which products_in_shopping_list to update.
     */
    where: products_in_shopping_listWhereUniqueInput
  }


  /**
   * products_in_shopping_list updateMany
   */
  export type products_in_shopping_listUpdateManyArgs = {
    /**
     * The data used to update products_in_shopping_lists.
     */
    data: XOR<products_in_shopping_listUpdateManyMutationInput, products_in_shopping_listUncheckedUpdateManyInput>
    /**
     * Filter which products_in_shopping_lists to update
     */
    where?: products_in_shopping_listWhereInput
  }


  /**
   * products_in_shopping_list upsert
   */
  export type products_in_shopping_listUpsertArgs = {
    /**
     * Select specific fields to fetch from the products_in_shopping_list
     */
    select?: products_in_shopping_listSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: products_in_shopping_listInclude | null
    /**
     * The filter to search for the products_in_shopping_list to update in case it exists.
     */
    where: products_in_shopping_listWhereUniqueInput
    /**
     * In case the products_in_shopping_list found by the `where` argument doesn't exist, create a new products_in_shopping_list with this data.
     */
    create: XOR<products_in_shopping_listCreateInput, products_in_shopping_listUncheckedCreateInput>
    /**
     * In case the products_in_shopping_list was found with the provided `where` argument, update it with this data.
     */
    update: XOR<products_in_shopping_listUpdateInput, products_in_shopping_listUncheckedUpdateInput>
  }


  /**
   * products_in_shopping_list delete
   */
  export type products_in_shopping_listDeleteArgs = {
    /**
     * Select specific fields to fetch from the products_in_shopping_list
     */
    select?: products_in_shopping_listSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: products_in_shopping_listInclude | null
    /**
     * Filter which products_in_shopping_list to delete.
     */
    where: products_in_shopping_listWhereUniqueInput
  }


  /**
   * products_in_shopping_list deleteMany
   */
  export type products_in_shopping_listDeleteManyArgs = {
    /**
     * Filter which products_in_shopping_lists to delete
     */
    where?: products_in_shopping_listWhereInput
  }


  /**
   * products_in_shopping_list without action
   */
  export type products_in_shopping_listArgs = {
    /**
     * Select specific fields to fetch from the products_in_shopping_list
     */
    select?: products_in_shopping_listSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: products_in_shopping_listInclude | null
  }



  /**
   * Model product
   */


  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    price: number | null
    quantity: number | null
    review: number | null
    available_quantity: number | null
    marketerId: number | null
    category_of_productId: number | null
    type_of_productId: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    price: number | null
    quantity: number | null
    review: number | null
    available_quantity: number | null
    marketerId: number | null
    category_of_productId: number | null
    type_of_productId: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    name: string | null
    price: number | null
    quantity: number | null
    review: number | null
    active_for_selling: boolean | null
    available_quantity: number | null
    marketerId: number | null
    created_at: Date | null
    updated_at: Date | null
    description: string | null
    category_of_productId: number | null
    type_of_productId: number | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    name: string | null
    price: number | null
    quantity: number | null
    review: number | null
    active_for_selling: boolean | null
    available_quantity: number | null
    marketerId: number | null
    created_at: Date | null
    updated_at: Date | null
    description: string | null
    category_of_productId: number | null
    type_of_productId: number | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    price: number
    quantity: number
    review: number
    active_for_selling: number
    available_quantity: number
    marketerId: number
    created_at: number
    updated_at: number
    description: number
    category_of_productId: number
    type_of_productId: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    price?: true
    quantity?: true
    review?: true
    available_quantity?: true
    marketerId?: true
    category_of_productId?: true
    type_of_productId?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    price?: true
    quantity?: true
    review?: true
    available_quantity?: true
    marketerId?: true
    category_of_productId?: true
    type_of_productId?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    quantity?: true
    review?: true
    active_for_selling?: true
    available_quantity?: true
    marketerId?: true
    created_at?: true
    updated_at?: true
    description?: true
    category_of_productId?: true
    type_of_productId?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    quantity?: true
    review?: true
    active_for_selling?: true
    available_quantity?: true
    marketerId?: true
    created_at?: true
    updated_at?: true
    description?: true
    category_of_productId?: true
    type_of_productId?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    quantity?: true
    review?: true
    active_for_selling?: true
    available_quantity?: true
    marketerId?: true
    created_at?: true
    updated_at?: true
    description?: true
    category_of_productId?: true
    type_of_productId?: true
    _all?: true
  }

  export type ProductAggregateArgs = {
    /**
     * Filter which product to aggregate.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: Enumerable<productOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs = {
    where?: productWhereInput
    orderBy?: Enumerable<productOrderByWithAggregationInput>
    by: ProductScalarFieldEnum[]
    having?: productScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }


  export type ProductGroupByOutputType = {
    id: number
    name: string
    price: number
    quantity: number | null
    review: number
    active_for_selling: boolean
    available_quantity: number
    marketerId: number
    created_at: Date
    updated_at: Date
    description: string
    category_of_productId: number
    type_of_productId: number
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type productSelect = {
    id?: boolean
    name?: boolean
    price?: boolean
    quantity?: boolean
    review?: boolean
    active_for_selling?: boolean
    available_quantity?: boolean
    marketerId?: boolean
    created_at?: boolean
    updated_at?: boolean
    description?: boolean
    category_of_productId?: boolean
    type_of_productId?: boolean
    image_of_product?: boolean | product$image_of_productArgs
    category_of_product?: boolean | category_of_productArgs
    marketer?: boolean | marketerArgs
    type_of_price?: boolean | type_of_priceArgs
    products_in_shopping_list?: boolean | product$products_in_shopping_listArgs
    sale_off?: boolean | product$sale_offArgs
    _count?: boolean | ProductCountOutputTypeArgs
  }


  export type productInclude = {
    image_of_product?: boolean | product$image_of_productArgs
    category_of_product?: boolean | category_of_productArgs
    marketer?: boolean | marketerArgs
    type_of_price?: boolean | type_of_priceArgs
    products_in_shopping_list?: boolean | product$products_in_shopping_listArgs
    sale_off?: boolean | product$sale_offArgs
    _count?: boolean | ProductCountOutputTypeArgs
  }

  export type productGetPayload<S extends boolean | null | undefined | productArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? product :
    S extends undefined ? never :
    S extends { include: any } & (productArgs | productFindManyArgs)
    ? product  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'image_of_product' ? Array < image_of_productGetPayload<S['include'][P]>>  :
        P extends 'category_of_product' ? category_of_productGetPayload<S['include'][P]> :
        P extends 'marketer' ? marketerGetPayload<S['include'][P]> :
        P extends 'type_of_price' ? type_of_priceGetPayload<S['include'][P]> :
        P extends 'products_in_shopping_list' ? Array < products_in_shopping_listGetPayload<S['include'][P]>>  :
        P extends 'sale_off' ? Array < sale_offGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProductCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (productArgs | productFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'image_of_product' ? Array < image_of_productGetPayload<S['select'][P]>>  :
        P extends 'category_of_product' ? category_of_productGetPayload<S['select'][P]> :
        P extends 'marketer' ? marketerGetPayload<S['select'][P]> :
        P extends 'type_of_price' ? type_of_priceGetPayload<S['select'][P]> :
        P extends 'products_in_shopping_list' ? Array < products_in_shopping_listGetPayload<S['select'][P]>>  :
        P extends 'sale_off' ? Array < sale_offGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProductCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof product ? product[P] : never
  } 
      : product


  type productCountArgs = 
    Omit<productFindManyArgs, 'select' | 'include'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface productDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Product that matches the filter.
     * @param {productFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends productFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, productFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'product'> extends True ? Prisma__productClient<productGetPayload<T>> : Prisma__productClient<productGetPayload<T> | null, null>

    /**
     * Find one Product that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {productFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends productFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, productFindUniqueOrThrowArgs>
    ): Prisma__productClient<productGetPayload<T>>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends productFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, productFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'product'> extends True ? Prisma__productClient<productGetPayload<T>> : Prisma__productClient<productGetPayload<T> | null, null>

    /**
     * Find the first Product that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends productFindFirstOrThrowArgs>(
      args?: SelectSubset<T, productFindFirstOrThrowArgs>
    ): Prisma__productClient<productGetPayload<T>>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends productFindManyArgs>(
      args?: SelectSubset<T, productFindManyArgs>
    ): Prisma.PrismaPromise<Array<productGetPayload<T>>>

    /**
     * Create a Product.
     * @param {productCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends productCreateArgs>(
      args: SelectSubset<T, productCreateArgs>
    ): Prisma__productClient<productGetPayload<T>>

    /**
     * Create many Products.
     *     @param {productCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends productCreateManyArgs>(
      args?: SelectSubset<T, productCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {productDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends productDeleteArgs>(
      args: SelectSubset<T, productDeleteArgs>
    ): Prisma__productClient<productGetPayload<T>>

    /**
     * Update one Product.
     * @param {productUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends productUpdateArgs>(
      args: SelectSubset<T, productUpdateArgs>
    ): Prisma__productClient<productGetPayload<T>>

    /**
     * Delete zero or more Products.
     * @param {productDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends productDeleteManyArgs>(
      args?: SelectSubset<T, productDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends productUpdateManyArgs>(
      args: SelectSubset<T, productUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {productUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends productUpsertArgs>(
      args: SelectSubset<T, productUpsertArgs>
    ): Prisma__productClient<productGetPayload<T>>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends productCountArgs>(
      args?: Subset<T, productCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__productClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    image_of_product<T extends product$image_of_productArgs= {}>(args?: Subset<T, product$image_of_productArgs>): Prisma.PrismaPromise<Array<image_of_productGetPayload<T>>| Null>;

    category_of_product<T extends category_of_productArgs= {}>(args?: Subset<T, category_of_productArgs>): Prisma__category_of_productClient<category_of_productGetPayload<T> | Null>;

    marketer<T extends marketerArgs= {}>(args?: Subset<T, marketerArgs>): Prisma__marketerClient<marketerGetPayload<T> | Null>;

    type_of_price<T extends type_of_priceArgs= {}>(args?: Subset<T, type_of_priceArgs>): Prisma__type_of_priceClient<type_of_priceGetPayload<T> | Null>;

    products_in_shopping_list<T extends product$products_in_shopping_listArgs= {}>(args?: Subset<T, product$products_in_shopping_listArgs>): Prisma.PrismaPromise<Array<products_in_shopping_listGetPayload<T>>| Null>;

    sale_off<T extends product$sale_offArgs= {}>(args?: Subset<T, product$sale_offArgs>): Prisma.PrismaPromise<Array<sale_offGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * product base type for findUnique actions
   */
  export type productFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude | null
    /**
     * Filter, which product to fetch.
     */
    where: productWhereUniqueInput
  }

  /**
   * product findUnique
   */
  export interface productFindUniqueArgs extends productFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * product findUniqueOrThrow
   */
  export type productFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude | null
    /**
     * Filter, which product to fetch.
     */
    where: productWhereUniqueInput
  }


  /**
   * product base type for findFirst actions
   */
  export type productFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude | null
    /**
     * Filter, which product to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: Enumerable<productOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: Enumerable<ProductScalarFieldEnum>
  }

  /**
   * product findFirst
   */
  export interface productFindFirstArgs extends productFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * product findFirstOrThrow
   */
  export type productFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude | null
    /**
     * Filter, which product to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: Enumerable<productOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * product findMany
   */
  export type productFindManyArgs = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude | null
    /**
     * Filter, which products to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: Enumerable<productOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * product create
   */
  export type productCreateArgs = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude | null
    /**
     * The data needed to create a product.
     */
    data: XOR<productCreateInput, productUncheckedCreateInput>
  }


  /**
   * product createMany
   */
  export type productCreateManyArgs = {
    /**
     * The data used to create many products.
     */
    data: Enumerable<productCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * product update
   */
  export type productUpdateArgs = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude | null
    /**
     * The data needed to update a product.
     */
    data: XOR<productUpdateInput, productUncheckedUpdateInput>
    /**
     * Choose, which product to update.
     */
    where: productWhereUniqueInput
  }


  /**
   * product updateMany
   */
  export type productUpdateManyArgs = {
    /**
     * The data used to update products.
     */
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     */
    where?: productWhereInput
  }


  /**
   * product upsert
   */
  export type productUpsertArgs = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude | null
    /**
     * The filter to search for the product to update in case it exists.
     */
    where: productWhereUniqueInput
    /**
     * In case the product found by the `where` argument doesn't exist, create a new product with this data.
     */
    create: XOR<productCreateInput, productUncheckedCreateInput>
    /**
     * In case the product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productUpdateInput, productUncheckedUpdateInput>
  }


  /**
   * product delete
   */
  export type productDeleteArgs = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude | null
    /**
     * Filter which product to delete.
     */
    where: productWhereUniqueInput
  }


  /**
   * product deleteMany
   */
  export type productDeleteManyArgs = {
    /**
     * Filter which products to delete
     */
    where?: productWhereInput
  }


  /**
   * product.image_of_product
   */
  export type product$image_of_productArgs = {
    /**
     * Select specific fields to fetch from the image_of_product
     */
    select?: image_of_productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: image_of_productInclude | null
    where?: image_of_productWhereInput
    orderBy?: Enumerable<image_of_productOrderByWithRelationInput>
    cursor?: image_of_productWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Image_of_productScalarFieldEnum>
  }


  /**
   * product.products_in_shopping_list
   */
  export type product$products_in_shopping_listArgs = {
    /**
     * Select specific fields to fetch from the products_in_shopping_list
     */
    select?: products_in_shopping_listSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: products_in_shopping_listInclude | null
    where?: products_in_shopping_listWhereInput
    orderBy?: Enumerable<products_in_shopping_listOrderByWithRelationInput>
    cursor?: products_in_shopping_listWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Products_in_shopping_listScalarFieldEnum>
  }


  /**
   * product.sale_off
   */
  export type product$sale_offArgs = {
    /**
     * Select specific fields to fetch from the sale_off
     */
    select?: sale_offSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sale_offInclude | null
    where?: sale_offWhereInput
    orderBy?: Enumerable<sale_offOrderByWithRelationInput>
    cursor?: sale_offWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Sale_offScalarFieldEnum>
  }


  /**
   * product without action
   */
  export type productArgs = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude | null
  }



  /**
   * Model marketer
   */


  export type AggregateMarketer = {
    _count: MarketerCountAggregateOutputType | null
    _avg: MarketerAvgAggregateOutputType | null
    _sum: MarketerSumAggregateOutputType | null
    _min: MarketerMinAggregateOutputType | null
    _max: MarketerMaxAggregateOutputType | null
  }

  export type MarketerAvgAggregateOutputType = {
    id: number | null
    review: number | null
    locationId: number | null
    genderId: number | null
  }

  export type MarketerSumAggregateOutputType = {
    id: number | null
    review: number | null
    locationId: number | null
    genderId: number | null
  }

  export type MarketerMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password_hash: string | null
    picture_uri: string | null
    review: number | null
    online: boolean | null
    locationId: number | null
    created_at: Date | null
    birthday: string | null
    updated_at: Date | null
    genderId: number | null
    cnpj: string | null
    cpf: string | null
    phone: string | null
    tent_name: string | null
  }

  export type MarketerMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password_hash: string | null
    picture_uri: string | null
    review: number | null
    online: boolean | null
    locationId: number | null
    created_at: Date | null
    birthday: string | null
    updated_at: Date | null
    genderId: number | null
    cnpj: string | null
    cpf: string | null
    phone: string | null
    tent_name: string | null
  }

  export type MarketerCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password_hash: number
    picture_uri: number
    review: number
    online: number
    locationId: number
    created_at: number
    birthday: number
    updated_at: number
    genderId: number
    cnpj: number
    cpf: number
    phone: number
    tent_name: number
    _all: number
  }


  export type MarketerAvgAggregateInputType = {
    id?: true
    review?: true
    locationId?: true
    genderId?: true
  }

  export type MarketerSumAggregateInputType = {
    id?: true
    review?: true
    locationId?: true
    genderId?: true
  }

  export type MarketerMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password_hash?: true
    picture_uri?: true
    review?: true
    online?: true
    locationId?: true
    created_at?: true
    birthday?: true
    updated_at?: true
    genderId?: true
    cnpj?: true
    cpf?: true
    phone?: true
    tent_name?: true
  }

  export type MarketerMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password_hash?: true
    picture_uri?: true
    review?: true
    online?: true
    locationId?: true
    created_at?: true
    birthday?: true
    updated_at?: true
    genderId?: true
    cnpj?: true
    cpf?: true
    phone?: true
    tent_name?: true
  }

  export type MarketerCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password_hash?: true
    picture_uri?: true
    review?: true
    online?: true
    locationId?: true
    created_at?: true
    birthday?: true
    updated_at?: true
    genderId?: true
    cnpj?: true
    cpf?: true
    phone?: true
    tent_name?: true
    _all?: true
  }

  export type MarketerAggregateArgs = {
    /**
     * Filter which marketer to aggregate.
     */
    where?: marketerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of marketers to fetch.
     */
    orderBy?: Enumerable<marketerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: marketerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` marketers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` marketers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned marketers
    **/
    _count?: true | MarketerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketerMaxAggregateInputType
  }

  export type GetMarketerAggregateType<T extends MarketerAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketer[P]>
      : GetScalarType<T[P], AggregateMarketer[P]>
  }




  export type MarketerGroupByArgs = {
    where?: marketerWhereInput
    orderBy?: Enumerable<marketerOrderByWithAggregationInput>
    by: MarketerScalarFieldEnum[]
    having?: marketerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketerCountAggregateInputType | true
    _avg?: MarketerAvgAggregateInputType
    _sum?: MarketerSumAggregateInputType
    _min?: MarketerMinAggregateInputType
    _max?: MarketerMaxAggregateInputType
  }


  export type MarketerGroupByOutputType = {
    id: number
    name: string
    email: string
    password_hash: string
    picture_uri: string | null
    review: number
    online: boolean
    locationId: number
    created_at: Date
    birthday: string
    updated_at: Date
    genderId: number
    cnpj: string | null
    cpf: string | null
    phone: string
    tent_name: string
    _count: MarketerCountAggregateOutputType | null
    _avg: MarketerAvgAggregateOutputType | null
    _sum: MarketerSumAggregateOutputType | null
    _min: MarketerMinAggregateOutputType | null
    _max: MarketerMaxAggregateOutputType | null
  }

  type GetMarketerGroupByPayload<T extends MarketerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MarketerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketerGroupByOutputType[P]>
            : GetScalarType<T[P], MarketerGroupByOutputType[P]>
        }
      >
    >


  export type marketerSelect = {
    id?: boolean
    name?: boolean
    email?: boolean
    password_hash?: boolean
    picture_uri?: boolean
    review?: boolean
    online?: boolean
    locationId?: boolean
    created_at?: boolean
    birthday?: boolean
    updated_at?: boolean
    genderId?: boolean
    cnpj?: boolean
    cpf?: boolean
    phone?: boolean
    tent_name?: boolean
    fair_marketers?: boolean | marketer$fair_marketersArgs
    gender?: boolean | genderArgs
    location?: boolean | locationArgs
    products?: boolean | marketer$productsArgs
    _count?: boolean | MarketerCountOutputTypeArgs
  }


  export type marketerInclude = {
    fair_marketers?: boolean | marketer$fair_marketersArgs
    gender?: boolean | genderArgs
    location?: boolean | locationArgs
    products?: boolean | marketer$productsArgs
    _count?: boolean | MarketerCountOutputTypeArgs
  }

  export type marketerGetPayload<S extends boolean | null | undefined | marketerArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? marketer :
    S extends undefined ? never :
    S extends { include: any } & (marketerArgs | marketerFindManyArgs)
    ? marketer  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'fair_marketers' ? Array < fair_marketersGetPayload<S['include'][P]>>  :
        P extends 'gender' ? genderGetPayload<S['include'][P]> :
        P extends 'location' ? locationGetPayload<S['include'][P]> :
        P extends 'products' ? Array < productGetPayload<S['include'][P]>>  :
        P extends '_count' ? MarketerCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (marketerArgs | marketerFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'fair_marketers' ? Array < fair_marketersGetPayload<S['select'][P]>>  :
        P extends 'gender' ? genderGetPayload<S['select'][P]> :
        P extends 'location' ? locationGetPayload<S['select'][P]> :
        P extends 'products' ? Array < productGetPayload<S['select'][P]>>  :
        P extends '_count' ? MarketerCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof marketer ? marketer[P] : never
  } 
      : marketer


  type marketerCountArgs = 
    Omit<marketerFindManyArgs, 'select' | 'include'> & {
      select?: MarketerCountAggregateInputType | true
    }

  export interface marketerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Marketer that matches the filter.
     * @param {marketerFindUniqueArgs} args - Arguments to find a Marketer
     * @example
     * // Get one Marketer
     * const marketer = await prisma.marketer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends marketerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, marketerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'marketer'> extends True ? Prisma__marketerClient<marketerGetPayload<T>> : Prisma__marketerClient<marketerGetPayload<T> | null, null>

    /**
     * Find one Marketer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {marketerFindUniqueOrThrowArgs} args - Arguments to find a Marketer
     * @example
     * // Get one Marketer
     * const marketer = await prisma.marketer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends marketerFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, marketerFindUniqueOrThrowArgs>
    ): Prisma__marketerClient<marketerGetPayload<T>>

    /**
     * Find the first Marketer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marketerFindFirstArgs} args - Arguments to find a Marketer
     * @example
     * // Get one Marketer
     * const marketer = await prisma.marketer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends marketerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, marketerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'marketer'> extends True ? Prisma__marketerClient<marketerGetPayload<T>> : Prisma__marketerClient<marketerGetPayload<T> | null, null>

    /**
     * Find the first Marketer that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marketerFindFirstOrThrowArgs} args - Arguments to find a Marketer
     * @example
     * // Get one Marketer
     * const marketer = await prisma.marketer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends marketerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, marketerFindFirstOrThrowArgs>
    ): Prisma__marketerClient<marketerGetPayload<T>>

    /**
     * Find zero or more Marketers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marketerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Marketers
     * const marketers = await prisma.marketer.findMany()
     * 
     * // Get first 10 Marketers
     * const marketers = await prisma.marketer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketerWithIdOnly = await prisma.marketer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends marketerFindManyArgs>(
      args?: SelectSubset<T, marketerFindManyArgs>
    ): Prisma.PrismaPromise<Array<marketerGetPayload<T>>>

    /**
     * Create a Marketer.
     * @param {marketerCreateArgs} args - Arguments to create a Marketer.
     * @example
     * // Create one Marketer
     * const Marketer = await prisma.marketer.create({
     *   data: {
     *     // ... data to create a Marketer
     *   }
     * })
     * 
    **/
    create<T extends marketerCreateArgs>(
      args: SelectSubset<T, marketerCreateArgs>
    ): Prisma__marketerClient<marketerGetPayload<T>>

    /**
     * Create many Marketers.
     *     @param {marketerCreateManyArgs} args - Arguments to create many Marketers.
     *     @example
     *     // Create many Marketers
     *     const marketer = await prisma.marketer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends marketerCreateManyArgs>(
      args?: SelectSubset<T, marketerCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Marketer.
     * @param {marketerDeleteArgs} args - Arguments to delete one Marketer.
     * @example
     * // Delete one Marketer
     * const Marketer = await prisma.marketer.delete({
     *   where: {
     *     // ... filter to delete one Marketer
     *   }
     * })
     * 
    **/
    delete<T extends marketerDeleteArgs>(
      args: SelectSubset<T, marketerDeleteArgs>
    ): Prisma__marketerClient<marketerGetPayload<T>>

    /**
     * Update one Marketer.
     * @param {marketerUpdateArgs} args - Arguments to update one Marketer.
     * @example
     * // Update one Marketer
     * const marketer = await prisma.marketer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends marketerUpdateArgs>(
      args: SelectSubset<T, marketerUpdateArgs>
    ): Prisma__marketerClient<marketerGetPayload<T>>

    /**
     * Delete zero or more Marketers.
     * @param {marketerDeleteManyArgs} args - Arguments to filter Marketers to delete.
     * @example
     * // Delete a few Marketers
     * const { count } = await prisma.marketer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends marketerDeleteManyArgs>(
      args?: SelectSubset<T, marketerDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Marketers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marketerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Marketers
     * const marketer = await prisma.marketer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends marketerUpdateManyArgs>(
      args: SelectSubset<T, marketerUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Marketer.
     * @param {marketerUpsertArgs} args - Arguments to update or create a Marketer.
     * @example
     * // Update or create a Marketer
     * const marketer = await prisma.marketer.upsert({
     *   create: {
     *     // ... data to create a Marketer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Marketer we want to update
     *   }
     * })
    **/
    upsert<T extends marketerUpsertArgs>(
      args: SelectSubset<T, marketerUpsertArgs>
    ): Prisma__marketerClient<marketerGetPayload<T>>

    /**
     * Count the number of Marketers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marketerCountArgs} args - Arguments to filter Marketers to count.
     * @example
     * // Count the number of Marketers
     * const count = await prisma.marketer.count({
     *   where: {
     *     // ... the filter for the Marketers we want to count
     *   }
     * })
    **/
    count<T extends marketerCountArgs>(
      args?: Subset<T, marketerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Marketer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketerAggregateArgs>(args: Subset<T, MarketerAggregateArgs>): Prisma.PrismaPromise<GetMarketerAggregateType<T>>

    /**
     * Group by Marketer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketerGroupByArgs['orderBy'] }
        : { orderBy?: MarketerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for marketer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__marketerClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    fair_marketers<T extends marketer$fair_marketersArgs= {}>(args?: Subset<T, marketer$fair_marketersArgs>): Prisma.PrismaPromise<Array<fair_marketersGetPayload<T>>| Null>;

    gender<T extends genderArgs= {}>(args?: Subset<T, genderArgs>): Prisma__genderClient<genderGetPayload<T> | Null>;

    location<T extends locationArgs= {}>(args?: Subset<T, locationArgs>): Prisma__locationClient<locationGetPayload<T> | Null>;

    products<T extends marketer$productsArgs= {}>(args?: Subset<T, marketer$productsArgs>): Prisma.PrismaPromise<Array<productGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * marketer base type for findUnique actions
   */
  export type marketerFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the marketer
     */
    select?: marketerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: marketerInclude | null
    /**
     * Filter, which marketer to fetch.
     */
    where: marketerWhereUniqueInput
  }

  /**
   * marketer findUnique
   */
  export interface marketerFindUniqueArgs extends marketerFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * marketer findUniqueOrThrow
   */
  export type marketerFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the marketer
     */
    select?: marketerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: marketerInclude | null
    /**
     * Filter, which marketer to fetch.
     */
    where: marketerWhereUniqueInput
  }


  /**
   * marketer base type for findFirst actions
   */
  export type marketerFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the marketer
     */
    select?: marketerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: marketerInclude | null
    /**
     * Filter, which marketer to fetch.
     */
    where?: marketerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of marketers to fetch.
     */
    orderBy?: Enumerable<marketerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for marketers.
     */
    cursor?: marketerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` marketers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` marketers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of marketers.
     */
    distinct?: Enumerable<MarketerScalarFieldEnum>
  }

  /**
   * marketer findFirst
   */
  export interface marketerFindFirstArgs extends marketerFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * marketer findFirstOrThrow
   */
  export type marketerFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the marketer
     */
    select?: marketerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: marketerInclude | null
    /**
     * Filter, which marketer to fetch.
     */
    where?: marketerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of marketers to fetch.
     */
    orderBy?: Enumerable<marketerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for marketers.
     */
    cursor?: marketerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` marketers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` marketers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of marketers.
     */
    distinct?: Enumerable<MarketerScalarFieldEnum>
  }


  /**
   * marketer findMany
   */
  export type marketerFindManyArgs = {
    /**
     * Select specific fields to fetch from the marketer
     */
    select?: marketerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: marketerInclude | null
    /**
     * Filter, which marketers to fetch.
     */
    where?: marketerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of marketers to fetch.
     */
    orderBy?: Enumerable<marketerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing marketers.
     */
    cursor?: marketerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` marketers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` marketers.
     */
    skip?: number
    distinct?: Enumerable<MarketerScalarFieldEnum>
  }


  /**
   * marketer create
   */
  export type marketerCreateArgs = {
    /**
     * Select specific fields to fetch from the marketer
     */
    select?: marketerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: marketerInclude | null
    /**
     * The data needed to create a marketer.
     */
    data: XOR<marketerCreateInput, marketerUncheckedCreateInput>
  }


  /**
   * marketer createMany
   */
  export type marketerCreateManyArgs = {
    /**
     * The data used to create many marketers.
     */
    data: Enumerable<marketerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * marketer update
   */
  export type marketerUpdateArgs = {
    /**
     * Select specific fields to fetch from the marketer
     */
    select?: marketerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: marketerInclude | null
    /**
     * The data needed to update a marketer.
     */
    data: XOR<marketerUpdateInput, marketerUncheckedUpdateInput>
    /**
     * Choose, which marketer to update.
     */
    where: marketerWhereUniqueInput
  }


  /**
   * marketer updateMany
   */
  export type marketerUpdateManyArgs = {
    /**
     * The data used to update marketers.
     */
    data: XOR<marketerUpdateManyMutationInput, marketerUncheckedUpdateManyInput>
    /**
     * Filter which marketers to update
     */
    where?: marketerWhereInput
  }


  /**
   * marketer upsert
   */
  export type marketerUpsertArgs = {
    /**
     * Select specific fields to fetch from the marketer
     */
    select?: marketerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: marketerInclude | null
    /**
     * The filter to search for the marketer to update in case it exists.
     */
    where: marketerWhereUniqueInput
    /**
     * In case the marketer found by the `where` argument doesn't exist, create a new marketer with this data.
     */
    create: XOR<marketerCreateInput, marketerUncheckedCreateInput>
    /**
     * In case the marketer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<marketerUpdateInput, marketerUncheckedUpdateInput>
  }


  /**
   * marketer delete
   */
  export type marketerDeleteArgs = {
    /**
     * Select specific fields to fetch from the marketer
     */
    select?: marketerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: marketerInclude | null
    /**
     * Filter which marketer to delete.
     */
    where: marketerWhereUniqueInput
  }


  /**
   * marketer deleteMany
   */
  export type marketerDeleteManyArgs = {
    /**
     * Filter which marketers to delete
     */
    where?: marketerWhereInput
  }


  /**
   * marketer.fair_marketers
   */
  export type marketer$fair_marketersArgs = {
    /**
     * Select specific fields to fetch from the fair_marketers
     */
    select?: fair_marketersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fair_marketersInclude | null
    where?: fair_marketersWhereInput
    orderBy?: Enumerable<fair_marketersOrderByWithRelationInput>
    cursor?: fair_marketersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Fair_marketersScalarFieldEnum>
  }


  /**
   * marketer.products
   */
  export type marketer$productsArgs = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude | null
    where?: productWhereInput
    orderBy?: Enumerable<productOrderByWithRelationInput>
    cursor?: productWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * marketer without action
   */
  export type marketerArgs = {
    /**
     * Select specific fields to fetch from the marketer
     */
    select?: marketerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: marketerInclude | null
  }



  /**
   * Model fair
   */


  export type AggregateFair = {
    _count: FairCountAggregateOutputType | null
    _avg: FairAvgAggregateOutputType | null
    _sum: FairSumAggregateOutputType | null
    _min: FairMinAggregateOutputType | null
    _max: FairMaxAggregateOutputType | null
  }

  export type FairAvgAggregateOutputType = {
    id: number | null
    review: number | null
    addressId: number | null
    locationId: number | null
  }

  export type FairSumAggregateOutputType = {
    id: number | null
    review: number | null
    addressId: number | null
    locationId: number | null
  }

  export type FairMinAggregateOutputType = {
    name: string | null
    id: number | null
    review: number | null
    addressId: number | null
    created_at: Date | null
    updated_at: Date | null
    locationId: number | null
  }

  export type FairMaxAggregateOutputType = {
    name: string | null
    id: number | null
    review: number | null
    addressId: number | null
    created_at: Date | null
    updated_at: Date | null
    locationId: number | null
  }

  export type FairCountAggregateOutputType = {
    name: number
    id: number
    review: number
    addressId: number
    created_at: number
    updated_at: number
    locationId: number
    _all: number
  }


  export type FairAvgAggregateInputType = {
    id?: true
    review?: true
    addressId?: true
    locationId?: true
  }

  export type FairSumAggregateInputType = {
    id?: true
    review?: true
    addressId?: true
    locationId?: true
  }

  export type FairMinAggregateInputType = {
    name?: true
    id?: true
    review?: true
    addressId?: true
    created_at?: true
    updated_at?: true
    locationId?: true
  }

  export type FairMaxAggregateInputType = {
    name?: true
    id?: true
    review?: true
    addressId?: true
    created_at?: true
    updated_at?: true
    locationId?: true
  }

  export type FairCountAggregateInputType = {
    name?: true
    id?: true
    review?: true
    addressId?: true
    created_at?: true
    updated_at?: true
    locationId?: true
    _all?: true
  }

  export type FairAggregateArgs = {
    /**
     * Filter which fair to aggregate.
     */
    where?: fairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fairs to fetch.
     */
    orderBy?: Enumerable<fairOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fairs
    **/
    _count?: true | FairCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FairAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FairSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FairMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FairMaxAggregateInputType
  }

  export type GetFairAggregateType<T extends FairAggregateArgs> = {
        [P in keyof T & keyof AggregateFair]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFair[P]>
      : GetScalarType<T[P], AggregateFair[P]>
  }




  export type FairGroupByArgs = {
    where?: fairWhereInput
    orderBy?: Enumerable<fairOrderByWithAggregationInput>
    by: FairScalarFieldEnum[]
    having?: fairScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FairCountAggregateInputType | true
    _avg?: FairAvgAggregateInputType
    _sum?: FairSumAggregateInputType
    _min?: FairMinAggregateInputType
    _max?: FairMaxAggregateInputType
  }


  export type FairGroupByOutputType = {
    name: string
    id: number
    review: number
    addressId: number
    created_at: Date
    updated_at: Date
    locationId: number
    _count: FairCountAggregateOutputType | null
    _avg: FairAvgAggregateOutputType | null
    _sum: FairSumAggregateOutputType | null
    _min: FairMinAggregateOutputType | null
    _max: FairMaxAggregateOutputType | null
  }

  type GetFairGroupByPayload<T extends FairGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FairGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FairGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FairGroupByOutputType[P]>
            : GetScalarType<T[P], FairGroupByOutputType[P]>
        }
      >
    >


  export type fairSelect = {
    name?: boolean
    id?: boolean
    review?: boolean
    addressId?: boolean
    created_at?: boolean
    updated_at?: boolean
    locationId?: boolean
    address?: boolean | addressArgs
    location?: boolean | locationArgs
    fair_date_hour_of_work?: boolean | fair$fair_date_hour_of_workArgs
    fair_marketers?: boolean | fair$fair_marketersArgs
    image?: boolean | fair$imageArgs
    _count?: boolean | FairCountOutputTypeArgs
  }


  export type fairInclude = {
    address?: boolean | addressArgs
    location?: boolean | locationArgs
    fair_date_hour_of_work?: boolean | fair$fair_date_hour_of_workArgs
    fair_marketers?: boolean | fair$fair_marketersArgs
    image?: boolean | fair$imageArgs
    _count?: boolean | FairCountOutputTypeArgs
  }

  export type fairGetPayload<S extends boolean | null | undefined | fairArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? fair :
    S extends undefined ? never :
    S extends { include: any } & (fairArgs | fairFindManyArgs)
    ? fair  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'address' ? addressGetPayload<S['include'][P]> :
        P extends 'location' ? locationGetPayload<S['include'][P]> :
        P extends 'fair_date_hour_of_work' ? Array < fair_date_hour_of_workGetPayload<S['include'][P]>>  :
        P extends 'fair_marketers' ? Array < fair_marketersGetPayload<S['include'][P]>>  :
        P extends 'image' ? Array < imageGetPayload<S['include'][P]>>  :
        P extends '_count' ? FairCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (fairArgs | fairFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'address' ? addressGetPayload<S['select'][P]> :
        P extends 'location' ? locationGetPayload<S['select'][P]> :
        P extends 'fair_date_hour_of_work' ? Array < fair_date_hour_of_workGetPayload<S['select'][P]>>  :
        P extends 'fair_marketers' ? Array < fair_marketersGetPayload<S['select'][P]>>  :
        P extends 'image' ? Array < imageGetPayload<S['select'][P]>>  :
        P extends '_count' ? FairCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof fair ? fair[P] : never
  } 
      : fair


  type fairCountArgs = 
    Omit<fairFindManyArgs, 'select' | 'include'> & {
      select?: FairCountAggregateInputType | true
    }

  export interface fairDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Fair that matches the filter.
     * @param {fairFindUniqueArgs} args - Arguments to find a Fair
     * @example
     * // Get one Fair
     * const fair = await prisma.fair.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends fairFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, fairFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'fair'> extends True ? Prisma__fairClient<fairGetPayload<T>> : Prisma__fairClient<fairGetPayload<T> | null, null>

    /**
     * Find one Fair that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {fairFindUniqueOrThrowArgs} args - Arguments to find a Fair
     * @example
     * // Get one Fair
     * const fair = await prisma.fair.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends fairFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, fairFindUniqueOrThrowArgs>
    ): Prisma__fairClient<fairGetPayload<T>>

    /**
     * Find the first Fair that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fairFindFirstArgs} args - Arguments to find a Fair
     * @example
     * // Get one Fair
     * const fair = await prisma.fair.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends fairFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, fairFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'fair'> extends True ? Prisma__fairClient<fairGetPayload<T>> : Prisma__fairClient<fairGetPayload<T> | null, null>

    /**
     * Find the first Fair that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fairFindFirstOrThrowArgs} args - Arguments to find a Fair
     * @example
     * // Get one Fair
     * const fair = await prisma.fair.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends fairFindFirstOrThrowArgs>(
      args?: SelectSubset<T, fairFindFirstOrThrowArgs>
    ): Prisma__fairClient<fairGetPayload<T>>

    /**
     * Find zero or more Fairs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fairFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fairs
     * const fairs = await prisma.fair.findMany()
     * 
     * // Get first 10 Fairs
     * const fairs = await prisma.fair.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const fairWithNameOnly = await prisma.fair.findMany({ select: { name: true } })
     * 
    **/
    findMany<T extends fairFindManyArgs>(
      args?: SelectSubset<T, fairFindManyArgs>
    ): Prisma.PrismaPromise<Array<fairGetPayload<T>>>

    /**
     * Create a Fair.
     * @param {fairCreateArgs} args - Arguments to create a Fair.
     * @example
     * // Create one Fair
     * const Fair = await prisma.fair.create({
     *   data: {
     *     // ... data to create a Fair
     *   }
     * })
     * 
    **/
    create<T extends fairCreateArgs>(
      args: SelectSubset<T, fairCreateArgs>
    ): Prisma__fairClient<fairGetPayload<T>>

    /**
     * Create many Fairs.
     *     @param {fairCreateManyArgs} args - Arguments to create many Fairs.
     *     @example
     *     // Create many Fairs
     *     const fair = await prisma.fair.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends fairCreateManyArgs>(
      args?: SelectSubset<T, fairCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Fair.
     * @param {fairDeleteArgs} args - Arguments to delete one Fair.
     * @example
     * // Delete one Fair
     * const Fair = await prisma.fair.delete({
     *   where: {
     *     // ... filter to delete one Fair
     *   }
     * })
     * 
    **/
    delete<T extends fairDeleteArgs>(
      args: SelectSubset<T, fairDeleteArgs>
    ): Prisma__fairClient<fairGetPayload<T>>

    /**
     * Update one Fair.
     * @param {fairUpdateArgs} args - Arguments to update one Fair.
     * @example
     * // Update one Fair
     * const fair = await prisma.fair.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends fairUpdateArgs>(
      args: SelectSubset<T, fairUpdateArgs>
    ): Prisma__fairClient<fairGetPayload<T>>

    /**
     * Delete zero or more Fairs.
     * @param {fairDeleteManyArgs} args - Arguments to filter Fairs to delete.
     * @example
     * // Delete a few Fairs
     * const { count } = await prisma.fair.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends fairDeleteManyArgs>(
      args?: SelectSubset<T, fairDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fairUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fairs
     * const fair = await prisma.fair.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends fairUpdateManyArgs>(
      args: SelectSubset<T, fairUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fair.
     * @param {fairUpsertArgs} args - Arguments to update or create a Fair.
     * @example
     * // Update or create a Fair
     * const fair = await prisma.fair.upsert({
     *   create: {
     *     // ... data to create a Fair
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fair we want to update
     *   }
     * })
    **/
    upsert<T extends fairUpsertArgs>(
      args: SelectSubset<T, fairUpsertArgs>
    ): Prisma__fairClient<fairGetPayload<T>>

    /**
     * Count the number of Fairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fairCountArgs} args - Arguments to filter Fairs to count.
     * @example
     * // Count the number of Fairs
     * const count = await prisma.fair.count({
     *   where: {
     *     // ... the filter for the Fairs we want to count
     *   }
     * })
    **/
    count<T extends fairCountArgs>(
      args?: Subset<T, fairCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FairCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FairAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FairAggregateArgs>(args: Subset<T, FairAggregateArgs>): Prisma.PrismaPromise<GetFairAggregateType<T>>

    /**
     * Group by Fair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FairGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FairGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FairGroupByArgs['orderBy'] }
        : { orderBy?: FairGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FairGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFairGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for fair.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__fairClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    address<T extends addressArgs= {}>(args?: Subset<T, addressArgs>): Prisma__addressClient<addressGetPayload<T> | Null>;

    location<T extends locationArgs= {}>(args?: Subset<T, locationArgs>): Prisma__locationClient<locationGetPayload<T> | Null>;

    fair_date_hour_of_work<T extends fair$fair_date_hour_of_workArgs= {}>(args?: Subset<T, fair$fair_date_hour_of_workArgs>): Prisma.PrismaPromise<Array<fair_date_hour_of_workGetPayload<T>>| Null>;

    fair_marketers<T extends fair$fair_marketersArgs= {}>(args?: Subset<T, fair$fair_marketersArgs>): Prisma.PrismaPromise<Array<fair_marketersGetPayload<T>>| Null>;

    image<T extends fair$imageArgs= {}>(args?: Subset<T, fair$imageArgs>): Prisma.PrismaPromise<Array<imageGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * fair base type for findUnique actions
   */
  export type fairFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the fair
     */
    select?: fairSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fairInclude | null
    /**
     * Filter, which fair to fetch.
     */
    where: fairWhereUniqueInput
  }

  /**
   * fair findUnique
   */
  export interface fairFindUniqueArgs extends fairFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fair findUniqueOrThrow
   */
  export type fairFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the fair
     */
    select?: fairSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fairInclude | null
    /**
     * Filter, which fair to fetch.
     */
    where: fairWhereUniqueInput
  }


  /**
   * fair base type for findFirst actions
   */
  export type fairFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the fair
     */
    select?: fairSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fairInclude | null
    /**
     * Filter, which fair to fetch.
     */
    where?: fairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fairs to fetch.
     */
    orderBy?: Enumerable<fairOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fairs.
     */
    cursor?: fairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fairs.
     */
    distinct?: Enumerable<FairScalarFieldEnum>
  }

  /**
   * fair findFirst
   */
  export interface fairFindFirstArgs extends fairFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fair findFirstOrThrow
   */
  export type fairFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the fair
     */
    select?: fairSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fairInclude | null
    /**
     * Filter, which fair to fetch.
     */
    where?: fairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fairs to fetch.
     */
    orderBy?: Enumerable<fairOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fairs.
     */
    cursor?: fairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fairs.
     */
    distinct?: Enumerable<FairScalarFieldEnum>
  }


  /**
   * fair findMany
   */
  export type fairFindManyArgs = {
    /**
     * Select specific fields to fetch from the fair
     */
    select?: fairSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fairInclude | null
    /**
     * Filter, which fairs to fetch.
     */
    where?: fairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fairs to fetch.
     */
    orderBy?: Enumerable<fairOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fairs.
     */
    cursor?: fairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fairs.
     */
    skip?: number
    distinct?: Enumerable<FairScalarFieldEnum>
  }


  /**
   * fair create
   */
  export type fairCreateArgs = {
    /**
     * Select specific fields to fetch from the fair
     */
    select?: fairSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fairInclude | null
    /**
     * The data needed to create a fair.
     */
    data: XOR<fairCreateInput, fairUncheckedCreateInput>
  }


  /**
   * fair createMany
   */
  export type fairCreateManyArgs = {
    /**
     * The data used to create many fairs.
     */
    data: Enumerable<fairCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * fair update
   */
  export type fairUpdateArgs = {
    /**
     * Select specific fields to fetch from the fair
     */
    select?: fairSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fairInclude | null
    /**
     * The data needed to update a fair.
     */
    data: XOR<fairUpdateInput, fairUncheckedUpdateInput>
    /**
     * Choose, which fair to update.
     */
    where: fairWhereUniqueInput
  }


  /**
   * fair updateMany
   */
  export type fairUpdateManyArgs = {
    /**
     * The data used to update fairs.
     */
    data: XOR<fairUpdateManyMutationInput, fairUncheckedUpdateManyInput>
    /**
     * Filter which fairs to update
     */
    where?: fairWhereInput
  }


  /**
   * fair upsert
   */
  export type fairUpsertArgs = {
    /**
     * Select specific fields to fetch from the fair
     */
    select?: fairSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fairInclude | null
    /**
     * The filter to search for the fair to update in case it exists.
     */
    where: fairWhereUniqueInput
    /**
     * In case the fair found by the `where` argument doesn't exist, create a new fair with this data.
     */
    create: XOR<fairCreateInput, fairUncheckedCreateInput>
    /**
     * In case the fair was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fairUpdateInput, fairUncheckedUpdateInput>
  }


  /**
   * fair delete
   */
  export type fairDeleteArgs = {
    /**
     * Select specific fields to fetch from the fair
     */
    select?: fairSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fairInclude | null
    /**
     * Filter which fair to delete.
     */
    where: fairWhereUniqueInput
  }


  /**
   * fair deleteMany
   */
  export type fairDeleteManyArgs = {
    /**
     * Filter which fairs to delete
     */
    where?: fairWhereInput
  }


  /**
   * fair.fair_date_hour_of_work
   */
  export type fair$fair_date_hour_of_workArgs = {
    /**
     * Select specific fields to fetch from the fair_date_hour_of_work
     */
    select?: fair_date_hour_of_workSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fair_date_hour_of_workInclude | null
    where?: fair_date_hour_of_workWhereInput
    orderBy?: Enumerable<fair_date_hour_of_workOrderByWithRelationInput>
    cursor?: fair_date_hour_of_workWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Fair_date_hour_of_workScalarFieldEnum>
  }


  /**
   * fair.fair_marketers
   */
  export type fair$fair_marketersArgs = {
    /**
     * Select specific fields to fetch from the fair_marketers
     */
    select?: fair_marketersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fair_marketersInclude | null
    where?: fair_marketersWhereInput
    orderBy?: Enumerable<fair_marketersOrderByWithRelationInput>
    cursor?: fair_marketersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Fair_marketersScalarFieldEnum>
  }


  /**
   * fair.image
   */
  export type fair$imageArgs = {
    /**
     * Select specific fields to fetch from the image
     */
    select?: imageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imageInclude | null
    where?: imageWhereInput
    orderBy?: Enumerable<imageOrderByWithRelationInput>
    cursor?: imageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ImageScalarFieldEnum>
  }


  /**
   * fair without action
   */
  export type fairArgs = {
    /**
     * Select specific fields to fetch from the fair
     */
    select?: fairSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fairInclude | null
  }



  /**
   * Model fair_marketers
   */


  export type AggregateFair_marketers = {
    _count: Fair_marketersCountAggregateOutputType | null
    _avg: Fair_marketersAvgAggregateOutputType | null
    _sum: Fair_marketersSumAggregateOutputType | null
    _min: Fair_marketersMinAggregateOutputType | null
    _max: Fair_marketersMaxAggregateOutputType | null
  }

  export type Fair_marketersAvgAggregateOutputType = {
    id: number | null
    fairId: number | null
    marketerId: number | null
  }

  export type Fair_marketersSumAggregateOutputType = {
    id: number | null
    fairId: number | null
    marketerId: number | null
  }

  export type Fair_marketersMinAggregateOutputType = {
    id: number | null
    fairId: number | null
    marketerId: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Fair_marketersMaxAggregateOutputType = {
    id: number | null
    fairId: number | null
    marketerId: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Fair_marketersCountAggregateOutputType = {
    id: number
    fairId: number
    marketerId: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Fair_marketersAvgAggregateInputType = {
    id?: true
    fairId?: true
    marketerId?: true
  }

  export type Fair_marketersSumAggregateInputType = {
    id?: true
    fairId?: true
    marketerId?: true
  }

  export type Fair_marketersMinAggregateInputType = {
    id?: true
    fairId?: true
    marketerId?: true
    created_at?: true
    updated_at?: true
  }

  export type Fair_marketersMaxAggregateInputType = {
    id?: true
    fairId?: true
    marketerId?: true
    created_at?: true
    updated_at?: true
  }

  export type Fair_marketersCountAggregateInputType = {
    id?: true
    fairId?: true
    marketerId?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Fair_marketersAggregateArgs = {
    /**
     * Filter which fair_marketers to aggregate.
     */
    where?: fair_marketersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fair_marketers to fetch.
     */
    orderBy?: Enumerable<fair_marketersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fair_marketersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fair_marketers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fair_marketers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fair_marketers
    **/
    _count?: true | Fair_marketersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Fair_marketersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Fair_marketersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Fair_marketersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Fair_marketersMaxAggregateInputType
  }

  export type GetFair_marketersAggregateType<T extends Fair_marketersAggregateArgs> = {
        [P in keyof T & keyof AggregateFair_marketers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFair_marketers[P]>
      : GetScalarType<T[P], AggregateFair_marketers[P]>
  }




  export type Fair_marketersGroupByArgs = {
    where?: fair_marketersWhereInput
    orderBy?: Enumerable<fair_marketersOrderByWithAggregationInput>
    by: Fair_marketersScalarFieldEnum[]
    having?: fair_marketersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Fair_marketersCountAggregateInputType | true
    _avg?: Fair_marketersAvgAggregateInputType
    _sum?: Fair_marketersSumAggregateInputType
    _min?: Fair_marketersMinAggregateInputType
    _max?: Fair_marketersMaxAggregateInputType
  }


  export type Fair_marketersGroupByOutputType = {
    id: number
    fairId: number
    marketerId: number
    created_at: Date
    updated_at: Date
    _count: Fair_marketersCountAggregateOutputType | null
    _avg: Fair_marketersAvgAggregateOutputType | null
    _sum: Fair_marketersSumAggregateOutputType | null
    _min: Fair_marketersMinAggregateOutputType | null
    _max: Fair_marketersMaxAggregateOutputType | null
  }

  type GetFair_marketersGroupByPayload<T extends Fair_marketersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Fair_marketersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Fair_marketersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Fair_marketersGroupByOutputType[P]>
            : GetScalarType<T[P], Fair_marketersGroupByOutputType[P]>
        }
      >
    >


  export type fair_marketersSelect = {
    id?: boolean
    fairId?: boolean
    marketerId?: boolean
    created_at?: boolean
    updated_at?: boolean
    fair?: boolean | fairArgs
    marketer?: boolean | marketerArgs
  }


  export type fair_marketersInclude = {
    fair?: boolean | fairArgs
    marketer?: boolean | marketerArgs
  }

  export type fair_marketersGetPayload<S extends boolean | null | undefined | fair_marketersArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? fair_marketers :
    S extends undefined ? never :
    S extends { include: any } & (fair_marketersArgs | fair_marketersFindManyArgs)
    ? fair_marketers  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'fair' ? fairGetPayload<S['include'][P]> :
        P extends 'marketer' ? marketerGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (fair_marketersArgs | fair_marketersFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'fair' ? fairGetPayload<S['select'][P]> :
        P extends 'marketer' ? marketerGetPayload<S['select'][P]> :  P extends keyof fair_marketers ? fair_marketers[P] : never
  } 
      : fair_marketers


  type fair_marketersCountArgs = 
    Omit<fair_marketersFindManyArgs, 'select' | 'include'> & {
      select?: Fair_marketersCountAggregateInputType | true
    }

  export interface fair_marketersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Fair_marketers that matches the filter.
     * @param {fair_marketersFindUniqueArgs} args - Arguments to find a Fair_marketers
     * @example
     * // Get one Fair_marketers
     * const fair_marketers = await prisma.fair_marketers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends fair_marketersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, fair_marketersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'fair_marketers'> extends True ? Prisma__fair_marketersClient<fair_marketersGetPayload<T>> : Prisma__fair_marketersClient<fair_marketersGetPayload<T> | null, null>

    /**
     * Find one Fair_marketers that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {fair_marketersFindUniqueOrThrowArgs} args - Arguments to find a Fair_marketers
     * @example
     * // Get one Fair_marketers
     * const fair_marketers = await prisma.fair_marketers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends fair_marketersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, fair_marketersFindUniqueOrThrowArgs>
    ): Prisma__fair_marketersClient<fair_marketersGetPayload<T>>

    /**
     * Find the first Fair_marketers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fair_marketersFindFirstArgs} args - Arguments to find a Fair_marketers
     * @example
     * // Get one Fair_marketers
     * const fair_marketers = await prisma.fair_marketers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends fair_marketersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, fair_marketersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'fair_marketers'> extends True ? Prisma__fair_marketersClient<fair_marketersGetPayload<T>> : Prisma__fair_marketersClient<fair_marketersGetPayload<T> | null, null>

    /**
     * Find the first Fair_marketers that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fair_marketersFindFirstOrThrowArgs} args - Arguments to find a Fair_marketers
     * @example
     * // Get one Fair_marketers
     * const fair_marketers = await prisma.fair_marketers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends fair_marketersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, fair_marketersFindFirstOrThrowArgs>
    ): Prisma__fair_marketersClient<fair_marketersGetPayload<T>>

    /**
     * Find zero or more Fair_marketers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fair_marketersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fair_marketers
     * const fair_marketers = await prisma.fair_marketers.findMany()
     * 
     * // Get first 10 Fair_marketers
     * const fair_marketers = await prisma.fair_marketers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fair_marketersWithIdOnly = await prisma.fair_marketers.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends fair_marketersFindManyArgs>(
      args?: SelectSubset<T, fair_marketersFindManyArgs>
    ): Prisma.PrismaPromise<Array<fair_marketersGetPayload<T>>>

    /**
     * Create a Fair_marketers.
     * @param {fair_marketersCreateArgs} args - Arguments to create a Fair_marketers.
     * @example
     * // Create one Fair_marketers
     * const Fair_marketers = await prisma.fair_marketers.create({
     *   data: {
     *     // ... data to create a Fair_marketers
     *   }
     * })
     * 
    **/
    create<T extends fair_marketersCreateArgs>(
      args: SelectSubset<T, fair_marketersCreateArgs>
    ): Prisma__fair_marketersClient<fair_marketersGetPayload<T>>

    /**
     * Create many Fair_marketers.
     *     @param {fair_marketersCreateManyArgs} args - Arguments to create many Fair_marketers.
     *     @example
     *     // Create many Fair_marketers
     *     const fair_marketers = await prisma.fair_marketers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends fair_marketersCreateManyArgs>(
      args?: SelectSubset<T, fair_marketersCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Fair_marketers.
     * @param {fair_marketersDeleteArgs} args - Arguments to delete one Fair_marketers.
     * @example
     * // Delete one Fair_marketers
     * const Fair_marketers = await prisma.fair_marketers.delete({
     *   where: {
     *     // ... filter to delete one Fair_marketers
     *   }
     * })
     * 
    **/
    delete<T extends fair_marketersDeleteArgs>(
      args: SelectSubset<T, fair_marketersDeleteArgs>
    ): Prisma__fair_marketersClient<fair_marketersGetPayload<T>>

    /**
     * Update one Fair_marketers.
     * @param {fair_marketersUpdateArgs} args - Arguments to update one Fair_marketers.
     * @example
     * // Update one Fair_marketers
     * const fair_marketers = await prisma.fair_marketers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends fair_marketersUpdateArgs>(
      args: SelectSubset<T, fair_marketersUpdateArgs>
    ): Prisma__fair_marketersClient<fair_marketersGetPayload<T>>

    /**
     * Delete zero or more Fair_marketers.
     * @param {fair_marketersDeleteManyArgs} args - Arguments to filter Fair_marketers to delete.
     * @example
     * // Delete a few Fair_marketers
     * const { count } = await prisma.fair_marketers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends fair_marketersDeleteManyArgs>(
      args?: SelectSubset<T, fair_marketersDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fair_marketers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fair_marketersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fair_marketers
     * const fair_marketers = await prisma.fair_marketers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends fair_marketersUpdateManyArgs>(
      args: SelectSubset<T, fair_marketersUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fair_marketers.
     * @param {fair_marketersUpsertArgs} args - Arguments to update or create a Fair_marketers.
     * @example
     * // Update or create a Fair_marketers
     * const fair_marketers = await prisma.fair_marketers.upsert({
     *   create: {
     *     // ... data to create a Fair_marketers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fair_marketers we want to update
     *   }
     * })
    **/
    upsert<T extends fair_marketersUpsertArgs>(
      args: SelectSubset<T, fair_marketersUpsertArgs>
    ): Prisma__fair_marketersClient<fair_marketersGetPayload<T>>

    /**
     * Count the number of Fair_marketers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fair_marketersCountArgs} args - Arguments to filter Fair_marketers to count.
     * @example
     * // Count the number of Fair_marketers
     * const count = await prisma.fair_marketers.count({
     *   where: {
     *     // ... the filter for the Fair_marketers we want to count
     *   }
     * })
    **/
    count<T extends fair_marketersCountArgs>(
      args?: Subset<T, fair_marketersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Fair_marketersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fair_marketers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fair_marketersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Fair_marketersAggregateArgs>(args: Subset<T, Fair_marketersAggregateArgs>): Prisma.PrismaPromise<GetFair_marketersAggregateType<T>>

    /**
     * Group by Fair_marketers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fair_marketersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Fair_marketersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Fair_marketersGroupByArgs['orderBy'] }
        : { orderBy?: Fair_marketersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Fair_marketersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFair_marketersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for fair_marketers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__fair_marketersClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    fair<T extends fairArgs= {}>(args?: Subset<T, fairArgs>): Prisma__fairClient<fairGetPayload<T> | Null>;

    marketer<T extends marketerArgs= {}>(args?: Subset<T, marketerArgs>): Prisma__marketerClient<marketerGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * fair_marketers base type for findUnique actions
   */
  export type fair_marketersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the fair_marketers
     */
    select?: fair_marketersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fair_marketersInclude | null
    /**
     * Filter, which fair_marketers to fetch.
     */
    where: fair_marketersWhereUniqueInput
  }

  /**
   * fair_marketers findUnique
   */
  export interface fair_marketersFindUniqueArgs extends fair_marketersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fair_marketers findUniqueOrThrow
   */
  export type fair_marketersFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the fair_marketers
     */
    select?: fair_marketersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fair_marketersInclude | null
    /**
     * Filter, which fair_marketers to fetch.
     */
    where: fair_marketersWhereUniqueInput
  }


  /**
   * fair_marketers base type for findFirst actions
   */
  export type fair_marketersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the fair_marketers
     */
    select?: fair_marketersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fair_marketersInclude | null
    /**
     * Filter, which fair_marketers to fetch.
     */
    where?: fair_marketersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fair_marketers to fetch.
     */
    orderBy?: Enumerable<fair_marketersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fair_marketers.
     */
    cursor?: fair_marketersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fair_marketers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fair_marketers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fair_marketers.
     */
    distinct?: Enumerable<Fair_marketersScalarFieldEnum>
  }

  /**
   * fair_marketers findFirst
   */
  export interface fair_marketersFindFirstArgs extends fair_marketersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fair_marketers findFirstOrThrow
   */
  export type fair_marketersFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the fair_marketers
     */
    select?: fair_marketersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fair_marketersInclude | null
    /**
     * Filter, which fair_marketers to fetch.
     */
    where?: fair_marketersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fair_marketers to fetch.
     */
    orderBy?: Enumerable<fair_marketersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fair_marketers.
     */
    cursor?: fair_marketersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fair_marketers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fair_marketers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fair_marketers.
     */
    distinct?: Enumerable<Fair_marketersScalarFieldEnum>
  }


  /**
   * fair_marketers findMany
   */
  export type fair_marketersFindManyArgs = {
    /**
     * Select specific fields to fetch from the fair_marketers
     */
    select?: fair_marketersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fair_marketersInclude | null
    /**
     * Filter, which fair_marketers to fetch.
     */
    where?: fair_marketersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fair_marketers to fetch.
     */
    orderBy?: Enumerable<fair_marketersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fair_marketers.
     */
    cursor?: fair_marketersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fair_marketers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fair_marketers.
     */
    skip?: number
    distinct?: Enumerable<Fair_marketersScalarFieldEnum>
  }


  /**
   * fair_marketers create
   */
  export type fair_marketersCreateArgs = {
    /**
     * Select specific fields to fetch from the fair_marketers
     */
    select?: fair_marketersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fair_marketersInclude | null
    /**
     * The data needed to create a fair_marketers.
     */
    data: XOR<fair_marketersCreateInput, fair_marketersUncheckedCreateInput>
  }


  /**
   * fair_marketers createMany
   */
  export type fair_marketersCreateManyArgs = {
    /**
     * The data used to create many fair_marketers.
     */
    data: Enumerable<fair_marketersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * fair_marketers update
   */
  export type fair_marketersUpdateArgs = {
    /**
     * Select specific fields to fetch from the fair_marketers
     */
    select?: fair_marketersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fair_marketersInclude | null
    /**
     * The data needed to update a fair_marketers.
     */
    data: XOR<fair_marketersUpdateInput, fair_marketersUncheckedUpdateInput>
    /**
     * Choose, which fair_marketers to update.
     */
    where: fair_marketersWhereUniqueInput
  }


  /**
   * fair_marketers updateMany
   */
  export type fair_marketersUpdateManyArgs = {
    /**
     * The data used to update fair_marketers.
     */
    data: XOR<fair_marketersUpdateManyMutationInput, fair_marketersUncheckedUpdateManyInput>
    /**
     * Filter which fair_marketers to update
     */
    where?: fair_marketersWhereInput
  }


  /**
   * fair_marketers upsert
   */
  export type fair_marketersUpsertArgs = {
    /**
     * Select specific fields to fetch from the fair_marketers
     */
    select?: fair_marketersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fair_marketersInclude | null
    /**
     * The filter to search for the fair_marketers to update in case it exists.
     */
    where: fair_marketersWhereUniqueInput
    /**
     * In case the fair_marketers found by the `where` argument doesn't exist, create a new fair_marketers with this data.
     */
    create: XOR<fair_marketersCreateInput, fair_marketersUncheckedCreateInput>
    /**
     * In case the fair_marketers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fair_marketersUpdateInput, fair_marketersUncheckedUpdateInput>
  }


  /**
   * fair_marketers delete
   */
  export type fair_marketersDeleteArgs = {
    /**
     * Select specific fields to fetch from the fair_marketers
     */
    select?: fair_marketersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fair_marketersInclude | null
    /**
     * Filter which fair_marketers to delete.
     */
    where: fair_marketersWhereUniqueInput
  }


  /**
   * fair_marketers deleteMany
   */
  export type fair_marketersDeleteManyArgs = {
    /**
     * Filter which fair_marketers to delete
     */
    where?: fair_marketersWhereInput
  }


  /**
   * fair_marketers without action
   */
  export type fair_marketersArgs = {
    /**
     * Select specific fields to fetch from the fair_marketers
     */
    select?: fair_marketersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fair_marketersInclude | null
  }



  /**
   * Model costumer_addresses
   */


  export type AggregateCostumer_addresses = {
    _count: Costumer_addressesCountAggregateOutputType | null
    _avg: Costumer_addressesAvgAggregateOutputType | null
    _sum: Costumer_addressesSumAggregateOutputType | null
    _min: Costumer_addressesMinAggregateOutputType | null
    _max: Costumer_addressesMaxAggregateOutputType | null
  }

  export type Costumer_addressesAvgAggregateOutputType = {
    id: number | null
    addressId: number | null
    costumerId: number | null
  }

  export type Costumer_addressesSumAggregateOutputType = {
    id: number | null
    addressId: number | null
    costumerId: number | null
  }

  export type Costumer_addressesMinAggregateOutputType = {
    id: number | null
    addressId: number | null
    costumerId: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Costumer_addressesMaxAggregateOutputType = {
    id: number | null
    addressId: number | null
    costumerId: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Costumer_addressesCountAggregateOutputType = {
    id: number
    addressId: number
    costumerId: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Costumer_addressesAvgAggregateInputType = {
    id?: true
    addressId?: true
    costumerId?: true
  }

  export type Costumer_addressesSumAggregateInputType = {
    id?: true
    addressId?: true
    costumerId?: true
  }

  export type Costumer_addressesMinAggregateInputType = {
    id?: true
    addressId?: true
    costumerId?: true
    created_at?: true
    updated_at?: true
  }

  export type Costumer_addressesMaxAggregateInputType = {
    id?: true
    addressId?: true
    costumerId?: true
    created_at?: true
    updated_at?: true
  }

  export type Costumer_addressesCountAggregateInputType = {
    id?: true
    addressId?: true
    costumerId?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Costumer_addressesAggregateArgs = {
    /**
     * Filter which costumer_addresses to aggregate.
     */
    where?: costumer_addressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of costumer_addresses to fetch.
     */
    orderBy?: Enumerable<costumer_addressesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: costumer_addressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` costumer_addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` costumer_addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned costumer_addresses
    **/
    _count?: true | Costumer_addressesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Costumer_addressesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Costumer_addressesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Costumer_addressesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Costumer_addressesMaxAggregateInputType
  }

  export type GetCostumer_addressesAggregateType<T extends Costumer_addressesAggregateArgs> = {
        [P in keyof T & keyof AggregateCostumer_addresses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCostumer_addresses[P]>
      : GetScalarType<T[P], AggregateCostumer_addresses[P]>
  }




  export type Costumer_addressesGroupByArgs = {
    where?: costumer_addressesWhereInput
    orderBy?: Enumerable<costumer_addressesOrderByWithAggregationInput>
    by: Costumer_addressesScalarFieldEnum[]
    having?: costumer_addressesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Costumer_addressesCountAggregateInputType | true
    _avg?: Costumer_addressesAvgAggregateInputType
    _sum?: Costumer_addressesSumAggregateInputType
    _min?: Costumer_addressesMinAggregateInputType
    _max?: Costumer_addressesMaxAggregateInputType
  }


  export type Costumer_addressesGroupByOutputType = {
    id: number
    addressId: number
    costumerId: number
    created_at: Date
    updated_at: Date
    _count: Costumer_addressesCountAggregateOutputType | null
    _avg: Costumer_addressesAvgAggregateOutputType | null
    _sum: Costumer_addressesSumAggregateOutputType | null
    _min: Costumer_addressesMinAggregateOutputType | null
    _max: Costumer_addressesMaxAggregateOutputType | null
  }

  type GetCostumer_addressesGroupByPayload<T extends Costumer_addressesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Costumer_addressesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Costumer_addressesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Costumer_addressesGroupByOutputType[P]>
            : GetScalarType<T[P], Costumer_addressesGroupByOutputType[P]>
        }
      >
    >


  export type costumer_addressesSelect = {
    id?: boolean
    addressId?: boolean
    costumerId?: boolean
    created_at?: boolean
    updated_at?: boolean
    address?: boolean | addressArgs
    costumer?: boolean | costumerArgs
    order?: boolean | costumer_addresses$orderArgs
    _count?: boolean | Costumer_addressesCountOutputTypeArgs
  }


  export type costumer_addressesInclude = {
    address?: boolean | addressArgs
    costumer?: boolean | costumerArgs
    order?: boolean | costumer_addresses$orderArgs
    _count?: boolean | Costumer_addressesCountOutputTypeArgs
  }

  export type costumer_addressesGetPayload<S extends boolean | null | undefined | costumer_addressesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? costumer_addresses :
    S extends undefined ? never :
    S extends { include: any } & (costumer_addressesArgs | costumer_addressesFindManyArgs)
    ? costumer_addresses  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'address' ? addressGetPayload<S['include'][P]> :
        P extends 'costumer' ? costumerGetPayload<S['include'][P]> :
        P extends 'order' ? Array < orderGetPayload<S['include'][P]>>  :
        P extends '_count' ? Costumer_addressesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (costumer_addressesArgs | costumer_addressesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'address' ? addressGetPayload<S['select'][P]> :
        P extends 'costumer' ? costumerGetPayload<S['select'][P]> :
        P extends 'order' ? Array < orderGetPayload<S['select'][P]>>  :
        P extends '_count' ? Costumer_addressesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof costumer_addresses ? costumer_addresses[P] : never
  } 
      : costumer_addresses


  type costumer_addressesCountArgs = 
    Omit<costumer_addressesFindManyArgs, 'select' | 'include'> & {
      select?: Costumer_addressesCountAggregateInputType | true
    }

  export interface costumer_addressesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Costumer_addresses that matches the filter.
     * @param {costumer_addressesFindUniqueArgs} args - Arguments to find a Costumer_addresses
     * @example
     * // Get one Costumer_addresses
     * const costumer_addresses = await prisma.costumer_addresses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends costumer_addressesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, costumer_addressesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'costumer_addresses'> extends True ? Prisma__costumer_addressesClient<costumer_addressesGetPayload<T>> : Prisma__costumer_addressesClient<costumer_addressesGetPayload<T> | null, null>

    /**
     * Find one Costumer_addresses that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {costumer_addressesFindUniqueOrThrowArgs} args - Arguments to find a Costumer_addresses
     * @example
     * // Get one Costumer_addresses
     * const costumer_addresses = await prisma.costumer_addresses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends costumer_addressesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, costumer_addressesFindUniqueOrThrowArgs>
    ): Prisma__costumer_addressesClient<costumer_addressesGetPayload<T>>

    /**
     * Find the first Costumer_addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costumer_addressesFindFirstArgs} args - Arguments to find a Costumer_addresses
     * @example
     * // Get one Costumer_addresses
     * const costumer_addresses = await prisma.costumer_addresses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends costumer_addressesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, costumer_addressesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'costumer_addresses'> extends True ? Prisma__costumer_addressesClient<costumer_addressesGetPayload<T>> : Prisma__costumer_addressesClient<costumer_addressesGetPayload<T> | null, null>

    /**
     * Find the first Costumer_addresses that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costumer_addressesFindFirstOrThrowArgs} args - Arguments to find a Costumer_addresses
     * @example
     * // Get one Costumer_addresses
     * const costumer_addresses = await prisma.costumer_addresses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends costumer_addressesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, costumer_addressesFindFirstOrThrowArgs>
    ): Prisma__costumer_addressesClient<costumer_addressesGetPayload<T>>

    /**
     * Find zero or more Costumer_addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costumer_addressesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Costumer_addresses
     * const costumer_addresses = await prisma.costumer_addresses.findMany()
     * 
     * // Get first 10 Costumer_addresses
     * const costumer_addresses = await prisma.costumer_addresses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const costumer_addressesWithIdOnly = await prisma.costumer_addresses.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends costumer_addressesFindManyArgs>(
      args?: SelectSubset<T, costumer_addressesFindManyArgs>
    ): Prisma.PrismaPromise<Array<costumer_addressesGetPayload<T>>>

    /**
     * Create a Costumer_addresses.
     * @param {costumer_addressesCreateArgs} args - Arguments to create a Costumer_addresses.
     * @example
     * // Create one Costumer_addresses
     * const Costumer_addresses = await prisma.costumer_addresses.create({
     *   data: {
     *     // ... data to create a Costumer_addresses
     *   }
     * })
     * 
    **/
    create<T extends costumer_addressesCreateArgs>(
      args: SelectSubset<T, costumer_addressesCreateArgs>
    ): Prisma__costumer_addressesClient<costumer_addressesGetPayload<T>>

    /**
     * Create many Costumer_addresses.
     *     @param {costumer_addressesCreateManyArgs} args - Arguments to create many Costumer_addresses.
     *     @example
     *     // Create many Costumer_addresses
     *     const costumer_addresses = await prisma.costumer_addresses.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends costumer_addressesCreateManyArgs>(
      args?: SelectSubset<T, costumer_addressesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Costumer_addresses.
     * @param {costumer_addressesDeleteArgs} args - Arguments to delete one Costumer_addresses.
     * @example
     * // Delete one Costumer_addresses
     * const Costumer_addresses = await prisma.costumer_addresses.delete({
     *   where: {
     *     // ... filter to delete one Costumer_addresses
     *   }
     * })
     * 
    **/
    delete<T extends costumer_addressesDeleteArgs>(
      args: SelectSubset<T, costumer_addressesDeleteArgs>
    ): Prisma__costumer_addressesClient<costumer_addressesGetPayload<T>>

    /**
     * Update one Costumer_addresses.
     * @param {costumer_addressesUpdateArgs} args - Arguments to update one Costumer_addresses.
     * @example
     * // Update one Costumer_addresses
     * const costumer_addresses = await prisma.costumer_addresses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends costumer_addressesUpdateArgs>(
      args: SelectSubset<T, costumer_addressesUpdateArgs>
    ): Prisma__costumer_addressesClient<costumer_addressesGetPayload<T>>

    /**
     * Delete zero or more Costumer_addresses.
     * @param {costumer_addressesDeleteManyArgs} args - Arguments to filter Costumer_addresses to delete.
     * @example
     * // Delete a few Costumer_addresses
     * const { count } = await prisma.costumer_addresses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends costumer_addressesDeleteManyArgs>(
      args?: SelectSubset<T, costumer_addressesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Costumer_addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costumer_addressesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Costumer_addresses
     * const costumer_addresses = await prisma.costumer_addresses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends costumer_addressesUpdateManyArgs>(
      args: SelectSubset<T, costumer_addressesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Costumer_addresses.
     * @param {costumer_addressesUpsertArgs} args - Arguments to update or create a Costumer_addresses.
     * @example
     * // Update or create a Costumer_addresses
     * const costumer_addresses = await prisma.costumer_addresses.upsert({
     *   create: {
     *     // ... data to create a Costumer_addresses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Costumer_addresses we want to update
     *   }
     * })
    **/
    upsert<T extends costumer_addressesUpsertArgs>(
      args: SelectSubset<T, costumer_addressesUpsertArgs>
    ): Prisma__costumer_addressesClient<costumer_addressesGetPayload<T>>

    /**
     * Count the number of Costumer_addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costumer_addressesCountArgs} args - Arguments to filter Costumer_addresses to count.
     * @example
     * // Count the number of Costumer_addresses
     * const count = await prisma.costumer_addresses.count({
     *   where: {
     *     // ... the filter for the Costumer_addresses we want to count
     *   }
     * })
    **/
    count<T extends costumer_addressesCountArgs>(
      args?: Subset<T, costumer_addressesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Costumer_addressesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Costumer_addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Costumer_addressesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Costumer_addressesAggregateArgs>(args: Subset<T, Costumer_addressesAggregateArgs>): Prisma.PrismaPromise<GetCostumer_addressesAggregateType<T>>

    /**
     * Group by Costumer_addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Costumer_addressesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Costumer_addressesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Costumer_addressesGroupByArgs['orderBy'] }
        : { orderBy?: Costumer_addressesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Costumer_addressesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostumer_addressesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for costumer_addresses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__costumer_addressesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    address<T extends addressArgs= {}>(args?: Subset<T, addressArgs>): Prisma__addressClient<addressGetPayload<T> | Null>;

    costumer<T extends costumerArgs= {}>(args?: Subset<T, costumerArgs>): Prisma__costumerClient<costumerGetPayload<T> | Null>;

    order<T extends costumer_addresses$orderArgs= {}>(args?: Subset<T, costumer_addresses$orderArgs>): Prisma.PrismaPromise<Array<orderGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * costumer_addresses base type for findUnique actions
   */
  export type costumer_addressesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the costumer_addresses
     */
    select?: costumer_addressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: costumer_addressesInclude | null
    /**
     * Filter, which costumer_addresses to fetch.
     */
    where: costumer_addressesWhereUniqueInput
  }

  /**
   * costumer_addresses findUnique
   */
  export interface costumer_addressesFindUniqueArgs extends costumer_addressesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * costumer_addresses findUniqueOrThrow
   */
  export type costumer_addressesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the costumer_addresses
     */
    select?: costumer_addressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: costumer_addressesInclude | null
    /**
     * Filter, which costumer_addresses to fetch.
     */
    where: costumer_addressesWhereUniqueInput
  }


  /**
   * costumer_addresses base type for findFirst actions
   */
  export type costumer_addressesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the costumer_addresses
     */
    select?: costumer_addressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: costumer_addressesInclude | null
    /**
     * Filter, which costumer_addresses to fetch.
     */
    where?: costumer_addressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of costumer_addresses to fetch.
     */
    orderBy?: Enumerable<costumer_addressesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for costumer_addresses.
     */
    cursor?: costumer_addressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` costumer_addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` costumer_addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of costumer_addresses.
     */
    distinct?: Enumerable<Costumer_addressesScalarFieldEnum>
  }

  /**
   * costumer_addresses findFirst
   */
  export interface costumer_addressesFindFirstArgs extends costumer_addressesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * costumer_addresses findFirstOrThrow
   */
  export type costumer_addressesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the costumer_addresses
     */
    select?: costumer_addressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: costumer_addressesInclude | null
    /**
     * Filter, which costumer_addresses to fetch.
     */
    where?: costumer_addressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of costumer_addresses to fetch.
     */
    orderBy?: Enumerable<costumer_addressesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for costumer_addresses.
     */
    cursor?: costumer_addressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` costumer_addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` costumer_addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of costumer_addresses.
     */
    distinct?: Enumerable<Costumer_addressesScalarFieldEnum>
  }


  /**
   * costumer_addresses findMany
   */
  export type costumer_addressesFindManyArgs = {
    /**
     * Select specific fields to fetch from the costumer_addresses
     */
    select?: costumer_addressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: costumer_addressesInclude | null
    /**
     * Filter, which costumer_addresses to fetch.
     */
    where?: costumer_addressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of costumer_addresses to fetch.
     */
    orderBy?: Enumerable<costumer_addressesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing costumer_addresses.
     */
    cursor?: costumer_addressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` costumer_addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` costumer_addresses.
     */
    skip?: number
    distinct?: Enumerable<Costumer_addressesScalarFieldEnum>
  }


  /**
   * costumer_addresses create
   */
  export type costumer_addressesCreateArgs = {
    /**
     * Select specific fields to fetch from the costumer_addresses
     */
    select?: costumer_addressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: costumer_addressesInclude | null
    /**
     * The data needed to create a costumer_addresses.
     */
    data: XOR<costumer_addressesCreateInput, costumer_addressesUncheckedCreateInput>
  }


  /**
   * costumer_addresses createMany
   */
  export type costumer_addressesCreateManyArgs = {
    /**
     * The data used to create many costumer_addresses.
     */
    data: Enumerable<costumer_addressesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * costumer_addresses update
   */
  export type costumer_addressesUpdateArgs = {
    /**
     * Select specific fields to fetch from the costumer_addresses
     */
    select?: costumer_addressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: costumer_addressesInclude | null
    /**
     * The data needed to update a costumer_addresses.
     */
    data: XOR<costumer_addressesUpdateInput, costumer_addressesUncheckedUpdateInput>
    /**
     * Choose, which costumer_addresses to update.
     */
    where: costumer_addressesWhereUniqueInput
  }


  /**
   * costumer_addresses updateMany
   */
  export type costumer_addressesUpdateManyArgs = {
    /**
     * The data used to update costumer_addresses.
     */
    data: XOR<costumer_addressesUpdateManyMutationInput, costumer_addressesUncheckedUpdateManyInput>
    /**
     * Filter which costumer_addresses to update
     */
    where?: costumer_addressesWhereInput
  }


  /**
   * costumer_addresses upsert
   */
  export type costumer_addressesUpsertArgs = {
    /**
     * Select specific fields to fetch from the costumer_addresses
     */
    select?: costumer_addressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: costumer_addressesInclude | null
    /**
     * The filter to search for the costumer_addresses to update in case it exists.
     */
    where: costumer_addressesWhereUniqueInput
    /**
     * In case the costumer_addresses found by the `where` argument doesn't exist, create a new costumer_addresses with this data.
     */
    create: XOR<costumer_addressesCreateInput, costumer_addressesUncheckedCreateInput>
    /**
     * In case the costumer_addresses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<costumer_addressesUpdateInput, costumer_addressesUncheckedUpdateInput>
  }


  /**
   * costumer_addresses delete
   */
  export type costumer_addressesDeleteArgs = {
    /**
     * Select specific fields to fetch from the costumer_addresses
     */
    select?: costumer_addressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: costumer_addressesInclude | null
    /**
     * Filter which costumer_addresses to delete.
     */
    where: costumer_addressesWhereUniqueInput
  }


  /**
   * costumer_addresses deleteMany
   */
  export type costumer_addressesDeleteManyArgs = {
    /**
     * Filter which costumer_addresses to delete
     */
    where?: costumer_addressesWhereInput
  }


  /**
   * costumer_addresses.order
   */
  export type costumer_addresses$orderArgs = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude | null
    where?: orderWhereInput
    orderBy?: Enumerable<orderOrderByWithRelationInput>
    cursor?: orderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * costumer_addresses without action
   */
  export type costumer_addressesArgs = {
    /**
     * Select specific fields to fetch from the costumer_addresses
     */
    select?: costumer_addressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: costumer_addressesInclude | null
  }



  /**
   * Model location
   */


  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    id: number | null
    longitude: number | null
    latitude: number | null
  }

  export type LocationSumAggregateOutputType = {
    id: number | null
    longitude: number | null
    latitude: number | null
  }

  export type LocationMinAggregateOutputType = {
    id: number | null
    longitude: number | null
    latitude: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type LocationMaxAggregateOutputType = {
    id: number | null
    longitude: number | null
    latitude: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    longitude: number
    latitude: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    id?: true
    longitude?: true
    latitude?: true
  }

  export type LocationSumAggregateInputType = {
    id?: true
    longitude?: true
    latitude?: true
  }

  export type LocationMinAggregateInputType = {
    id?: true
    longitude?: true
    latitude?: true
    created_at?: true
    updated_at?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    longitude?: true
    latitude?: true
    created_at?: true
    updated_at?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    longitude?: true
    latitude?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type LocationAggregateArgs = {
    /**
     * Filter which location to aggregate.
     */
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: Enumerable<locationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs = {
    where?: locationWhereInput
    orderBy?: Enumerable<locationOrderByWithAggregationInput>
    by: LocationScalarFieldEnum[]
    having?: locationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }


  export type LocationGroupByOutputType = {
    id: number
    longitude: number
    latitude: number
    created_at: Date
    updated_at: Date
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type locationSelect = {
    id?: boolean
    longitude?: boolean
    latitude?: boolean
    created_at?: boolean
    updated_at?: boolean
    address?: boolean | location$addressArgs
    deliveryman?: boolean | deliverymanArgs
    fair?: boolean | location$fairArgs
    marketer?: boolean | marketerArgs
    _count?: boolean | LocationCountOutputTypeArgs
  }


  export type locationInclude = {
    address?: boolean | location$addressArgs
    deliveryman?: boolean | deliverymanArgs
    fair?: boolean | location$fairArgs
    marketer?: boolean | marketerArgs
    _count?: boolean | LocationCountOutputTypeArgs
  }

  export type locationGetPayload<S extends boolean | null | undefined | locationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? location :
    S extends undefined ? never :
    S extends { include: any } & (locationArgs | locationFindManyArgs)
    ? location  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'address' ? Array < addressGetPayload<S['include'][P]>>  :
        P extends 'deliveryman' ? deliverymanGetPayload<S['include'][P]> | null :
        P extends 'fair' ? Array < fairGetPayload<S['include'][P]>>  :
        P extends 'marketer' ? marketerGetPayload<S['include'][P]> | null :
        P extends '_count' ? LocationCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (locationArgs | locationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'address' ? Array < addressGetPayload<S['select'][P]>>  :
        P extends 'deliveryman' ? deliverymanGetPayload<S['select'][P]> | null :
        P extends 'fair' ? Array < fairGetPayload<S['select'][P]>>  :
        P extends 'marketer' ? marketerGetPayload<S['select'][P]> | null :
        P extends '_count' ? LocationCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof location ? location[P] : never
  } 
      : location


  type locationCountArgs = 
    Omit<locationFindManyArgs, 'select' | 'include'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface locationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Location that matches the filter.
     * @param {locationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends locationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, locationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'location'> extends True ? Prisma__locationClient<locationGetPayload<T>> : Prisma__locationClient<locationGetPayload<T> | null, null>

    /**
     * Find one Location that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {locationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends locationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, locationFindUniqueOrThrowArgs>
    ): Prisma__locationClient<locationGetPayload<T>>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends locationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, locationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'location'> extends True ? Prisma__locationClient<locationGetPayload<T>> : Prisma__locationClient<locationGetPayload<T> | null, null>

    /**
     * Find the first Location that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends locationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, locationFindFirstOrThrowArgs>
    ): Prisma__locationClient<locationGetPayload<T>>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends locationFindManyArgs>(
      args?: SelectSubset<T, locationFindManyArgs>
    ): Prisma.PrismaPromise<Array<locationGetPayload<T>>>

    /**
     * Create a Location.
     * @param {locationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
    **/
    create<T extends locationCreateArgs>(
      args: SelectSubset<T, locationCreateArgs>
    ): Prisma__locationClient<locationGetPayload<T>>

    /**
     * Create many Locations.
     *     @param {locationCreateManyArgs} args - Arguments to create many Locations.
     *     @example
     *     // Create many Locations
     *     const location = await prisma.location.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends locationCreateManyArgs>(
      args?: SelectSubset<T, locationCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Location.
     * @param {locationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
    **/
    delete<T extends locationDeleteArgs>(
      args: SelectSubset<T, locationDeleteArgs>
    ): Prisma__locationClient<locationGetPayload<T>>

    /**
     * Update one Location.
     * @param {locationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends locationUpdateArgs>(
      args: SelectSubset<T, locationUpdateArgs>
    ): Prisma__locationClient<locationGetPayload<T>>

    /**
     * Delete zero or more Locations.
     * @param {locationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends locationDeleteManyArgs>(
      args?: SelectSubset<T, locationDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends locationUpdateManyArgs>(
      args: SelectSubset<T, locationUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Location.
     * @param {locationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
    **/
    upsert<T extends locationUpsertArgs>(
      args: SelectSubset<T, locationUpsertArgs>
    ): Prisma__locationClient<locationGetPayload<T>>

    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends locationCountArgs>(
      args?: Subset<T, locationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__locationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    address<T extends location$addressArgs= {}>(args?: Subset<T, location$addressArgs>): Prisma.PrismaPromise<Array<addressGetPayload<T>>| Null>;

    deliveryman<T extends deliverymanArgs= {}>(args?: Subset<T, deliverymanArgs>): Prisma__deliverymanClient<deliverymanGetPayload<T> | Null>;

    fair<T extends location$fairArgs= {}>(args?: Subset<T, location$fairArgs>): Prisma.PrismaPromise<Array<fairGetPayload<T>>| Null>;

    marketer<T extends marketerArgs= {}>(args?: Subset<T, marketerArgs>): Prisma__marketerClient<marketerGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * location base type for findUnique actions
   */
  export type locationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: locationInclude | null
    /**
     * Filter, which location to fetch.
     */
    where: locationWhereUniqueInput
  }

  /**
   * location findUnique
   */
  export interface locationFindUniqueArgs extends locationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * location findUniqueOrThrow
   */
  export type locationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: locationInclude | null
    /**
     * Filter, which location to fetch.
     */
    where: locationWhereUniqueInput
  }


  /**
   * location base type for findFirst actions
   */
  export type locationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: locationInclude | null
    /**
     * Filter, which location to fetch.
     */
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: Enumerable<locationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locations.
     */
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locations.
     */
    distinct?: Enumerable<LocationScalarFieldEnum>
  }

  /**
   * location findFirst
   */
  export interface locationFindFirstArgs extends locationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * location findFirstOrThrow
   */
  export type locationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: locationInclude | null
    /**
     * Filter, which location to fetch.
     */
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: Enumerable<locationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locations.
     */
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locations.
     */
    distinct?: Enumerable<LocationScalarFieldEnum>
  }


  /**
   * location findMany
   */
  export type locationFindManyArgs = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: locationInclude | null
    /**
     * Filter, which locations to fetch.
     */
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: Enumerable<locationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing locations.
     */
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    distinct?: Enumerable<LocationScalarFieldEnum>
  }


  /**
   * location create
   */
  export type locationCreateArgs = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: locationInclude | null
    /**
     * The data needed to create a location.
     */
    data: XOR<locationCreateInput, locationUncheckedCreateInput>
  }


  /**
   * location createMany
   */
  export type locationCreateManyArgs = {
    /**
     * The data used to create many locations.
     */
    data: Enumerable<locationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * location update
   */
  export type locationUpdateArgs = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: locationInclude | null
    /**
     * The data needed to update a location.
     */
    data: XOR<locationUpdateInput, locationUncheckedUpdateInput>
    /**
     * Choose, which location to update.
     */
    where: locationWhereUniqueInput
  }


  /**
   * location updateMany
   */
  export type locationUpdateManyArgs = {
    /**
     * The data used to update locations.
     */
    data: XOR<locationUpdateManyMutationInput, locationUncheckedUpdateManyInput>
    /**
     * Filter which locations to update
     */
    where?: locationWhereInput
  }


  /**
   * location upsert
   */
  export type locationUpsertArgs = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: locationInclude | null
    /**
     * The filter to search for the location to update in case it exists.
     */
    where: locationWhereUniqueInput
    /**
     * In case the location found by the `where` argument doesn't exist, create a new location with this data.
     */
    create: XOR<locationCreateInput, locationUncheckedCreateInput>
    /**
     * In case the location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<locationUpdateInput, locationUncheckedUpdateInput>
  }


  /**
   * location delete
   */
  export type locationDeleteArgs = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: locationInclude | null
    /**
     * Filter which location to delete.
     */
    where: locationWhereUniqueInput
  }


  /**
   * location deleteMany
   */
  export type locationDeleteManyArgs = {
    /**
     * Filter which locations to delete
     */
    where?: locationWhereInput
  }


  /**
   * location.address
   */
  export type location$addressArgs = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude | null
    where?: addressWhereInput
    orderBy?: Enumerable<addressOrderByWithRelationInput>
    cursor?: addressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * location.fair
   */
  export type location$fairArgs = {
    /**
     * Select specific fields to fetch from the fair
     */
    select?: fairSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fairInclude | null
    where?: fairWhereInput
    orderBy?: Enumerable<fairOrderByWithRelationInput>
    cursor?: fairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FairScalarFieldEnum>
  }


  /**
   * location without action
   */
  export type locationArgs = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: locationInclude | null
  }



  /**
   * Model address
   */


  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressAvgAggregateOutputType = {
    id: number | null
    number: number | null
    address_typeId: number | null
    cityId: number | null
    uFId: number | null
    neighborhoodId: number | null
    locationId: number | null
  }

  export type AddressSumAggregateOutputType = {
    id: number | null
    number: number | null
    address_typeId: number | null
    cityId: number | null
    uFId: number | null
    neighborhoodId: number | null
    locationId: number | null
  }

  export type AddressMinAggregateOutputType = {
    id: number | null
    cep: string | null
    logradouro: string | null
    number: number | null
    created_at: Date | null
    updated_at: Date | null
    address_typeId: number | null
    complemento: string | null
    cityId: number | null
    uFId: number | null
    neighborhoodId: number | null
    locationId: number | null
  }

  export type AddressMaxAggregateOutputType = {
    id: number | null
    cep: string | null
    logradouro: string | null
    number: number | null
    created_at: Date | null
    updated_at: Date | null
    address_typeId: number | null
    complemento: string | null
    cityId: number | null
    uFId: number | null
    neighborhoodId: number | null
    locationId: number | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    cep: number
    logradouro: number
    number: number
    created_at: number
    updated_at: number
    address_typeId: number
    complemento: number
    cityId: number
    uFId: number
    neighborhoodId: number
    locationId: number
    _all: number
  }


  export type AddressAvgAggregateInputType = {
    id?: true
    number?: true
    address_typeId?: true
    cityId?: true
    uFId?: true
    neighborhoodId?: true
    locationId?: true
  }

  export type AddressSumAggregateInputType = {
    id?: true
    number?: true
    address_typeId?: true
    cityId?: true
    uFId?: true
    neighborhoodId?: true
    locationId?: true
  }

  export type AddressMinAggregateInputType = {
    id?: true
    cep?: true
    logradouro?: true
    number?: true
    created_at?: true
    updated_at?: true
    address_typeId?: true
    complemento?: true
    cityId?: true
    uFId?: true
    neighborhoodId?: true
    locationId?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    cep?: true
    logradouro?: true
    number?: true
    created_at?: true
    updated_at?: true
    address_typeId?: true
    complemento?: true
    cityId?: true
    uFId?: true
    neighborhoodId?: true
    locationId?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    cep?: true
    logradouro?: true
    number?: true
    created_at?: true
    updated_at?: true
    address_typeId?: true
    complemento?: true
    cityId?: true
    uFId?: true
    neighborhoodId?: true
    locationId?: true
    _all?: true
  }

  export type AddressAggregateArgs = {
    /**
     * Filter which address to aggregate.
     */
    where?: addressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of addresses to fetch.
     */
    orderBy?: Enumerable<addressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: addressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs = {
    where?: addressWhereInput
    orderBy?: Enumerable<addressOrderByWithAggregationInput>
    by: AddressScalarFieldEnum[]
    having?: addressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _avg?: AddressAvgAggregateInputType
    _sum?: AddressSumAggregateInputType
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }


  export type AddressGroupByOutputType = {
    id: number
    cep: string
    logradouro: string
    number: number
    created_at: Date
    updated_at: Date
    address_typeId: number
    complemento: string
    cityId: number
    uFId: number
    neighborhoodId: number
    locationId: number
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type addressSelect = {
    id?: boolean
    cep?: boolean
    logradouro?: boolean
    number?: boolean
    created_at?: boolean
    updated_at?: boolean
    address_typeId?: boolean
    complemento?: boolean
    cityId?: boolean
    uFId?: boolean
    neighborhoodId?: boolean
    locationId?: boolean
    type?: boolean | address_typeArgs
    city?: boolean | cityArgs
    location?: boolean | locationArgs
    neighborhood?: boolean | neighborhoodArgs
    uf?: boolean | ufArgs
    costumer_addresses?: boolean | address$costumer_addressesArgs
    fair?: boolean | fairArgs
    _count?: boolean | AddressCountOutputTypeArgs
  }


  export type addressInclude = {
    type?: boolean | address_typeArgs
    city?: boolean | cityArgs
    location?: boolean | locationArgs
    neighborhood?: boolean | neighborhoodArgs
    uf?: boolean | ufArgs
    costumer_addresses?: boolean | address$costumer_addressesArgs
    fair?: boolean | fairArgs
    _count?: boolean | AddressCountOutputTypeArgs
  }

  export type addressGetPayload<S extends boolean | null | undefined | addressArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? address :
    S extends undefined ? never :
    S extends { include: any } & (addressArgs | addressFindManyArgs)
    ? address  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'type' ? address_typeGetPayload<S['include'][P]> :
        P extends 'city' ? cityGetPayload<S['include'][P]> :
        P extends 'location' ? locationGetPayload<S['include'][P]> :
        P extends 'neighborhood' ? neighborhoodGetPayload<S['include'][P]> :
        P extends 'uf' ? ufGetPayload<S['include'][P]> :
        P extends 'costumer_addresses' ? Array < costumer_addressesGetPayload<S['include'][P]>>  :
        P extends 'fair' ? fairGetPayload<S['include'][P]> | null :
        P extends '_count' ? AddressCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (addressArgs | addressFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'type' ? address_typeGetPayload<S['select'][P]> :
        P extends 'city' ? cityGetPayload<S['select'][P]> :
        P extends 'location' ? locationGetPayload<S['select'][P]> :
        P extends 'neighborhood' ? neighborhoodGetPayload<S['select'][P]> :
        P extends 'uf' ? ufGetPayload<S['select'][P]> :
        P extends 'costumer_addresses' ? Array < costumer_addressesGetPayload<S['select'][P]>>  :
        P extends 'fair' ? fairGetPayload<S['select'][P]> | null :
        P extends '_count' ? AddressCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof address ? address[P] : never
  } 
      : address


  type addressCountArgs = 
    Omit<addressFindManyArgs, 'select' | 'include'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface addressDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Address that matches the filter.
     * @param {addressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends addressFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, addressFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'address'> extends True ? Prisma__addressClient<addressGetPayload<T>> : Prisma__addressClient<addressGetPayload<T> | null, null>

    /**
     * Find one Address that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {addressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends addressFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, addressFindUniqueOrThrowArgs>
    ): Prisma__addressClient<addressGetPayload<T>>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {addressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends addressFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, addressFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'address'> extends True ? Prisma__addressClient<addressGetPayload<T>> : Prisma__addressClient<addressGetPayload<T> | null, null>

    /**
     * Find the first Address that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {addressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends addressFindFirstOrThrowArgs>(
      args?: SelectSubset<T, addressFindFirstOrThrowArgs>
    ): Prisma__addressClient<addressGetPayload<T>>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {addressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends addressFindManyArgs>(
      args?: SelectSubset<T, addressFindManyArgs>
    ): Prisma.PrismaPromise<Array<addressGetPayload<T>>>

    /**
     * Create a Address.
     * @param {addressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
    **/
    create<T extends addressCreateArgs>(
      args: SelectSubset<T, addressCreateArgs>
    ): Prisma__addressClient<addressGetPayload<T>>

    /**
     * Create many Addresses.
     *     @param {addressCreateManyArgs} args - Arguments to create many Addresses.
     *     @example
     *     // Create many Addresses
     *     const address = await prisma.address.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends addressCreateManyArgs>(
      args?: SelectSubset<T, addressCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Address.
     * @param {addressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
    **/
    delete<T extends addressDeleteArgs>(
      args: SelectSubset<T, addressDeleteArgs>
    ): Prisma__addressClient<addressGetPayload<T>>

    /**
     * Update one Address.
     * @param {addressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends addressUpdateArgs>(
      args: SelectSubset<T, addressUpdateArgs>
    ): Prisma__addressClient<addressGetPayload<T>>

    /**
     * Delete zero or more Addresses.
     * @param {addressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends addressDeleteManyArgs>(
      args?: SelectSubset<T, addressDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {addressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends addressUpdateManyArgs>(
      args: SelectSubset<T, addressUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Address.
     * @param {addressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
    **/
    upsert<T extends addressUpsertArgs>(
      args: SelectSubset<T, addressUpsertArgs>
    ): Prisma__addressClient<addressGetPayload<T>>

    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {addressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends addressCountArgs>(
      args?: Subset<T, addressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__addressClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    type<T extends address_typeArgs= {}>(args?: Subset<T, address_typeArgs>): Prisma__address_typeClient<address_typeGetPayload<T> | Null>;

    city<T extends cityArgs= {}>(args?: Subset<T, cityArgs>): Prisma__cityClient<cityGetPayload<T> | Null>;

    location<T extends locationArgs= {}>(args?: Subset<T, locationArgs>): Prisma__locationClient<locationGetPayload<T> | Null>;

    neighborhood<T extends neighborhoodArgs= {}>(args?: Subset<T, neighborhoodArgs>): Prisma__neighborhoodClient<neighborhoodGetPayload<T> | Null>;

    uf<T extends ufArgs= {}>(args?: Subset<T, ufArgs>): Prisma__ufClient<ufGetPayload<T> | Null>;

    costumer_addresses<T extends address$costumer_addressesArgs= {}>(args?: Subset<T, address$costumer_addressesArgs>): Prisma.PrismaPromise<Array<costumer_addressesGetPayload<T>>| Null>;

    fair<T extends fairArgs= {}>(args?: Subset<T, fairArgs>): Prisma__fairClient<fairGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * address base type for findUnique actions
   */
  export type addressFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude | null
    /**
     * Filter, which address to fetch.
     */
    where: addressWhereUniqueInput
  }

  /**
   * address findUnique
   */
  export interface addressFindUniqueArgs extends addressFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * address findUniqueOrThrow
   */
  export type addressFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude | null
    /**
     * Filter, which address to fetch.
     */
    where: addressWhereUniqueInput
  }


  /**
   * address base type for findFirst actions
   */
  export type addressFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude | null
    /**
     * Filter, which address to fetch.
     */
    where?: addressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of addresses to fetch.
     */
    orderBy?: Enumerable<addressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for addresses.
     */
    cursor?: addressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of addresses.
     */
    distinct?: Enumerable<AddressScalarFieldEnum>
  }

  /**
   * address findFirst
   */
  export interface addressFindFirstArgs extends addressFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * address findFirstOrThrow
   */
  export type addressFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude | null
    /**
     * Filter, which address to fetch.
     */
    where?: addressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of addresses to fetch.
     */
    orderBy?: Enumerable<addressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for addresses.
     */
    cursor?: addressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of addresses.
     */
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * address findMany
   */
  export type addressFindManyArgs = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude | null
    /**
     * Filter, which addresses to fetch.
     */
    where?: addressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of addresses to fetch.
     */
    orderBy?: Enumerable<addressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing addresses.
     */
    cursor?: addressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` addresses.
     */
    skip?: number
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * address create
   */
  export type addressCreateArgs = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude | null
    /**
     * The data needed to create a address.
     */
    data: XOR<addressCreateInput, addressUncheckedCreateInput>
  }


  /**
   * address createMany
   */
  export type addressCreateManyArgs = {
    /**
     * The data used to create many addresses.
     */
    data: Enumerable<addressCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * address update
   */
  export type addressUpdateArgs = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude | null
    /**
     * The data needed to update a address.
     */
    data: XOR<addressUpdateInput, addressUncheckedUpdateInput>
    /**
     * Choose, which address to update.
     */
    where: addressWhereUniqueInput
  }


  /**
   * address updateMany
   */
  export type addressUpdateManyArgs = {
    /**
     * The data used to update addresses.
     */
    data: XOR<addressUpdateManyMutationInput, addressUncheckedUpdateManyInput>
    /**
     * Filter which addresses to update
     */
    where?: addressWhereInput
  }


  /**
   * address upsert
   */
  export type addressUpsertArgs = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude | null
    /**
     * The filter to search for the address to update in case it exists.
     */
    where: addressWhereUniqueInput
    /**
     * In case the address found by the `where` argument doesn't exist, create a new address with this data.
     */
    create: XOR<addressCreateInput, addressUncheckedCreateInput>
    /**
     * In case the address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<addressUpdateInput, addressUncheckedUpdateInput>
  }


  /**
   * address delete
   */
  export type addressDeleteArgs = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude | null
    /**
     * Filter which address to delete.
     */
    where: addressWhereUniqueInput
  }


  /**
   * address deleteMany
   */
  export type addressDeleteManyArgs = {
    /**
     * Filter which addresses to delete
     */
    where?: addressWhereInput
  }


  /**
   * address.costumer_addresses
   */
  export type address$costumer_addressesArgs = {
    /**
     * Select specific fields to fetch from the costumer_addresses
     */
    select?: costumer_addressesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: costumer_addressesInclude | null
    where?: costumer_addressesWhereInput
    orderBy?: Enumerable<costumer_addressesOrderByWithRelationInput>
    cursor?: costumer_addressesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Costumer_addressesScalarFieldEnum>
  }


  /**
   * address without action
   */
  export type addressArgs = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude | null
  }



  /**
   * Model address_type
   */


  export type AggregateAddress_type = {
    _count: Address_typeCountAggregateOutputType | null
    _avg: Address_typeAvgAggregateOutputType | null
    _sum: Address_typeSumAggregateOutputType | null
    _min: Address_typeMinAggregateOutputType | null
    _max: Address_typeMaxAggregateOutputType | null
  }

  export type Address_typeAvgAggregateOutputType = {
    id: number | null
  }

  export type Address_typeSumAggregateOutputType = {
    id: number | null
  }

  export type Address_typeMinAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Address_typeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Address_typeCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Address_typeAvgAggregateInputType = {
    id?: true
  }

  export type Address_typeSumAggregateInputType = {
    id?: true
  }

  export type Address_typeMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type Address_typeMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type Address_typeCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Address_typeAggregateArgs = {
    /**
     * Filter which address_type to aggregate.
     */
    where?: address_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of address_types to fetch.
     */
    orderBy?: Enumerable<address_typeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: address_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` address_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` address_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned address_types
    **/
    _count?: true | Address_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Address_typeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Address_typeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Address_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Address_typeMaxAggregateInputType
  }

  export type GetAddress_typeAggregateType<T extends Address_typeAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress_type[P]>
      : GetScalarType<T[P], AggregateAddress_type[P]>
  }




  export type Address_typeGroupByArgs = {
    where?: address_typeWhereInput
    orderBy?: Enumerable<address_typeOrderByWithAggregationInput>
    by: Address_typeScalarFieldEnum[]
    having?: address_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Address_typeCountAggregateInputType | true
    _avg?: Address_typeAvgAggregateInputType
    _sum?: Address_typeSumAggregateInputType
    _min?: Address_typeMinAggregateInputType
    _max?: Address_typeMaxAggregateInputType
  }


  export type Address_typeGroupByOutputType = {
    id: number
    name: string
    created_at: Date
    updated_at: Date
    _count: Address_typeCountAggregateOutputType | null
    _avg: Address_typeAvgAggregateOutputType | null
    _sum: Address_typeSumAggregateOutputType | null
    _min: Address_typeMinAggregateOutputType | null
    _max: Address_typeMaxAggregateOutputType | null
  }

  type GetAddress_typeGroupByPayload<T extends Address_typeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Address_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Address_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Address_typeGroupByOutputType[P]>
            : GetScalarType<T[P], Address_typeGroupByOutputType[P]>
        }
      >
    >


  export type address_typeSelect = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    address?: boolean | address_type$addressArgs
    _count?: boolean | Address_typeCountOutputTypeArgs
  }


  export type address_typeInclude = {
    address?: boolean | address_type$addressArgs
    _count?: boolean | Address_typeCountOutputTypeArgs
  }

  export type address_typeGetPayload<S extends boolean | null | undefined | address_typeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? address_type :
    S extends undefined ? never :
    S extends { include: any } & (address_typeArgs | address_typeFindManyArgs)
    ? address_type  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'address' ? Array < addressGetPayload<S['include'][P]>>  :
        P extends '_count' ? Address_typeCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (address_typeArgs | address_typeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'address' ? Array < addressGetPayload<S['select'][P]>>  :
        P extends '_count' ? Address_typeCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof address_type ? address_type[P] : never
  } 
      : address_type


  type address_typeCountArgs = 
    Omit<address_typeFindManyArgs, 'select' | 'include'> & {
      select?: Address_typeCountAggregateInputType | true
    }

  export interface address_typeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Address_type that matches the filter.
     * @param {address_typeFindUniqueArgs} args - Arguments to find a Address_type
     * @example
     * // Get one Address_type
     * const address_type = await prisma.address_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends address_typeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, address_typeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'address_type'> extends True ? Prisma__address_typeClient<address_typeGetPayload<T>> : Prisma__address_typeClient<address_typeGetPayload<T> | null, null>

    /**
     * Find one Address_type that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {address_typeFindUniqueOrThrowArgs} args - Arguments to find a Address_type
     * @example
     * // Get one Address_type
     * const address_type = await prisma.address_type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends address_typeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, address_typeFindUniqueOrThrowArgs>
    ): Prisma__address_typeClient<address_typeGetPayload<T>>

    /**
     * Find the first Address_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {address_typeFindFirstArgs} args - Arguments to find a Address_type
     * @example
     * // Get one Address_type
     * const address_type = await prisma.address_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends address_typeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, address_typeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'address_type'> extends True ? Prisma__address_typeClient<address_typeGetPayload<T>> : Prisma__address_typeClient<address_typeGetPayload<T> | null, null>

    /**
     * Find the first Address_type that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {address_typeFindFirstOrThrowArgs} args - Arguments to find a Address_type
     * @example
     * // Get one Address_type
     * const address_type = await prisma.address_type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends address_typeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, address_typeFindFirstOrThrowArgs>
    ): Prisma__address_typeClient<address_typeGetPayload<T>>

    /**
     * Find zero or more Address_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {address_typeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Address_types
     * const address_types = await prisma.address_type.findMany()
     * 
     * // Get first 10 Address_types
     * const address_types = await prisma.address_type.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const address_typeWithIdOnly = await prisma.address_type.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends address_typeFindManyArgs>(
      args?: SelectSubset<T, address_typeFindManyArgs>
    ): Prisma.PrismaPromise<Array<address_typeGetPayload<T>>>

    /**
     * Create a Address_type.
     * @param {address_typeCreateArgs} args - Arguments to create a Address_type.
     * @example
     * // Create one Address_type
     * const Address_type = await prisma.address_type.create({
     *   data: {
     *     // ... data to create a Address_type
     *   }
     * })
     * 
    **/
    create<T extends address_typeCreateArgs>(
      args: SelectSubset<T, address_typeCreateArgs>
    ): Prisma__address_typeClient<address_typeGetPayload<T>>

    /**
     * Create many Address_types.
     *     @param {address_typeCreateManyArgs} args - Arguments to create many Address_types.
     *     @example
     *     // Create many Address_types
     *     const address_type = await prisma.address_type.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends address_typeCreateManyArgs>(
      args?: SelectSubset<T, address_typeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Address_type.
     * @param {address_typeDeleteArgs} args - Arguments to delete one Address_type.
     * @example
     * // Delete one Address_type
     * const Address_type = await prisma.address_type.delete({
     *   where: {
     *     // ... filter to delete one Address_type
     *   }
     * })
     * 
    **/
    delete<T extends address_typeDeleteArgs>(
      args: SelectSubset<T, address_typeDeleteArgs>
    ): Prisma__address_typeClient<address_typeGetPayload<T>>

    /**
     * Update one Address_type.
     * @param {address_typeUpdateArgs} args - Arguments to update one Address_type.
     * @example
     * // Update one Address_type
     * const address_type = await prisma.address_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends address_typeUpdateArgs>(
      args: SelectSubset<T, address_typeUpdateArgs>
    ): Prisma__address_typeClient<address_typeGetPayload<T>>

    /**
     * Delete zero or more Address_types.
     * @param {address_typeDeleteManyArgs} args - Arguments to filter Address_types to delete.
     * @example
     * // Delete a few Address_types
     * const { count } = await prisma.address_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends address_typeDeleteManyArgs>(
      args?: SelectSubset<T, address_typeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Address_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {address_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Address_types
     * const address_type = await prisma.address_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends address_typeUpdateManyArgs>(
      args: SelectSubset<T, address_typeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Address_type.
     * @param {address_typeUpsertArgs} args - Arguments to update or create a Address_type.
     * @example
     * // Update or create a Address_type
     * const address_type = await prisma.address_type.upsert({
     *   create: {
     *     // ... data to create a Address_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address_type we want to update
     *   }
     * })
    **/
    upsert<T extends address_typeUpsertArgs>(
      args: SelectSubset<T, address_typeUpsertArgs>
    ): Prisma__address_typeClient<address_typeGetPayload<T>>

    /**
     * Count the number of Address_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {address_typeCountArgs} args - Arguments to filter Address_types to count.
     * @example
     * // Count the number of Address_types
     * const count = await prisma.address_type.count({
     *   where: {
     *     // ... the filter for the Address_types we want to count
     *   }
     * })
    **/
    count<T extends address_typeCountArgs>(
      args?: Subset<T, address_typeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Address_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Address_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Address_typeAggregateArgs>(args: Subset<T, Address_typeAggregateArgs>): Prisma.PrismaPromise<GetAddress_typeAggregateType<T>>

    /**
     * Group by Address_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Address_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Address_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Address_typeGroupByArgs['orderBy'] }
        : { orderBy?: Address_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Address_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddress_typeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for address_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__address_typeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    address<T extends address_type$addressArgs= {}>(args?: Subset<T, address_type$addressArgs>): Prisma.PrismaPromise<Array<addressGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * address_type base type for findUnique actions
   */
  export type address_typeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the address_type
     */
    select?: address_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: address_typeInclude | null
    /**
     * Filter, which address_type to fetch.
     */
    where: address_typeWhereUniqueInput
  }

  /**
   * address_type findUnique
   */
  export interface address_typeFindUniqueArgs extends address_typeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * address_type findUniqueOrThrow
   */
  export type address_typeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the address_type
     */
    select?: address_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: address_typeInclude | null
    /**
     * Filter, which address_type to fetch.
     */
    where: address_typeWhereUniqueInput
  }


  /**
   * address_type base type for findFirst actions
   */
  export type address_typeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the address_type
     */
    select?: address_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: address_typeInclude | null
    /**
     * Filter, which address_type to fetch.
     */
    where?: address_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of address_types to fetch.
     */
    orderBy?: Enumerable<address_typeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for address_types.
     */
    cursor?: address_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` address_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` address_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of address_types.
     */
    distinct?: Enumerable<Address_typeScalarFieldEnum>
  }

  /**
   * address_type findFirst
   */
  export interface address_typeFindFirstArgs extends address_typeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * address_type findFirstOrThrow
   */
  export type address_typeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the address_type
     */
    select?: address_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: address_typeInclude | null
    /**
     * Filter, which address_type to fetch.
     */
    where?: address_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of address_types to fetch.
     */
    orderBy?: Enumerable<address_typeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for address_types.
     */
    cursor?: address_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` address_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` address_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of address_types.
     */
    distinct?: Enumerable<Address_typeScalarFieldEnum>
  }


  /**
   * address_type findMany
   */
  export type address_typeFindManyArgs = {
    /**
     * Select specific fields to fetch from the address_type
     */
    select?: address_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: address_typeInclude | null
    /**
     * Filter, which address_types to fetch.
     */
    where?: address_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of address_types to fetch.
     */
    orderBy?: Enumerable<address_typeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing address_types.
     */
    cursor?: address_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` address_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` address_types.
     */
    skip?: number
    distinct?: Enumerable<Address_typeScalarFieldEnum>
  }


  /**
   * address_type create
   */
  export type address_typeCreateArgs = {
    /**
     * Select specific fields to fetch from the address_type
     */
    select?: address_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: address_typeInclude | null
    /**
     * The data needed to create a address_type.
     */
    data: XOR<address_typeCreateInput, address_typeUncheckedCreateInput>
  }


  /**
   * address_type createMany
   */
  export type address_typeCreateManyArgs = {
    /**
     * The data used to create many address_types.
     */
    data: Enumerable<address_typeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * address_type update
   */
  export type address_typeUpdateArgs = {
    /**
     * Select specific fields to fetch from the address_type
     */
    select?: address_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: address_typeInclude | null
    /**
     * The data needed to update a address_type.
     */
    data: XOR<address_typeUpdateInput, address_typeUncheckedUpdateInput>
    /**
     * Choose, which address_type to update.
     */
    where: address_typeWhereUniqueInput
  }


  /**
   * address_type updateMany
   */
  export type address_typeUpdateManyArgs = {
    /**
     * The data used to update address_types.
     */
    data: XOR<address_typeUpdateManyMutationInput, address_typeUncheckedUpdateManyInput>
    /**
     * Filter which address_types to update
     */
    where?: address_typeWhereInput
  }


  /**
   * address_type upsert
   */
  export type address_typeUpsertArgs = {
    /**
     * Select specific fields to fetch from the address_type
     */
    select?: address_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: address_typeInclude | null
    /**
     * The filter to search for the address_type to update in case it exists.
     */
    where: address_typeWhereUniqueInput
    /**
     * In case the address_type found by the `where` argument doesn't exist, create a new address_type with this data.
     */
    create: XOR<address_typeCreateInput, address_typeUncheckedCreateInput>
    /**
     * In case the address_type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<address_typeUpdateInput, address_typeUncheckedUpdateInput>
  }


  /**
   * address_type delete
   */
  export type address_typeDeleteArgs = {
    /**
     * Select specific fields to fetch from the address_type
     */
    select?: address_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: address_typeInclude | null
    /**
     * Filter which address_type to delete.
     */
    where: address_typeWhereUniqueInput
  }


  /**
   * address_type deleteMany
   */
  export type address_typeDeleteManyArgs = {
    /**
     * Filter which address_types to delete
     */
    where?: address_typeWhereInput
  }


  /**
   * address_type.address
   */
  export type address_type$addressArgs = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude | null
    where?: addressWhereInput
    orderBy?: Enumerable<addressOrderByWithRelationInput>
    cursor?: addressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * address_type without action
   */
  export type address_typeArgs = {
    /**
     * Select specific fields to fetch from the address_type
     */
    select?: address_typeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: address_typeInclude | null
  }



  /**
   * Model veicule
   */


  export type AggregateVeicule = {
    _count: VeiculeCountAggregateOutputType | null
    _avg: VeiculeAvgAggregateOutputType | null
    _sum: VeiculeSumAggregateOutputType | null
    _min: VeiculeMinAggregateOutputType | null
    _max: VeiculeMaxAggregateOutputType | null
  }

  export type VeiculeAvgAggregateOutputType = {
    id: number | null
  }

  export type VeiculeSumAggregateOutputType = {
    id: number | null
  }

  export type VeiculeMinAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VeiculeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VeiculeCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type VeiculeAvgAggregateInputType = {
    id?: true
  }

  export type VeiculeSumAggregateInputType = {
    id?: true
  }

  export type VeiculeMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type VeiculeMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type VeiculeCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type VeiculeAggregateArgs = {
    /**
     * Filter which veicule to aggregate.
     */
    where?: veiculeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of veicules to fetch.
     */
    orderBy?: Enumerable<veiculeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: veiculeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` veicules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` veicules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned veicules
    **/
    _count?: true | VeiculeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VeiculeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VeiculeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VeiculeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VeiculeMaxAggregateInputType
  }

  export type GetVeiculeAggregateType<T extends VeiculeAggregateArgs> = {
        [P in keyof T & keyof AggregateVeicule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVeicule[P]>
      : GetScalarType<T[P], AggregateVeicule[P]>
  }




  export type VeiculeGroupByArgs = {
    where?: veiculeWhereInput
    orderBy?: Enumerable<veiculeOrderByWithAggregationInput>
    by: VeiculeScalarFieldEnum[]
    having?: veiculeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VeiculeCountAggregateInputType | true
    _avg?: VeiculeAvgAggregateInputType
    _sum?: VeiculeSumAggregateInputType
    _min?: VeiculeMinAggregateInputType
    _max?: VeiculeMaxAggregateInputType
  }


  export type VeiculeGroupByOutputType = {
    id: number
    name: string
    created_at: Date
    updated_at: Date
    _count: VeiculeCountAggregateOutputType | null
    _avg: VeiculeAvgAggregateOutputType | null
    _sum: VeiculeSumAggregateOutputType | null
    _min: VeiculeMinAggregateOutputType | null
    _max: VeiculeMaxAggregateOutputType | null
  }

  type GetVeiculeGroupByPayload<T extends VeiculeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<VeiculeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VeiculeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VeiculeGroupByOutputType[P]>
            : GetScalarType<T[P], VeiculeGroupByOutputType[P]>
        }
      >
    >


  export type veiculeSelect = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    veicule_deliveryman?: boolean | veicule$veicule_deliverymanArgs
    _count?: boolean | VeiculeCountOutputTypeArgs
  }


  export type veiculeInclude = {
    veicule_deliveryman?: boolean | veicule$veicule_deliverymanArgs
    _count?: boolean | VeiculeCountOutputTypeArgs
  }

  export type veiculeGetPayload<S extends boolean | null | undefined | veiculeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? veicule :
    S extends undefined ? never :
    S extends { include: any } & (veiculeArgs | veiculeFindManyArgs)
    ? veicule  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'veicule_deliveryman' ? Array < veicule_deliverymanGetPayload<S['include'][P]>>  :
        P extends '_count' ? VeiculeCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (veiculeArgs | veiculeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'veicule_deliveryman' ? Array < veicule_deliverymanGetPayload<S['select'][P]>>  :
        P extends '_count' ? VeiculeCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof veicule ? veicule[P] : never
  } 
      : veicule


  type veiculeCountArgs = 
    Omit<veiculeFindManyArgs, 'select' | 'include'> & {
      select?: VeiculeCountAggregateInputType | true
    }

  export interface veiculeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Veicule that matches the filter.
     * @param {veiculeFindUniqueArgs} args - Arguments to find a Veicule
     * @example
     * // Get one Veicule
     * const veicule = await prisma.veicule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends veiculeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, veiculeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'veicule'> extends True ? Prisma__veiculeClient<veiculeGetPayload<T>> : Prisma__veiculeClient<veiculeGetPayload<T> | null, null>

    /**
     * Find one Veicule that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {veiculeFindUniqueOrThrowArgs} args - Arguments to find a Veicule
     * @example
     * // Get one Veicule
     * const veicule = await prisma.veicule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends veiculeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, veiculeFindUniqueOrThrowArgs>
    ): Prisma__veiculeClient<veiculeGetPayload<T>>

    /**
     * Find the first Veicule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {veiculeFindFirstArgs} args - Arguments to find a Veicule
     * @example
     * // Get one Veicule
     * const veicule = await prisma.veicule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends veiculeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, veiculeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'veicule'> extends True ? Prisma__veiculeClient<veiculeGetPayload<T>> : Prisma__veiculeClient<veiculeGetPayload<T> | null, null>

    /**
     * Find the first Veicule that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {veiculeFindFirstOrThrowArgs} args - Arguments to find a Veicule
     * @example
     * // Get one Veicule
     * const veicule = await prisma.veicule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends veiculeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, veiculeFindFirstOrThrowArgs>
    ): Prisma__veiculeClient<veiculeGetPayload<T>>

    /**
     * Find zero or more Veicules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {veiculeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Veicules
     * const veicules = await prisma.veicule.findMany()
     * 
     * // Get first 10 Veicules
     * const veicules = await prisma.veicule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const veiculeWithIdOnly = await prisma.veicule.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends veiculeFindManyArgs>(
      args?: SelectSubset<T, veiculeFindManyArgs>
    ): Prisma.PrismaPromise<Array<veiculeGetPayload<T>>>

    /**
     * Create a Veicule.
     * @param {veiculeCreateArgs} args - Arguments to create a Veicule.
     * @example
     * // Create one Veicule
     * const Veicule = await prisma.veicule.create({
     *   data: {
     *     // ... data to create a Veicule
     *   }
     * })
     * 
    **/
    create<T extends veiculeCreateArgs>(
      args: SelectSubset<T, veiculeCreateArgs>
    ): Prisma__veiculeClient<veiculeGetPayload<T>>

    /**
     * Create many Veicules.
     *     @param {veiculeCreateManyArgs} args - Arguments to create many Veicules.
     *     @example
     *     // Create many Veicules
     *     const veicule = await prisma.veicule.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends veiculeCreateManyArgs>(
      args?: SelectSubset<T, veiculeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Veicule.
     * @param {veiculeDeleteArgs} args - Arguments to delete one Veicule.
     * @example
     * // Delete one Veicule
     * const Veicule = await prisma.veicule.delete({
     *   where: {
     *     // ... filter to delete one Veicule
     *   }
     * })
     * 
    **/
    delete<T extends veiculeDeleteArgs>(
      args: SelectSubset<T, veiculeDeleteArgs>
    ): Prisma__veiculeClient<veiculeGetPayload<T>>

    /**
     * Update one Veicule.
     * @param {veiculeUpdateArgs} args - Arguments to update one Veicule.
     * @example
     * // Update one Veicule
     * const veicule = await prisma.veicule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends veiculeUpdateArgs>(
      args: SelectSubset<T, veiculeUpdateArgs>
    ): Prisma__veiculeClient<veiculeGetPayload<T>>

    /**
     * Delete zero or more Veicules.
     * @param {veiculeDeleteManyArgs} args - Arguments to filter Veicules to delete.
     * @example
     * // Delete a few Veicules
     * const { count } = await prisma.veicule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends veiculeDeleteManyArgs>(
      args?: SelectSubset<T, veiculeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Veicules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {veiculeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Veicules
     * const veicule = await prisma.veicule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends veiculeUpdateManyArgs>(
      args: SelectSubset<T, veiculeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Veicule.
     * @param {veiculeUpsertArgs} args - Arguments to update or create a Veicule.
     * @example
     * // Update or create a Veicule
     * const veicule = await prisma.veicule.upsert({
     *   create: {
     *     // ... data to create a Veicule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Veicule we want to update
     *   }
     * })
    **/
    upsert<T extends veiculeUpsertArgs>(
      args: SelectSubset<T, veiculeUpsertArgs>
    ): Prisma__veiculeClient<veiculeGetPayload<T>>

    /**
     * Count the number of Veicules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {veiculeCountArgs} args - Arguments to filter Veicules to count.
     * @example
     * // Count the number of Veicules
     * const count = await prisma.veicule.count({
     *   where: {
     *     // ... the filter for the Veicules we want to count
     *   }
     * })
    **/
    count<T extends veiculeCountArgs>(
      args?: Subset<T, veiculeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VeiculeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Veicule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeiculeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VeiculeAggregateArgs>(args: Subset<T, VeiculeAggregateArgs>): Prisma.PrismaPromise<GetVeiculeAggregateType<T>>

    /**
     * Group by Veicule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VeiculeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VeiculeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VeiculeGroupByArgs['orderBy'] }
        : { orderBy?: VeiculeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VeiculeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVeiculeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for veicule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__veiculeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    veicule_deliveryman<T extends veicule$veicule_deliverymanArgs= {}>(args?: Subset<T, veicule$veicule_deliverymanArgs>): Prisma.PrismaPromise<Array<veicule_deliverymanGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * veicule base type for findUnique actions
   */
  export type veiculeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the veicule
     */
    select?: veiculeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veiculeInclude | null
    /**
     * Filter, which veicule to fetch.
     */
    where: veiculeWhereUniqueInput
  }

  /**
   * veicule findUnique
   */
  export interface veiculeFindUniqueArgs extends veiculeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * veicule findUniqueOrThrow
   */
  export type veiculeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the veicule
     */
    select?: veiculeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veiculeInclude | null
    /**
     * Filter, which veicule to fetch.
     */
    where: veiculeWhereUniqueInput
  }


  /**
   * veicule base type for findFirst actions
   */
  export type veiculeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the veicule
     */
    select?: veiculeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veiculeInclude | null
    /**
     * Filter, which veicule to fetch.
     */
    where?: veiculeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of veicules to fetch.
     */
    orderBy?: Enumerable<veiculeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for veicules.
     */
    cursor?: veiculeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` veicules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` veicules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of veicules.
     */
    distinct?: Enumerable<VeiculeScalarFieldEnum>
  }

  /**
   * veicule findFirst
   */
  export interface veiculeFindFirstArgs extends veiculeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * veicule findFirstOrThrow
   */
  export type veiculeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the veicule
     */
    select?: veiculeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veiculeInclude | null
    /**
     * Filter, which veicule to fetch.
     */
    where?: veiculeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of veicules to fetch.
     */
    orderBy?: Enumerable<veiculeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for veicules.
     */
    cursor?: veiculeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` veicules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` veicules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of veicules.
     */
    distinct?: Enumerable<VeiculeScalarFieldEnum>
  }


  /**
   * veicule findMany
   */
  export type veiculeFindManyArgs = {
    /**
     * Select specific fields to fetch from the veicule
     */
    select?: veiculeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veiculeInclude | null
    /**
     * Filter, which veicules to fetch.
     */
    where?: veiculeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of veicules to fetch.
     */
    orderBy?: Enumerable<veiculeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing veicules.
     */
    cursor?: veiculeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` veicules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` veicules.
     */
    skip?: number
    distinct?: Enumerable<VeiculeScalarFieldEnum>
  }


  /**
   * veicule create
   */
  export type veiculeCreateArgs = {
    /**
     * Select specific fields to fetch from the veicule
     */
    select?: veiculeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veiculeInclude | null
    /**
     * The data needed to create a veicule.
     */
    data: XOR<veiculeCreateInput, veiculeUncheckedCreateInput>
  }


  /**
   * veicule createMany
   */
  export type veiculeCreateManyArgs = {
    /**
     * The data used to create many veicules.
     */
    data: Enumerable<veiculeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * veicule update
   */
  export type veiculeUpdateArgs = {
    /**
     * Select specific fields to fetch from the veicule
     */
    select?: veiculeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veiculeInclude | null
    /**
     * The data needed to update a veicule.
     */
    data: XOR<veiculeUpdateInput, veiculeUncheckedUpdateInput>
    /**
     * Choose, which veicule to update.
     */
    where: veiculeWhereUniqueInput
  }


  /**
   * veicule updateMany
   */
  export type veiculeUpdateManyArgs = {
    /**
     * The data used to update veicules.
     */
    data: XOR<veiculeUpdateManyMutationInput, veiculeUncheckedUpdateManyInput>
    /**
     * Filter which veicules to update
     */
    where?: veiculeWhereInput
  }


  /**
   * veicule upsert
   */
  export type veiculeUpsertArgs = {
    /**
     * Select specific fields to fetch from the veicule
     */
    select?: veiculeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veiculeInclude | null
    /**
     * The filter to search for the veicule to update in case it exists.
     */
    where: veiculeWhereUniqueInput
    /**
     * In case the veicule found by the `where` argument doesn't exist, create a new veicule with this data.
     */
    create: XOR<veiculeCreateInput, veiculeUncheckedCreateInput>
    /**
     * In case the veicule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<veiculeUpdateInput, veiculeUncheckedUpdateInput>
  }


  /**
   * veicule delete
   */
  export type veiculeDeleteArgs = {
    /**
     * Select specific fields to fetch from the veicule
     */
    select?: veiculeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veiculeInclude | null
    /**
     * Filter which veicule to delete.
     */
    where: veiculeWhereUniqueInput
  }


  /**
   * veicule deleteMany
   */
  export type veiculeDeleteManyArgs = {
    /**
     * Filter which veicules to delete
     */
    where?: veiculeWhereInput
  }


  /**
   * veicule.veicule_deliveryman
   */
  export type veicule$veicule_deliverymanArgs = {
    /**
     * Select specific fields to fetch from the veicule_deliveryman
     */
    select?: veicule_deliverymanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veicule_deliverymanInclude | null
    where?: veicule_deliverymanWhereInput
    orderBy?: Enumerable<veicule_deliverymanOrderByWithRelationInput>
    cursor?: veicule_deliverymanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Veicule_deliverymanScalarFieldEnum>
  }


  /**
   * veicule without action
   */
  export type veiculeArgs = {
    /**
     * Select specific fields to fetch from the veicule
     */
    select?: veiculeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: veiculeInclude | null
  }



  /**
   * Model image_of_product
   */


  export type AggregateImage_of_product = {
    _count: Image_of_productCountAggregateOutputType | null
    _avg: Image_of_productAvgAggregateOutputType | null
    _sum: Image_of_productSumAggregateOutputType | null
    _min: Image_of_productMinAggregateOutputType | null
    _max: Image_of_productMaxAggregateOutputType | null
  }

  export type Image_of_productAvgAggregateOutputType = {
    id: number | null
    imageId: number | null
    productId: number | null
  }

  export type Image_of_productSumAggregateOutputType = {
    id: number | null
    imageId: number | null
    productId: number | null
  }

  export type Image_of_productMinAggregateOutputType = {
    id: number | null
    imageId: number | null
    productId: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Image_of_productMaxAggregateOutputType = {
    id: number | null
    imageId: number | null
    productId: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Image_of_productCountAggregateOutputType = {
    id: number
    imageId: number
    productId: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Image_of_productAvgAggregateInputType = {
    id?: true
    imageId?: true
    productId?: true
  }

  export type Image_of_productSumAggregateInputType = {
    id?: true
    imageId?: true
    productId?: true
  }

  export type Image_of_productMinAggregateInputType = {
    id?: true
    imageId?: true
    productId?: true
    created_at?: true
    updated_at?: true
  }

  export type Image_of_productMaxAggregateInputType = {
    id?: true
    imageId?: true
    productId?: true
    created_at?: true
    updated_at?: true
  }

  export type Image_of_productCountAggregateInputType = {
    id?: true
    imageId?: true
    productId?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Image_of_productAggregateArgs = {
    /**
     * Filter which image_of_product to aggregate.
     */
    where?: image_of_productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of image_of_products to fetch.
     */
    orderBy?: Enumerable<image_of_productOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: image_of_productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` image_of_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` image_of_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned image_of_products
    **/
    _count?: true | Image_of_productCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Image_of_productAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Image_of_productSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Image_of_productMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Image_of_productMaxAggregateInputType
  }

  export type GetImage_of_productAggregateType<T extends Image_of_productAggregateArgs> = {
        [P in keyof T & keyof AggregateImage_of_product]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImage_of_product[P]>
      : GetScalarType<T[P], AggregateImage_of_product[P]>
  }




  export type Image_of_productGroupByArgs = {
    where?: image_of_productWhereInput
    orderBy?: Enumerable<image_of_productOrderByWithAggregationInput>
    by: Image_of_productScalarFieldEnum[]
    having?: image_of_productScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Image_of_productCountAggregateInputType | true
    _avg?: Image_of_productAvgAggregateInputType
    _sum?: Image_of_productSumAggregateInputType
    _min?: Image_of_productMinAggregateInputType
    _max?: Image_of_productMaxAggregateInputType
  }


  export type Image_of_productGroupByOutputType = {
    id: number
    imageId: number
    productId: number
    created_at: Date
    updated_at: Date
    _count: Image_of_productCountAggregateOutputType | null
    _avg: Image_of_productAvgAggregateOutputType | null
    _sum: Image_of_productSumAggregateOutputType | null
    _min: Image_of_productMinAggregateOutputType | null
    _max: Image_of_productMaxAggregateOutputType | null
  }

  type GetImage_of_productGroupByPayload<T extends Image_of_productGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Image_of_productGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Image_of_productGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Image_of_productGroupByOutputType[P]>
            : GetScalarType<T[P], Image_of_productGroupByOutputType[P]>
        }
      >
    >


  export type image_of_productSelect = {
    id?: boolean
    imageId?: boolean
    productId?: boolean
    created_at?: boolean
    updated_at?: boolean
    image?: boolean | imageArgs
    product?: boolean | productArgs
  }


  export type image_of_productInclude = {
    image?: boolean | imageArgs
    product?: boolean | productArgs
  }

  export type image_of_productGetPayload<S extends boolean | null | undefined | image_of_productArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? image_of_product :
    S extends undefined ? never :
    S extends { include: any } & (image_of_productArgs | image_of_productFindManyArgs)
    ? image_of_product  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'image' ? imageGetPayload<S['include'][P]> :
        P extends 'product' ? productGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (image_of_productArgs | image_of_productFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'image' ? imageGetPayload<S['select'][P]> :
        P extends 'product' ? productGetPayload<S['select'][P]> :  P extends keyof image_of_product ? image_of_product[P] : never
  } 
      : image_of_product


  type image_of_productCountArgs = 
    Omit<image_of_productFindManyArgs, 'select' | 'include'> & {
      select?: Image_of_productCountAggregateInputType | true
    }

  export interface image_of_productDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Image_of_product that matches the filter.
     * @param {image_of_productFindUniqueArgs} args - Arguments to find a Image_of_product
     * @example
     * // Get one Image_of_product
     * const image_of_product = await prisma.image_of_product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends image_of_productFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, image_of_productFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'image_of_product'> extends True ? Prisma__image_of_productClient<image_of_productGetPayload<T>> : Prisma__image_of_productClient<image_of_productGetPayload<T> | null, null>

    /**
     * Find one Image_of_product that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {image_of_productFindUniqueOrThrowArgs} args - Arguments to find a Image_of_product
     * @example
     * // Get one Image_of_product
     * const image_of_product = await prisma.image_of_product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends image_of_productFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, image_of_productFindUniqueOrThrowArgs>
    ): Prisma__image_of_productClient<image_of_productGetPayload<T>>

    /**
     * Find the first Image_of_product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {image_of_productFindFirstArgs} args - Arguments to find a Image_of_product
     * @example
     * // Get one Image_of_product
     * const image_of_product = await prisma.image_of_product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends image_of_productFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, image_of_productFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'image_of_product'> extends True ? Prisma__image_of_productClient<image_of_productGetPayload<T>> : Prisma__image_of_productClient<image_of_productGetPayload<T> | null, null>

    /**
     * Find the first Image_of_product that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {image_of_productFindFirstOrThrowArgs} args - Arguments to find a Image_of_product
     * @example
     * // Get one Image_of_product
     * const image_of_product = await prisma.image_of_product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends image_of_productFindFirstOrThrowArgs>(
      args?: SelectSubset<T, image_of_productFindFirstOrThrowArgs>
    ): Prisma__image_of_productClient<image_of_productGetPayload<T>>

    /**
     * Find zero or more Image_of_products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {image_of_productFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Image_of_products
     * const image_of_products = await prisma.image_of_product.findMany()
     * 
     * // Get first 10 Image_of_products
     * const image_of_products = await prisma.image_of_product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const image_of_productWithIdOnly = await prisma.image_of_product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends image_of_productFindManyArgs>(
      args?: SelectSubset<T, image_of_productFindManyArgs>
    ): Prisma.PrismaPromise<Array<image_of_productGetPayload<T>>>

    /**
     * Create a Image_of_product.
     * @param {image_of_productCreateArgs} args - Arguments to create a Image_of_product.
     * @example
     * // Create one Image_of_product
     * const Image_of_product = await prisma.image_of_product.create({
     *   data: {
     *     // ... data to create a Image_of_product
     *   }
     * })
     * 
    **/
    create<T extends image_of_productCreateArgs>(
      args: SelectSubset<T, image_of_productCreateArgs>
    ): Prisma__image_of_productClient<image_of_productGetPayload<T>>

    /**
     * Create many Image_of_products.
     *     @param {image_of_productCreateManyArgs} args - Arguments to create many Image_of_products.
     *     @example
     *     // Create many Image_of_products
     *     const image_of_product = await prisma.image_of_product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends image_of_productCreateManyArgs>(
      args?: SelectSubset<T, image_of_productCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Image_of_product.
     * @param {image_of_productDeleteArgs} args - Arguments to delete one Image_of_product.
     * @example
     * // Delete one Image_of_product
     * const Image_of_product = await prisma.image_of_product.delete({
     *   where: {
     *     // ... filter to delete one Image_of_product
     *   }
     * })
     * 
    **/
    delete<T extends image_of_productDeleteArgs>(
      args: SelectSubset<T, image_of_productDeleteArgs>
    ): Prisma__image_of_productClient<image_of_productGetPayload<T>>

    /**
     * Update one Image_of_product.
     * @param {image_of_productUpdateArgs} args - Arguments to update one Image_of_product.
     * @example
     * // Update one Image_of_product
     * const image_of_product = await prisma.image_of_product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends image_of_productUpdateArgs>(
      args: SelectSubset<T, image_of_productUpdateArgs>
    ): Prisma__image_of_productClient<image_of_productGetPayload<T>>

    /**
     * Delete zero or more Image_of_products.
     * @param {image_of_productDeleteManyArgs} args - Arguments to filter Image_of_products to delete.
     * @example
     * // Delete a few Image_of_products
     * const { count } = await prisma.image_of_product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends image_of_productDeleteManyArgs>(
      args?: SelectSubset<T, image_of_productDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Image_of_products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {image_of_productUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Image_of_products
     * const image_of_product = await prisma.image_of_product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends image_of_productUpdateManyArgs>(
      args: SelectSubset<T, image_of_productUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Image_of_product.
     * @param {image_of_productUpsertArgs} args - Arguments to update or create a Image_of_product.
     * @example
     * // Update or create a Image_of_product
     * const image_of_product = await prisma.image_of_product.upsert({
     *   create: {
     *     // ... data to create a Image_of_product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Image_of_product we want to update
     *   }
     * })
    **/
    upsert<T extends image_of_productUpsertArgs>(
      args: SelectSubset<T, image_of_productUpsertArgs>
    ): Prisma__image_of_productClient<image_of_productGetPayload<T>>

    /**
     * Count the number of Image_of_products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {image_of_productCountArgs} args - Arguments to filter Image_of_products to count.
     * @example
     * // Count the number of Image_of_products
     * const count = await prisma.image_of_product.count({
     *   where: {
     *     // ... the filter for the Image_of_products we want to count
     *   }
     * })
    **/
    count<T extends image_of_productCountArgs>(
      args?: Subset<T, image_of_productCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Image_of_productCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Image_of_product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Image_of_productAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Image_of_productAggregateArgs>(args: Subset<T, Image_of_productAggregateArgs>): Prisma.PrismaPromise<GetImage_of_productAggregateType<T>>

    /**
     * Group by Image_of_product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Image_of_productGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Image_of_productGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Image_of_productGroupByArgs['orderBy'] }
        : { orderBy?: Image_of_productGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Image_of_productGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImage_of_productGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for image_of_product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__image_of_productClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    image<T extends imageArgs= {}>(args?: Subset<T, imageArgs>): Prisma__imageClient<imageGetPayload<T> | Null>;

    product<T extends productArgs= {}>(args?: Subset<T, productArgs>): Prisma__productClient<productGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * image_of_product base type for findUnique actions
   */
  export type image_of_productFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the image_of_product
     */
    select?: image_of_productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: image_of_productInclude | null
    /**
     * Filter, which image_of_product to fetch.
     */
    where: image_of_productWhereUniqueInput
  }

  /**
   * image_of_product findUnique
   */
  export interface image_of_productFindUniqueArgs extends image_of_productFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * image_of_product findUniqueOrThrow
   */
  export type image_of_productFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the image_of_product
     */
    select?: image_of_productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: image_of_productInclude | null
    /**
     * Filter, which image_of_product to fetch.
     */
    where: image_of_productWhereUniqueInput
  }


  /**
   * image_of_product base type for findFirst actions
   */
  export type image_of_productFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the image_of_product
     */
    select?: image_of_productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: image_of_productInclude | null
    /**
     * Filter, which image_of_product to fetch.
     */
    where?: image_of_productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of image_of_products to fetch.
     */
    orderBy?: Enumerable<image_of_productOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for image_of_products.
     */
    cursor?: image_of_productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` image_of_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` image_of_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of image_of_products.
     */
    distinct?: Enumerable<Image_of_productScalarFieldEnum>
  }

  /**
   * image_of_product findFirst
   */
  export interface image_of_productFindFirstArgs extends image_of_productFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * image_of_product findFirstOrThrow
   */
  export type image_of_productFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the image_of_product
     */
    select?: image_of_productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: image_of_productInclude | null
    /**
     * Filter, which image_of_product to fetch.
     */
    where?: image_of_productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of image_of_products to fetch.
     */
    orderBy?: Enumerable<image_of_productOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for image_of_products.
     */
    cursor?: image_of_productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` image_of_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` image_of_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of image_of_products.
     */
    distinct?: Enumerable<Image_of_productScalarFieldEnum>
  }


  /**
   * image_of_product findMany
   */
  export type image_of_productFindManyArgs = {
    /**
     * Select specific fields to fetch from the image_of_product
     */
    select?: image_of_productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: image_of_productInclude | null
    /**
     * Filter, which image_of_products to fetch.
     */
    where?: image_of_productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of image_of_products to fetch.
     */
    orderBy?: Enumerable<image_of_productOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing image_of_products.
     */
    cursor?: image_of_productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` image_of_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` image_of_products.
     */
    skip?: number
    distinct?: Enumerable<Image_of_productScalarFieldEnum>
  }


  /**
   * image_of_product create
   */
  export type image_of_productCreateArgs = {
    /**
     * Select specific fields to fetch from the image_of_product
     */
    select?: image_of_productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: image_of_productInclude | null
    /**
     * The data needed to create a image_of_product.
     */
    data: XOR<image_of_productCreateInput, image_of_productUncheckedCreateInput>
  }


  /**
   * image_of_product createMany
   */
  export type image_of_productCreateManyArgs = {
    /**
     * The data used to create many image_of_products.
     */
    data: Enumerable<image_of_productCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * image_of_product update
   */
  export type image_of_productUpdateArgs = {
    /**
     * Select specific fields to fetch from the image_of_product
     */
    select?: image_of_productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: image_of_productInclude | null
    /**
     * The data needed to update a image_of_product.
     */
    data: XOR<image_of_productUpdateInput, image_of_productUncheckedUpdateInput>
    /**
     * Choose, which image_of_product to update.
     */
    where: image_of_productWhereUniqueInput
  }


  /**
   * image_of_product updateMany
   */
  export type image_of_productUpdateManyArgs = {
    /**
     * The data used to update image_of_products.
     */
    data: XOR<image_of_productUpdateManyMutationInput, image_of_productUncheckedUpdateManyInput>
    /**
     * Filter which image_of_products to update
     */
    where?: image_of_productWhereInput
  }


  /**
   * image_of_product upsert
   */
  export type image_of_productUpsertArgs = {
    /**
     * Select specific fields to fetch from the image_of_product
     */
    select?: image_of_productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: image_of_productInclude | null
    /**
     * The filter to search for the image_of_product to update in case it exists.
     */
    where: image_of_productWhereUniqueInput
    /**
     * In case the image_of_product found by the `where` argument doesn't exist, create a new image_of_product with this data.
     */
    create: XOR<image_of_productCreateInput, image_of_productUncheckedCreateInput>
    /**
     * In case the image_of_product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<image_of_productUpdateInput, image_of_productUncheckedUpdateInput>
  }


  /**
   * image_of_product delete
   */
  export type image_of_productDeleteArgs = {
    /**
     * Select specific fields to fetch from the image_of_product
     */
    select?: image_of_productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: image_of_productInclude | null
    /**
     * Filter which image_of_product to delete.
     */
    where: image_of_productWhereUniqueInput
  }


  /**
   * image_of_product deleteMany
   */
  export type image_of_productDeleteManyArgs = {
    /**
     * Filter which image_of_products to delete
     */
    where?: image_of_productWhereInput
  }


  /**
   * image_of_product without action
   */
  export type image_of_productArgs = {
    /**
     * Select specific fields to fetch from the image_of_product
     */
    select?: image_of_productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: image_of_productInclude | null
  }



  /**
   * Model image
   */


  export type AggregateImage = {
    _count: ImageCountAggregateOutputType | null
    _avg: ImageAvgAggregateOutputType | null
    _sum: ImageSumAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  export type ImageAvgAggregateOutputType = {
    id: number | null
    fairId: number | null
  }

  export type ImageSumAggregateOutputType = {
    id: number | null
    fairId: number | null
  }

  export type ImageMinAggregateOutputType = {
    id: number | null
    uri: string | null
    created_at: Date | null
    updated_at: Date | null
    fairId: number | null
  }

  export type ImageMaxAggregateOutputType = {
    id: number | null
    uri: string | null
    created_at: Date | null
    updated_at: Date | null
    fairId: number | null
  }

  export type ImageCountAggregateOutputType = {
    id: number
    uri: number
    created_at: number
    updated_at: number
    fairId: number
    _all: number
  }


  export type ImageAvgAggregateInputType = {
    id?: true
    fairId?: true
  }

  export type ImageSumAggregateInputType = {
    id?: true
    fairId?: true
  }

  export type ImageMinAggregateInputType = {
    id?: true
    uri?: true
    created_at?: true
    updated_at?: true
    fairId?: true
  }

  export type ImageMaxAggregateInputType = {
    id?: true
    uri?: true
    created_at?: true
    updated_at?: true
    fairId?: true
  }

  export type ImageCountAggregateInputType = {
    id?: true
    uri?: true
    created_at?: true
    updated_at?: true
    fairId?: true
    _all?: true
  }

  export type ImageAggregateArgs = {
    /**
     * Filter which image to aggregate.
     */
    where?: imageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of images to fetch.
     */
    orderBy?: Enumerable<imageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: imageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned images
    **/
    _count?: true | ImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageMaxAggregateInputType
  }

  export type GetImageAggregateType<T extends ImageAggregateArgs> = {
        [P in keyof T & keyof AggregateImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImage[P]>
      : GetScalarType<T[P], AggregateImage[P]>
  }




  export type ImageGroupByArgs = {
    where?: imageWhereInput
    orderBy?: Enumerable<imageOrderByWithAggregationInput>
    by: ImageScalarFieldEnum[]
    having?: imageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageCountAggregateInputType | true
    _avg?: ImageAvgAggregateInputType
    _sum?: ImageSumAggregateInputType
    _min?: ImageMinAggregateInputType
    _max?: ImageMaxAggregateInputType
  }


  export type ImageGroupByOutputType = {
    id: number
    uri: string
    created_at: Date
    updated_at: Date
    fairId: number | null
    _count: ImageCountAggregateOutputType | null
    _avg: ImageAvgAggregateOutputType | null
    _sum: ImageSumAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  type GetImageGroupByPayload<T extends ImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageGroupByOutputType[P]>
            : GetScalarType<T[P], ImageGroupByOutputType[P]>
        }
      >
    >


  export type imageSelect = {
    id?: boolean
    uri?: boolean
    created_at?: boolean
    updated_at?: boolean
    fairId?: boolean
    category_of_product?: boolean | image$category_of_productArgs
    fair?: boolean | fairArgs
    image_of_product?: boolean | image$image_of_productArgs
    _count?: boolean | ImageCountOutputTypeArgs
  }


  export type imageInclude = {
    category_of_product?: boolean | image$category_of_productArgs
    fair?: boolean | fairArgs
    image_of_product?: boolean | image$image_of_productArgs
    _count?: boolean | ImageCountOutputTypeArgs
  }

  export type imageGetPayload<S extends boolean | null | undefined | imageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? image :
    S extends undefined ? never :
    S extends { include: any } & (imageArgs | imageFindManyArgs)
    ? image  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'category_of_product' ? Array < category_of_productGetPayload<S['include'][P]>>  :
        P extends 'fair' ? fairGetPayload<S['include'][P]> | null :
        P extends 'image_of_product' ? Array < image_of_productGetPayload<S['include'][P]>>  :
        P extends '_count' ? ImageCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (imageArgs | imageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'category_of_product' ? Array < category_of_productGetPayload<S['select'][P]>>  :
        P extends 'fair' ? fairGetPayload<S['select'][P]> | null :
        P extends 'image_of_product' ? Array < image_of_productGetPayload<S['select'][P]>>  :
        P extends '_count' ? ImageCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof image ? image[P] : never
  } 
      : image


  type imageCountArgs = 
    Omit<imageFindManyArgs, 'select' | 'include'> & {
      select?: ImageCountAggregateInputType | true
    }

  export interface imageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Image that matches the filter.
     * @param {imageFindUniqueArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends imageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, imageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'image'> extends True ? Prisma__imageClient<imageGetPayload<T>> : Prisma__imageClient<imageGetPayload<T> | null, null>

    /**
     * Find one Image that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {imageFindUniqueOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends imageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, imageFindUniqueOrThrowArgs>
    ): Prisma__imageClient<imageGetPayload<T>>

    /**
     * Find the first Image that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imageFindFirstArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends imageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, imageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'image'> extends True ? Prisma__imageClient<imageGetPayload<T>> : Prisma__imageClient<imageGetPayload<T> | null, null>

    /**
     * Find the first Image that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imageFindFirstOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends imageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, imageFindFirstOrThrowArgs>
    ): Prisma__imageClient<imageGetPayload<T>>

    /**
     * Find zero or more Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images
     * const images = await prisma.image.findMany()
     * 
     * // Get first 10 Images
     * const images = await prisma.image.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imageWithIdOnly = await prisma.image.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends imageFindManyArgs>(
      args?: SelectSubset<T, imageFindManyArgs>
    ): Prisma.PrismaPromise<Array<imageGetPayload<T>>>

    /**
     * Create a Image.
     * @param {imageCreateArgs} args - Arguments to create a Image.
     * @example
     * // Create one Image
     * const Image = await prisma.image.create({
     *   data: {
     *     // ... data to create a Image
     *   }
     * })
     * 
    **/
    create<T extends imageCreateArgs>(
      args: SelectSubset<T, imageCreateArgs>
    ): Prisma__imageClient<imageGetPayload<T>>

    /**
     * Create many Images.
     *     @param {imageCreateManyArgs} args - Arguments to create many Images.
     *     @example
     *     // Create many Images
     *     const image = await prisma.image.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends imageCreateManyArgs>(
      args?: SelectSubset<T, imageCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Image.
     * @param {imageDeleteArgs} args - Arguments to delete one Image.
     * @example
     * // Delete one Image
     * const Image = await prisma.image.delete({
     *   where: {
     *     // ... filter to delete one Image
     *   }
     * })
     * 
    **/
    delete<T extends imageDeleteArgs>(
      args: SelectSubset<T, imageDeleteArgs>
    ): Prisma__imageClient<imageGetPayload<T>>

    /**
     * Update one Image.
     * @param {imageUpdateArgs} args - Arguments to update one Image.
     * @example
     * // Update one Image
     * const image = await prisma.image.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends imageUpdateArgs>(
      args: SelectSubset<T, imageUpdateArgs>
    ): Prisma__imageClient<imageGetPayload<T>>

    /**
     * Delete zero or more Images.
     * @param {imageDeleteManyArgs} args - Arguments to filter Images to delete.
     * @example
     * // Delete a few Images
     * const { count } = await prisma.image.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends imageDeleteManyArgs>(
      args?: SelectSubset<T, imageDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends imageUpdateManyArgs>(
      args: SelectSubset<T, imageUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Image.
     * @param {imageUpsertArgs} args - Arguments to update or create a Image.
     * @example
     * // Update or create a Image
     * const image = await prisma.image.upsert({
     *   create: {
     *     // ... data to create a Image
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Image we want to update
     *   }
     * })
    **/
    upsert<T extends imageUpsertArgs>(
      args: SelectSubset<T, imageUpsertArgs>
    ): Prisma__imageClient<imageGetPayload<T>>

    /**
     * Count the number of Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imageCountArgs} args - Arguments to filter Images to count.
     * @example
     * // Count the number of Images
     * const count = await prisma.image.count({
     *   where: {
     *     // ... the filter for the Images we want to count
     *   }
     * })
    **/
    count<T extends imageCountArgs>(
      args?: Subset<T, imageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageAggregateArgs>(args: Subset<T, ImageAggregateArgs>): Prisma.PrismaPromise<GetImageAggregateType<T>>

    /**
     * Group by Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageGroupByArgs['orderBy'] }
        : { orderBy?: ImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for image.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__imageClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    category_of_product<T extends image$category_of_productArgs= {}>(args?: Subset<T, image$category_of_productArgs>): Prisma.PrismaPromise<Array<category_of_productGetPayload<T>>| Null>;

    fair<T extends fairArgs= {}>(args?: Subset<T, fairArgs>): Prisma__fairClient<fairGetPayload<T> | Null>;

    image_of_product<T extends image$image_of_productArgs= {}>(args?: Subset<T, image$image_of_productArgs>): Prisma.PrismaPromise<Array<image_of_productGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * image base type for findUnique actions
   */
  export type imageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the image
     */
    select?: imageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imageInclude | null
    /**
     * Filter, which image to fetch.
     */
    where: imageWhereUniqueInput
  }

  /**
   * image findUnique
   */
  export interface imageFindUniqueArgs extends imageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * image findUniqueOrThrow
   */
  export type imageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the image
     */
    select?: imageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imageInclude | null
    /**
     * Filter, which image to fetch.
     */
    where: imageWhereUniqueInput
  }


  /**
   * image base type for findFirst actions
   */
  export type imageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the image
     */
    select?: imageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imageInclude | null
    /**
     * Filter, which image to fetch.
     */
    where?: imageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of images to fetch.
     */
    orderBy?: Enumerable<imageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for images.
     */
    cursor?: imageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of images.
     */
    distinct?: Enumerable<ImageScalarFieldEnum>
  }

  /**
   * image findFirst
   */
  export interface imageFindFirstArgs extends imageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * image findFirstOrThrow
   */
  export type imageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the image
     */
    select?: imageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imageInclude | null
    /**
     * Filter, which image to fetch.
     */
    where?: imageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of images to fetch.
     */
    orderBy?: Enumerable<imageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for images.
     */
    cursor?: imageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of images.
     */
    distinct?: Enumerable<ImageScalarFieldEnum>
  }


  /**
   * image findMany
   */
  export type imageFindManyArgs = {
    /**
     * Select specific fields to fetch from the image
     */
    select?: imageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imageInclude | null
    /**
     * Filter, which images to fetch.
     */
    where?: imageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of images to fetch.
     */
    orderBy?: Enumerable<imageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing images.
     */
    cursor?: imageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` images.
     */
    skip?: number
    distinct?: Enumerable<ImageScalarFieldEnum>
  }


  /**
   * image create
   */
  export type imageCreateArgs = {
    /**
     * Select specific fields to fetch from the image
     */
    select?: imageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imageInclude | null
    /**
     * The data needed to create a image.
     */
    data: XOR<imageCreateInput, imageUncheckedCreateInput>
  }


  /**
   * image createMany
   */
  export type imageCreateManyArgs = {
    /**
     * The data used to create many images.
     */
    data: Enumerable<imageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * image update
   */
  export type imageUpdateArgs = {
    /**
     * Select specific fields to fetch from the image
     */
    select?: imageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imageInclude | null
    /**
     * The data needed to update a image.
     */
    data: XOR<imageUpdateInput, imageUncheckedUpdateInput>
    /**
     * Choose, which image to update.
     */
    where: imageWhereUniqueInput
  }


  /**
   * image updateMany
   */
  export type imageUpdateManyArgs = {
    /**
     * The data used to update images.
     */
    data: XOR<imageUpdateManyMutationInput, imageUncheckedUpdateManyInput>
    /**
     * Filter which images to update
     */
    where?: imageWhereInput
  }


  /**
   * image upsert
   */
  export type imageUpsertArgs = {
    /**
     * Select specific fields to fetch from the image
     */
    select?: imageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imageInclude | null
    /**
     * The filter to search for the image to update in case it exists.
     */
    where: imageWhereUniqueInput
    /**
     * In case the image found by the `where` argument doesn't exist, create a new image with this data.
     */
    create: XOR<imageCreateInput, imageUncheckedCreateInput>
    /**
     * In case the image was found with the provided `where` argument, update it with this data.
     */
    update: XOR<imageUpdateInput, imageUncheckedUpdateInput>
  }


  /**
   * image delete
   */
  export type imageDeleteArgs = {
    /**
     * Select specific fields to fetch from the image
     */
    select?: imageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imageInclude | null
    /**
     * Filter which image to delete.
     */
    where: imageWhereUniqueInput
  }


  /**
   * image deleteMany
   */
  export type imageDeleteManyArgs = {
    /**
     * Filter which images to delete
     */
    where?: imageWhereInput
  }


  /**
   * image.category_of_product
   */
  export type image$category_of_productArgs = {
    /**
     * Select specific fields to fetch from the category_of_product
     */
    select?: category_of_productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: category_of_productInclude | null
    where?: category_of_productWhereInput
    orderBy?: Enumerable<category_of_productOrderByWithRelationInput>
    cursor?: category_of_productWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Category_of_productScalarFieldEnum>
  }


  /**
   * image.image_of_product
   */
  export type image$image_of_productArgs = {
    /**
     * Select specific fields to fetch from the image_of_product
     */
    select?: image_of_productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: image_of_productInclude | null
    where?: image_of_productWhereInput
    orderBy?: Enumerable<image_of_productOrderByWithRelationInput>
    cursor?: image_of_productWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Image_of_productScalarFieldEnum>
  }


  /**
   * image without action
   */
  export type imageArgs = {
    /**
     * Select specific fields to fetch from the image
     */
    select?: imageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: imageInclude | null
  }



  /**
   * Model payment_method
   */


  export type AggregatePayment_method = {
    _count: Payment_methodCountAggregateOutputType | null
    _avg: Payment_methodAvgAggregateOutputType | null
    _sum: Payment_methodSumAggregateOutputType | null
    _min: Payment_methodMinAggregateOutputType | null
    _max: Payment_methodMaxAggregateOutputType | null
  }

  export type Payment_methodAvgAggregateOutputType = {
    id: number | null
  }

  export type Payment_methodSumAggregateOutputType = {
    id: number | null
  }

  export type Payment_methodMinAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Payment_methodMaxAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Payment_methodCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Payment_methodAvgAggregateInputType = {
    id?: true
  }

  export type Payment_methodSumAggregateInputType = {
    id?: true
  }

  export type Payment_methodMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type Payment_methodMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type Payment_methodCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Payment_methodAggregateArgs = {
    /**
     * Filter which payment_method to aggregate.
     */
    where?: payment_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_methods to fetch.
     */
    orderBy?: Enumerable<payment_methodOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: payment_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payment_methods
    **/
    _count?: true | Payment_methodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Payment_methodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Payment_methodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Payment_methodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Payment_methodMaxAggregateInputType
  }

  export type GetPayment_methodAggregateType<T extends Payment_methodAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment_method]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment_method[P]>
      : GetScalarType<T[P], AggregatePayment_method[P]>
  }




  export type Payment_methodGroupByArgs = {
    where?: payment_methodWhereInput
    orderBy?: Enumerable<payment_methodOrderByWithAggregationInput>
    by: Payment_methodScalarFieldEnum[]
    having?: payment_methodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Payment_methodCountAggregateInputType | true
    _avg?: Payment_methodAvgAggregateInputType
    _sum?: Payment_methodSumAggregateInputType
    _min?: Payment_methodMinAggregateInputType
    _max?: Payment_methodMaxAggregateInputType
  }


  export type Payment_methodGroupByOutputType = {
    id: number
    name: string
    created_at: Date
    updated_at: Date
    _count: Payment_methodCountAggregateOutputType | null
    _avg: Payment_methodAvgAggregateOutputType | null
    _sum: Payment_methodSumAggregateOutputType | null
    _min: Payment_methodMinAggregateOutputType | null
    _max: Payment_methodMaxAggregateOutputType | null
  }

  type GetPayment_methodGroupByPayload<T extends Payment_methodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Payment_methodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Payment_methodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Payment_methodGroupByOutputType[P]>
            : GetScalarType<T[P], Payment_methodGroupByOutputType[P]>
        }
      >
    >


  export type payment_methodSelect = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    payment?: boolean | payment_method$paymentArgs
    _count?: boolean | Payment_methodCountOutputTypeArgs
  }


  export type payment_methodInclude = {
    payment?: boolean | payment_method$paymentArgs
    _count?: boolean | Payment_methodCountOutputTypeArgs
  }

  export type payment_methodGetPayload<S extends boolean | null | undefined | payment_methodArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? payment_method :
    S extends undefined ? never :
    S extends { include: any } & (payment_methodArgs | payment_methodFindManyArgs)
    ? payment_method  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'payment' ? Array < paymentGetPayload<S['include'][P]>>  :
        P extends '_count' ? Payment_methodCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (payment_methodArgs | payment_methodFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'payment' ? Array < paymentGetPayload<S['select'][P]>>  :
        P extends '_count' ? Payment_methodCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof payment_method ? payment_method[P] : never
  } 
      : payment_method


  type payment_methodCountArgs = 
    Omit<payment_methodFindManyArgs, 'select' | 'include'> & {
      select?: Payment_methodCountAggregateInputType | true
    }

  export interface payment_methodDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Payment_method that matches the filter.
     * @param {payment_methodFindUniqueArgs} args - Arguments to find a Payment_method
     * @example
     * // Get one Payment_method
     * const payment_method = await prisma.payment_method.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends payment_methodFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, payment_methodFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'payment_method'> extends True ? Prisma__payment_methodClient<payment_methodGetPayload<T>> : Prisma__payment_methodClient<payment_methodGetPayload<T> | null, null>

    /**
     * Find one Payment_method that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {payment_methodFindUniqueOrThrowArgs} args - Arguments to find a Payment_method
     * @example
     * // Get one Payment_method
     * const payment_method = await prisma.payment_method.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends payment_methodFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, payment_methodFindUniqueOrThrowArgs>
    ): Prisma__payment_methodClient<payment_methodGetPayload<T>>

    /**
     * Find the first Payment_method that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodFindFirstArgs} args - Arguments to find a Payment_method
     * @example
     * // Get one Payment_method
     * const payment_method = await prisma.payment_method.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends payment_methodFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, payment_methodFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'payment_method'> extends True ? Prisma__payment_methodClient<payment_methodGetPayload<T>> : Prisma__payment_methodClient<payment_methodGetPayload<T> | null, null>

    /**
     * Find the first Payment_method that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodFindFirstOrThrowArgs} args - Arguments to find a Payment_method
     * @example
     * // Get one Payment_method
     * const payment_method = await prisma.payment_method.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends payment_methodFindFirstOrThrowArgs>(
      args?: SelectSubset<T, payment_methodFindFirstOrThrowArgs>
    ): Prisma__payment_methodClient<payment_methodGetPayload<T>>

    /**
     * Find zero or more Payment_methods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payment_methods
     * const payment_methods = await prisma.payment_method.findMany()
     * 
     * // Get first 10 Payment_methods
     * const payment_methods = await prisma.payment_method.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payment_methodWithIdOnly = await prisma.payment_method.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends payment_methodFindManyArgs>(
      args?: SelectSubset<T, payment_methodFindManyArgs>
    ): Prisma.PrismaPromise<Array<payment_methodGetPayload<T>>>

    /**
     * Create a Payment_method.
     * @param {payment_methodCreateArgs} args - Arguments to create a Payment_method.
     * @example
     * // Create one Payment_method
     * const Payment_method = await prisma.payment_method.create({
     *   data: {
     *     // ... data to create a Payment_method
     *   }
     * })
     * 
    **/
    create<T extends payment_methodCreateArgs>(
      args: SelectSubset<T, payment_methodCreateArgs>
    ): Prisma__payment_methodClient<payment_methodGetPayload<T>>

    /**
     * Create many Payment_methods.
     *     @param {payment_methodCreateManyArgs} args - Arguments to create many Payment_methods.
     *     @example
     *     // Create many Payment_methods
     *     const payment_method = await prisma.payment_method.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends payment_methodCreateManyArgs>(
      args?: SelectSubset<T, payment_methodCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment_method.
     * @param {payment_methodDeleteArgs} args - Arguments to delete one Payment_method.
     * @example
     * // Delete one Payment_method
     * const Payment_method = await prisma.payment_method.delete({
     *   where: {
     *     // ... filter to delete one Payment_method
     *   }
     * })
     * 
    **/
    delete<T extends payment_methodDeleteArgs>(
      args: SelectSubset<T, payment_methodDeleteArgs>
    ): Prisma__payment_methodClient<payment_methodGetPayload<T>>

    /**
     * Update one Payment_method.
     * @param {payment_methodUpdateArgs} args - Arguments to update one Payment_method.
     * @example
     * // Update one Payment_method
     * const payment_method = await prisma.payment_method.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends payment_methodUpdateArgs>(
      args: SelectSubset<T, payment_methodUpdateArgs>
    ): Prisma__payment_methodClient<payment_methodGetPayload<T>>

    /**
     * Delete zero or more Payment_methods.
     * @param {payment_methodDeleteManyArgs} args - Arguments to filter Payment_methods to delete.
     * @example
     * // Delete a few Payment_methods
     * const { count } = await prisma.payment_method.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends payment_methodDeleteManyArgs>(
      args?: SelectSubset<T, payment_methodDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payment_methods
     * const payment_method = await prisma.payment_method.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends payment_methodUpdateManyArgs>(
      args: SelectSubset<T, payment_methodUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment_method.
     * @param {payment_methodUpsertArgs} args - Arguments to update or create a Payment_method.
     * @example
     * // Update or create a Payment_method
     * const payment_method = await prisma.payment_method.upsert({
     *   create: {
     *     // ... data to create a Payment_method
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment_method we want to update
     *   }
     * })
    **/
    upsert<T extends payment_methodUpsertArgs>(
      args: SelectSubset<T, payment_methodUpsertArgs>
    ): Prisma__payment_methodClient<payment_methodGetPayload<T>>

    /**
     * Count the number of Payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodCountArgs} args - Arguments to filter Payment_methods to count.
     * @example
     * // Count the number of Payment_methods
     * const count = await prisma.payment_method.count({
     *   where: {
     *     // ... the filter for the Payment_methods we want to count
     *   }
     * })
    **/
    count<T extends payment_methodCountArgs>(
      args?: Subset<T, payment_methodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Payment_methodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment_method.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Payment_methodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Payment_methodAggregateArgs>(args: Subset<T, Payment_methodAggregateArgs>): Prisma.PrismaPromise<GetPayment_methodAggregateType<T>>

    /**
     * Group by Payment_method.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Payment_methodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Payment_methodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Payment_methodGroupByArgs['orderBy'] }
        : { orderBy?: Payment_methodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Payment_methodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayment_methodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for payment_method.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__payment_methodClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    payment<T extends payment_method$paymentArgs= {}>(args?: Subset<T, payment_method$paymentArgs>): Prisma.PrismaPromise<Array<paymentGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * payment_method base type for findUnique actions
   */
  export type payment_methodFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_methodInclude | null
    /**
     * Filter, which payment_method to fetch.
     */
    where: payment_methodWhereUniqueInput
  }

  /**
   * payment_method findUnique
   */
  export interface payment_methodFindUniqueArgs extends payment_methodFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * payment_method findUniqueOrThrow
   */
  export type payment_methodFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_methodInclude | null
    /**
     * Filter, which payment_method to fetch.
     */
    where: payment_methodWhereUniqueInput
  }


  /**
   * payment_method base type for findFirst actions
   */
  export type payment_methodFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_methodInclude | null
    /**
     * Filter, which payment_method to fetch.
     */
    where?: payment_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_methods to fetch.
     */
    orderBy?: Enumerable<payment_methodOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_methods.
     */
    cursor?: payment_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_methods.
     */
    distinct?: Enumerable<Payment_methodScalarFieldEnum>
  }

  /**
   * payment_method findFirst
   */
  export interface payment_methodFindFirstArgs extends payment_methodFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * payment_method findFirstOrThrow
   */
  export type payment_methodFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_methodInclude | null
    /**
     * Filter, which payment_method to fetch.
     */
    where?: payment_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_methods to fetch.
     */
    orderBy?: Enumerable<payment_methodOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_methods.
     */
    cursor?: payment_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_methods.
     */
    distinct?: Enumerable<Payment_methodScalarFieldEnum>
  }


  /**
   * payment_method findMany
   */
  export type payment_methodFindManyArgs = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_methodInclude | null
    /**
     * Filter, which payment_methods to fetch.
     */
    where?: payment_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_methods to fetch.
     */
    orderBy?: Enumerable<payment_methodOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payment_methods.
     */
    cursor?: payment_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_methods.
     */
    skip?: number
    distinct?: Enumerable<Payment_methodScalarFieldEnum>
  }


  /**
   * payment_method create
   */
  export type payment_methodCreateArgs = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_methodInclude | null
    /**
     * The data needed to create a payment_method.
     */
    data: XOR<payment_methodCreateInput, payment_methodUncheckedCreateInput>
  }


  /**
   * payment_method createMany
   */
  export type payment_methodCreateManyArgs = {
    /**
     * The data used to create many payment_methods.
     */
    data: Enumerable<payment_methodCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * payment_method update
   */
  export type payment_methodUpdateArgs = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_methodInclude | null
    /**
     * The data needed to update a payment_method.
     */
    data: XOR<payment_methodUpdateInput, payment_methodUncheckedUpdateInput>
    /**
     * Choose, which payment_method to update.
     */
    where: payment_methodWhereUniqueInput
  }


  /**
   * payment_method updateMany
   */
  export type payment_methodUpdateManyArgs = {
    /**
     * The data used to update payment_methods.
     */
    data: XOR<payment_methodUpdateManyMutationInput, payment_methodUncheckedUpdateManyInput>
    /**
     * Filter which payment_methods to update
     */
    where?: payment_methodWhereInput
  }


  /**
   * payment_method upsert
   */
  export type payment_methodUpsertArgs = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_methodInclude | null
    /**
     * The filter to search for the payment_method to update in case it exists.
     */
    where: payment_methodWhereUniqueInput
    /**
     * In case the payment_method found by the `where` argument doesn't exist, create a new payment_method with this data.
     */
    create: XOR<payment_methodCreateInput, payment_methodUncheckedCreateInput>
    /**
     * In case the payment_method was found with the provided `where` argument, update it with this data.
     */
    update: XOR<payment_methodUpdateInput, payment_methodUncheckedUpdateInput>
  }


  /**
   * payment_method delete
   */
  export type payment_methodDeleteArgs = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_methodInclude | null
    /**
     * Filter which payment_method to delete.
     */
    where: payment_methodWhereUniqueInput
  }


  /**
   * payment_method deleteMany
   */
  export type payment_methodDeleteManyArgs = {
    /**
     * Filter which payment_methods to delete
     */
    where?: payment_methodWhereInput
  }


  /**
   * payment_method.payment
   */
  export type payment_method$paymentArgs = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: paymentInclude | null
    where?: paymentWhereInput
    orderBy?: Enumerable<paymentOrderByWithRelationInput>
    cursor?: paymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PaymentScalarFieldEnum>
  }


  /**
   * payment_method without action
   */
  export type payment_methodArgs = {
    /**
     * Select specific fields to fetch from the payment_method
     */
    select?: payment_methodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_methodInclude | null
  }



  /**
   * Model fair_date_hour_of_work
   */


  export type AggregateFair_date_hour_of_work = {
    _count: Fair_date_hour_of_workCountAggregateOutputType | null
    _avg: Fair_date_hour_of_workAvgAggregateOutputType | null
    _sum: Fair_date_hour_of_workSumAggregateOutputType | null
    _min: Fair_date_hour_of_workMinAggregateOutputType | null
    _max: Fair_date_hour_of_workMaxAggregateOutputType | null
  }

  export type Fair_date_hour_of_workAvgAggregateOutputType = {
    id: number | null
    fairId: number | null
    date_and_hour_of_workId: number | null
  }

  export type Fair_date_hour_of_workSumAggregateOutputType = {
    id: number | null
    fairId: number | null
    date_and_hour_of_workId: number | null
  }

  export type Fair_date_hour_of_workMinAggregateOutputType = {
    id: number | null
    fairId: number | null
    date_and_hour_of_workId: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Fair_date_hour_of_workMaxAggregateOutputType = {
    id: number | null
    fairId: number | null
    date_and_hour_of_workId: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Fair_date_hour_of_workCountAggregateOutputType = {
    id: number
    fairId: number
    date_and_hour_of_workId: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Fair_date_hour_of_workAvgAggregateInputType = {
    id?: true
    fairId?: true
    date_and_hour_of_workId?: true
  }

  export type Fair_date_hour_of_workSumAggregateInputType = {
    id?: true
    fairId?: true
    date_and_hour_of_workId?: true
  }

  export type Fair_date_hour_of_workMinAggregateInputType = {
    id?: true
    fairId?: true
    date_and_hour_of_workId?: true
    created_at?: true
    updated_at?: true
  }

  export type Fair_date_hour_of_workMaxAggregateInputType = {
    id?: true
    fairId?: true
    date_and_hour_of_workId?: true
    created_at?: true
    updated_at?: true
  }

  export type Fair_date_hour_of_workCountAggregateInputType = {
    id?: true
    fairId?: true
    date_and_hour_of_workId?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Fair_date_hour_of_workAggregateArgs = {
    /**
     * Filter which fair_date_hour_of_work to aggregate.
     */
    where?: fair_date_hour_of_workWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fair_date_hour_of_works to fetch.
     */
    orderBy?: Enumerable<fair_date_hour_of_workOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fair_date_hour_of_workWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fair_date_hour_of_works from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fair_date_hour_of_works.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fair_date_hour_of_works
    **/
    _count?: true | Fair_date_hour_of_workCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Fair_date_hour_of_workAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Fair_date_hour_of_workSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Fair_date_hour_of_workMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Fair_date_hour_of_workMaxAggregateInputType
  }

  export type GetFair_date_hour_of_workAggregateType<T extends Fair_date_hour_of_workAggregateArgs> = {
        [P in keyof T & keyof AggregateFair_date_hour_of_work]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFair_date_hour_of_work[P]>
      : GetScalarType<T[P], AggregateFair_date_hour_of_work[P]>
  }




  export type Fair_date_hour_of_workGroupByArgs = {
    where?: fair_date_hour_of_workWhereInput
    orderBy?: Enumerable<fair_date_hour_of_workOrderByWithAggregationInput>
    by: Fair_date_hour_of_workScalarFieldEnum[]
    having?: fair_date_hour_of_workScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Fair_date_hour_of_workCountAggregateInputType | true
    _avg?: Fair_date_hour_of_workAvgAggregateInputType
    _sum?: Fair_date_hour_of_workSumAggregateInputType
    _min?: Fair_date_hour_of_workMinAggregateInputType
    _max?: Fair_date_hour_of_workMaxAggregateInputType
  }


  export type Fair_date_hour_of_workGroupByOutputType = {
    id: number
    fairId: number
    date_and_hour_of_workId: number
    created_at: Date
    updated_at: Date
    _count: Fair_date_hour_of_workCountAggregateOutputType | null
    _avg: Fair_date_hour_of_workAvgAggregateOutputType | null
    _sum: Fair_date_hour_of_workSumAggregateOutputType | null
    _min: Fair_date_hour_of_workMinAggregateOutputType | null
    _max: Fair_date_hour_of_workMaxAggregateOutputType | null
  }

  type GetFair_date_hour_of_workGroupByPayload<T extends Fair_date_hour_of_workGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Fair_date_hour_of_workGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Fair_date_hour_of_workGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Fair_date_hour_of_workGroupByOutputType[P]>
            : GetScalarType<T[P], Fair_date_hour_of_workGroupByOutputType[P]>
        }
      >
    >


  export type fair_date_hour_of_workSelect = {
    id?: boolean
    fairId?: boolean
    date_and_hour_of_workId?: boolean
    created_at?: boolean
    updated_at?: boolean
    dates?: boolean | date_and_hour_of_workArgs
    fair?: boolean | fairArgs
  }


  export type fair_date_hour_of_workInclude = {
    dates?: boolean | date_and_hour_of_workArgs
    fair?: boolean | fairArgs
  }

  export type fair_date_hour_of_workGetPayload<S extends boolean | null | undefined | fair_date_hour_of_workArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? fair_date_hour_of_work :
    S extends undefined ? never :
    S extends { include: any } & (fair_date_hour_of_workArgs | fair_date_hour_of_workFindManyArgs)
    ? fair_date_hour_of_work  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'dates' ? date_and_hour_of_workGetPayload<S['include'][P]> :
        P extends 'fair' ? fairGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (fair_date_hour_of_workArgs | fair_date_hour_of_workFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'dates' ? date_and_hour_of_workGetPayload<S['select'][P]> :
        P extends 'fair' ? fairGetPayload<S['select'][P]> :  P extends keyof fair_date_hour_of_work ? fair_date_hour_of_work[P] : never
  } 
      : fair_date_hour_of_work


  type fair_date_hour_of_workCountArgs = 
    Omit<fair_date_hour_of_workFindManyArgs, 'select' | 'include'> & {
      select?: Fair_date_hour_of_workCountAggregateInputType | true
    }

  export interface fair_date_hour_of_workDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Fair_date_hour_of_work that matches the filter.
     * @param {fair_date_hour_of_workFindUniqueArgs} args - Arguments to find a Fair_date_hour_of_work
     * @example
     * // Get one Fair_date_hour_of_work
     * const fair_date_hour_of_work = await prisma.fair_date_hour_of_work.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends fair_date_hour_of_workFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, fair_date_hour_of_workFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'fair_date_hour_of_work'> extends True ? Prisma__fair_date_hour_of_workClient<fair_date_hour_of_workGetPayload<T>> : Prisma__fair_date_hour_of_workClient<fair_date_hour_of_workGetPayload<T> | null, null>

    /**
     * Find one Fair_date_hour_of_work that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {fair_date_hour_of_workFindUniqueOrThrowArgs} args - Arguments to find a Fair_date_hour_of_work
     * @example
     * // Get one Fair_date_hour_of_work
     * const fair_date_hour_of_work = await prisma.fair_date_hour_of_work.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends fair_date_hour_of_workFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, fair_date_hour_of_workFindUniqueOrThrowArgs>
    ): Prisma__fair_date_hour_of_workClient<fair_date_hour_of_workGetPayload<T>>

    /**
     * Find the first Fair_date_hour_of_work that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fair_date_hour_of_workFindFirstArgs} args - Arguments to find a Fair_date_hour_of_work
     * @example
     * // Get one Fair_date_hour_of_work
     * const fair_date_hour_of_work = await prisma.fair_date_hour_of_work.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends fair_date_hour_of_workFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, fair_date_hour_of_workFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'fair_date_hour_of_work'> extends True ? Prisma__fair_date_hour_of_workClient<fair_date_hour_of_workGetPayload<T>> : Prisma__fair_date_hour_of_workClient<fair_date_hour_of_workGetPayload<T> | null, null>

    /**
     * Find the first Fair_date_hour_of_work that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fair_date_hour_of_workFindFirstOrThrowArgs} args - Arguments to find a Fair_date_hour_of_work
     * @example
     * // Get one Fair_date_hour_of_work
     * const fair_date_hour_of_work = await prisma.fair_date_hour_of_work.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends fair_date_hour_of_workFindFirstOrThrowArgs>(
      args?: SelectSubset<T, fair_date_hour_of_workFindFirstOrThrowArgs>
    ): Prisma__fair_date_hour_of_workClient<fair_date_hour_of_workGetPayload<T>>

    /**
     * Find zero or more Fair_date_hour_of_works that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fair_date_hour_of_workFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fair_date_hour_of_works
     * const fair_date_hour_of_works = await prisma.fair_date_hour_of_work.findMany()
     * 
     * // Get first 10 Fair_date_hour_of_works
     * const fair_date_hour_of_works = await prisma.fair_date_hour_of_work.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fair_date_hour_of_workWithIdOnly = await prisma.fair_date_hour_of_work.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends fair_date_hour_of_workFindManyArgs>(
      args?: SelectSubset<T, fair_date_hour_of_workFindManyArgs>
    ): Prisma.PrismaPromise<Array<fair_date_hour_of_workGetPayload<T>>>

    /**
     * Create a Fair_date_hour_of_work.
     * @param {fair_date_hour_of_workCreateArgs} args - Arguments to create a Fair_date_hour_of_work.
     * @example
     * // Create one Fair_date_hour_of_work
     * const Fair_date_hour_of_work = await prisma.fair_date_hour_of_work.create({
     *   data: {
     *     // ... data to create a Fair_date_hour_of_work
     *   }
     * })
     * 
    **/
    create<T extends fair_date_hour_of_workCreateArgs>(
      args: SelectSubset<T, fair_date_hour_of_workCreateArgs>
    ): Prisma__fair_date_hour_of_workClient<fair_date_hour_of_workGetPayload<T>>

    /**
     * Create many Fair_date_hour_of_works.
     *     @param {fair_date_hour_of_workCreateManyArgs} args - Arguments to create many Fair_date_hour_of_works.
     *     @example
     *     // Create many Fair_date_hour_of_works
     *     const fair_date_hour_of_work = await prisma.fair_date_hour_of_work.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends fair_date_hour_of_workCreateManyArgs>(
      args?: SelectSubset<T, fair_date_hour_of_workCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Fair_date_hour_of_work.
     * @param {fair_date_hour_of_workDeleteArgs} args - Arguments to delete one Fair_date_hour_of_work.
     * @example
     * // Delete one Fair_date_hour_of_work
     * const Fair_date_hour_of_work = await prisma.fair_date_hour_of_work.delete({
     *   where: {
     *     // ... filter to delete one Fair_date_hour_of_work
     *   }
     * })
     * 
    **/
    delete<T extends fair_date_hour_of_workDeleteArgs>(
      args: SelectSubset<T, fair_date_hour_of_workDeleteArgs>
    ): Prisma__fair_date_hour_of_workClient<fair_date_hour_of_workGetPayload<T>>

    /**
     * Update one Fair_date_hour_of_work.
     * @param {fair_date_hour_of_workUpdateArgs} args - Arguments to update one Fair_date_hour_of_work.
     * @example
     * // Update one Fair_date_hour_of_work
     * const fair_date_hour_of_work = await prisma.fair_date_hour_of_work.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends fair_date_hour_of_workUpdateArgs>(
      args: SelectSubset<T, fair_date_hour_of_workUpdateArgs>
    ): Prisma__fair_date_hour_of_workClient<fair_date_hour_of_workGetPayload<T>>

    /**
     * Delete zero or more Fair_date_hour_of_works.
     * @param {fair_date_hour_of_workDeleteManyArgs} args - Arguments to filter Fair_date_hour_of_works to delete.
     * @example
     * // Delete a few Fair_date_hour_of_works
     * const { count } = await prisma.fair_date_hour_of_work.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends fair_date_hour_of_workDeleteManyArgs>(
      args?: SelectSubset<T, fair_date_hour_of_workDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fair_date_hour_of_works.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fair_date_hour_of_workUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fair_date_hour_of_works
     * const fair_date_hour_of_work = await prisma.fair_date_hour_of_work.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends fair_date_hour_of_workUpdateManyArgs>(
      args: SelectSubset<T, fair_date_hour_of_workUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fair_date_hour_of_work.
     * @param {fair_date_hour_of_workUpsertArgs} args - Arguments to update or create a Fair_date_hour_of_work.
     * @example
     * // Update or create a Fair_date_hour_of_work
     * const fair_date_hour_of_work = await prisma.fair_date_hour_of_work.upsert({
     *   create: {
     *     // ... data to create a Fair_date_hour_of_work
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fair_date_hour_of_work we want to update
     *   }
     * })
    **/
    upsert<T extends fair_date_hour_of_workUpsertArgs>(
      args: SelectSubset<T, fair_date_hour_of_workUpsertArgs>
    ): Prisma__fair_date_hour_of_workClient<fair_date_hour_of_workGetPayload<T>>

    /**
     * Count the number of Fair_date_hour_of_works.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fair_date_hour_of_workCountArgs} args - Arguments to filter Fair_date_hour_of_works to count.
     * @example
     * // Count the number of Fair_date_hour_of_works
     * const count = await prisma.fair_date_hour_of_work.count({
     *   where: {
     *     // ... the filter for the Fair_date_hour_of_works we want to count
     *   }
     * })
    **/
    count<T extends fair_date_hour_of_workCountArgs>(
      args?: Subset<T, fair_date_hour_of_workCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Fair_date_hour_of_workCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fair_date_hour_of_work.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fair_date_hour_of_workAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Fair_date_hour_of_workAggregateArgs>(args: Subset<T, Fair_date_hour_of_workAggregateArgs>): Prisma.PrismaPromise<GetFair_date_hour_of_workAggregateType<T>>

    /**
     * Group by Fair_date_hour_of_work.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fair_date_hour_of_workGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Fair_date_hour_of_workGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Fair_date_hour_of_workGroupByArgs['orderBy'] }
        : { orderBy?: Fair_date_hour_of_workGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Fair_date_hour_of_workGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFair_date_hour_of_workGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for fair_date_hour_of_work.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__fair_date_hour_of_workClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    dates<T extends date_and_hour_of_workArgs= {}>(args?: Subset<T, date_and_hour_of_workArgs>): Prisma__date_and_hour_of_workClient<date_and_hour_of_workGetPayload<T> | Null>;

    fair<T extends fairArgs= {}>(args?: Subset<T, fairArgs>): Prisma__fairClient<fairGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * fair_date_hour_of_work base type for findUnique actions
   */
  export type fair_date_hour_of_workFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the fair_date_hour_of_work
     */
    select?: fair_date_hour_of_workSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fair_date_hour_of_workInclude | null
    /**
     * Filter, which fair_date_hour_of_work to fetch.
     */
    where: fair_date_hour_of_workWhereUniqueInput
  }

  /**
   * fair_date_hour_of_work findUnique
   */
  export interface fair_date_hour_of_workFindUniqueArgs extends fair_date_hour_of_workFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fair_date_hour_of_work findUniqueOrThrow
   */
  export type fair_date_hour_of_workFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the fair_date_hour_of_work
     */
    select?: fair_date_hour_of_workSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fair_date_hour_of_workInclude | null
    /**
     * Filter, which fair_date_hour_of_work to fetch.
     */
    where: fair_date_hour_of_workWhereUniqueInput
  }


  /**
   * fair_date_hour_of_work base type for findFirst actions
   */
  export type fair_date_hour_of_workFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the fair_date_hour_of_work
     */
    select?: fair_date_hour_of_workSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fair_date_hour_of_workInclude | null
    /**
     * Filter, which fair_date_hour_of_work to fetch.
     */
    where?: fair_date_hour_of_workWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fair_date_hour_of_works to fetch.
     */
    orderBy?: Enumerable<fair_date_hour_of_workOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fair_date_hour_of_works.
     */
    cursor?: fair_date_hour_of_workWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fair_date_hour_of_works from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fair_date_hour_of_works.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fair_date_hour_of_works.
     */
    distinct?: Enumerable<Fair_date_hour_of_workScalarFieldEnum>
  }

  /**
   * fair_date_hour_of_work findFirst
   */
  export interface fair_date_hour_of_workFindFirstArgs extends fair_date_hour_of_workFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fair_date_hour_of_work findFirstOrThrow
   */
  export type fair_date_hour_of_workFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the fair_date_hour_of_work
     */
    select?: fair_date_hour_of_workSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fair_date_hour_of_workInclude | null
    /**
     * Filter, which fair_date_hour_of_work to fetch.
     */
    where?: fair_date_hour_of_workWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fair_date_hour_of_works to fetch.
     */
    orderBy?: Enumerable<fair_date_hour_of_workOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fair_date_hour_of_works.
     */
    cursor?: fair_date_hour_of_workWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fair_date_hour_of_works from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fair_date_hour_of_works.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fair_date_hour_of_works.
     */
    distinct?: Enumerable<Fair_date_hour_of_workScalarFieldEnum>
  }


  /**
   * fair_date_hour_of_work findMany
   */
  export type fair_date_hour_of_workFindManyArgs = {
    /**
     * Select specific fields to fetch from the fair_date_hour_of_work
     */
    select?: fair_date_hour_of_workSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fair_date_hour_of_workInclude | null
    /**
     * Filter, which fair_date_hour_of_works to fetch.
     */
    where?: fair_date_hour_of_workWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fair_date_hour_of_works to fetch.
     */
    orderBy?: Enumerable<fair_date_hour_of_workOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fair_date_hour_of_works.
     */
    cursor?: fair_date_hour_of_workWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fair_date_hour_of_works from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fair_date_hour_of_works.
     */
    skip?: number
    distinct?: Enumerable<Fair_date_hour_of_workScalarFieldEnum>
  }


  /**
   * fair_date_hour_of_work create
   */
  export type fair_date_hour_of_workCreateArgs = {
    /**
     * Select specific fields to fetch from the fair_date_hour_of_work
     */
    select?: fair_date_hour_of_workSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fair_date_hour_of_workInclude | null
    /**
     * The data needed to create a fair_date_hour_of_work.
     */
    data: XOR<fair_date_hour_of_workCreateInput, fair_date_hour_of_workUncheckedCreateInput>
  }


  /**
   * fair_date_hour_of_work createMany
   */
  export type fair_date_hour_of_workCreateManyArgs = {
    /**
     * The data used to create many fair_date_hour_of_works.
     */
    data: Enumerable<fair_date_hour_of_workCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * fair_date_hour_of_work update
   */
  export type fair_date_hour_of_workUpdateArgs = {
    /**
     * Select specific fields to fetch from the fair_date_hour_of_work
     */
    select?: fair_date_hour_of_workSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fair_date_hour_of_workInclude | null
    /**
     * The data needed to update a fair_date_hour_of_work.
     */
    data: XOR<fair_date_hour_of_workUpdateInput, fair_date_hour_of_workUncheckedUpdateInput>
    /**
     * Choose, which fair_date_hour_of_work to update.
     */
    where: fair_date_hour_of_workWhereUniqueInput
  }


  /**
   * fair_date_hour_of_work updateMany
   */
  export type fair_date_hour_of_workUpdateManyArgs = {
    /**
     * The data used to update fair_date_hour_of_works.
     */
    data: XOR<fair_date_hour_of_workUpdateManyMutationInput, fair_date_hour_of_workUncheckedUpdateManyInput>
    /**
     * Filter which fair_date_hour_of_works to update
     */
    where?: fair_date_hour_of_workWhereInput
  }


  /**
   * fair_date_hour_of_work upsert
   */
  export type fair_date_hour_of_workUpsertArgs = {
    /**
     * Select specific fields to fetch from the fair_date_hour_of_work
     */
    select?: fair_date_hour_of_workSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fair_date_hour_of_workInclude | null
    /**
     * The filter to search for the fair_date_hour_of_work to update in case it exists.
     */
    where: fair_date_hour_of_workWhereUniqueInput
    /**
     * In case the fair_date_hour_of_work found by the `where` argument doesn't exist, create a new fair_date_hour_of_work with this data.
     */
    create: XOR<fair_date_hour_of_workCreateInput, fair_date_hour_of_workUncheckedCreateInput>
    /**
     * In case the fair_date_hour_of_work was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fair_date_hour_of_workUpdateInput, fair_date_hour_of_workUncheckedUpdateInput>
  }


  /**
   * fair_date_hour_of_work delete
   */
  export type fair_date_hour_of_workDeleteArgs = {
    /**
     * Select specific fields to fetch from the fair_date_hour_of_work
     */
    select?: fair_date_hour_of_workSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fair_date_hour_of_workInclude | null
    /**
     * Filter which fair_date_hour_of_work to delete.
     */
    where: fair_date_hour_of_workWhereUniqueInput
  }


  /**
   * fair_date_hour_of_work deleteMany
   */
  export type fair_date_hour_of_workDeleteManyArgs = {
    /**
     * Filter which fair_date_hour_of_works to delete
     */
    where?: fair_date_hour_of_workWhereInput
  }


  /**
   * fair_date_hour_of_work without action
   */
  export type fair_date_hour_of_workArgs = {
    /**
     * Select specific fields to fetch from the fair_date_hour_of_work
     */
    select?: fair_date_hour_of_workSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fair_date_hour_of_workInclude | null
  }



  /**
   * Model date_and_hour_of_work
   */


  export type AggregateDate_and_hour_of_work = {
    _count: Date_and_hour_of_workCountAggregateOutputType | null
    _avg: Date_and_hour_of_workAvgAggregateOutputType | null
    _sum: Date_and_hour_of_workSumAggregateOutputType | null
    _min: Date_and_hour_of_workMinAggregateOutputType | null
    _max: Date_and_hour_of_workMaxAggregateOutputType | null
  }

  export type Date_and_hour_of_workAvgAggregateOutputType = {
    id: number | null
    day_of_weekId: number | null
  }

  export type Date_and_hour_of_workSumAggregateOutputType = {
    id: number | null
    day_of_weekId: number | null
  }

  export type Date_and_hour_of_workMinAggregateOutputType = {
    id: number | null
    open_datetime: Date | null
    close_datetime: Date | null
    created_at: Date | null
    updated_at: Date | null
    day_of_weekId: number | null
  }

  export type Date_and_hour_of_workMaxAggregateOutputType = {
    id: number | null
    open_datetime: Date | null
    close_datetime: Date | null
    created_at: Date | null
    updated_at: Date | null
    day_of_weekId: number | null
  }

  export type Date_and_hour_of_workCountAggregateOutputType = {
    id: number
    open_datetime: number
    close_datetime: number
    created_at: number
    updated_at: number
    day_of_weekId: number
    _all: number
  }


  export type Date_and_hour_of_workAvgAggregateInputType = {
    id?: true
    day_of_weekId?: true
  }

  export type Date_and_hour_of_workSumAggregateInputType = {
    id?: true
    day_of_weekId?: true
  }

  export type Date_and_hour_of_workMinAggregateInputType = {
    id?: true
    open_datetime?: true
    close_datetime?: true
    created_at?: true
    updated_at?: true
    day_of_weekId?: true
  }

  export type Date_and_hour_of_workMaxAggregateInputType = {
    id?: true
    open_datetime?: true
    close_datetime?: true
    created_at?: true
    updated_at?: true
    day_of_weekId?: true
  }

  export type Date_and_hour_of_workCountAggregateInputType = {
    id?: true
    open_datetime?: true
    close_datetime?: true
    created_at?: true
    updated_at?: true
    day_of_weekId?: true
    _all?: true
  }

  export type Date_and_hour_of_workAggregateArgs = {
    /**
     * Filter which date_and_hour_of_work to aggregate.
     */
    where?: date_and_hour_of_workWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of date_and_hour_of_works to fetch.
     */
    orderBy?: Enumerable<date_and_hour_of_workOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: date_and_hour_of_workWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` date_and_hour_of_works from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` date_and_hour_of_works.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned date_and_hour_of_works
    **/
    _count?: true | Date_and_hour_of_workCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Date_and_hour_of_workAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Date_and_hour_of_workSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Date_and_hour_of_workMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Date_and_hour_of_workMaxAggregateInputType
  }

  export type GetDate_and_hour_of_workAggregateType<T extends Date_and_hour_of_workAggregateArgs> = {
        [P in keyof T & keyof AggregateDate_and_hour_of_work]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDate_and_hour_of_work[P]>
      : GetScalarType<T[P], AggregateDate_and_hour_of_work[P]>
  }




  export type Date_and_hour_of_workGroupByArgs = {
    where?: date_and_hour_of_workWhereInput
    orderBy?: Enumerable<date_and_hour_of_workOrderByWithAggregationInput>
    by: Date_and_hour_of_workScalarFieldEnum[]
    having?: date_and_hour_of_workScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Date_and_hour_of_workCountAggregateInputType | true
    _avg?: Date_and_hour_of_workAvgAggregateInputType
    _sum?: Date_and_hour_of_workSumAggregateInputType
    _min?: Date_and_hour_of_workMinAggregateInputType
    _max?: Date_and_hour_of_workMaxAggregateInputType
  }


  export type Date_and_hour_of_workGroupByOutputType = {
    id: number
    open_datetime: Date
    close_datetime: Date
    created_at: Date
    updated_at: Date
    day_of_weekId: number
    _count: Date_and_hour_of_workCountAggregateOutputType | null
    _avg: Date_and_hour_of_workAvgAggregateOutputType | null
    _sum: Date_and_hour_of_workSumAggregateOutputType | null
    _min: Date_and_hour_of_workMinAggregateOutputType | null
    _max: Date_and_hour_of_workMaxAggregateOutputType | null
  }

  type GetDate_and_hour_of_workGroupByPayload<T extends Date_and_hour_of_workGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Date_and_hour_of_workGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Date_and_hour_of_workGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Date_and_hour_of_workGroupByOutputType[P]>
            : GetScalarType<T[P], Date_and_hour_of_workGroupByOutputType[P]>
        }
      >
    >


  export type date_and_hour_of_workSelect = {
    id?: boolean
    open_datetime?: boolean
    close_datetime?: boolean
    created_at?: boolean
    updated_at?: boolean
    day_of_weekId?: boolean
    day_of_week?: boolean | day_of_weekArgs
    fair_date_hour_of_work?: boolean | date_and_hour_of_work$fair_date_hour_of_workArgs
    _count?: boolean | Date_and_hour_of_workCountOutputTypeArgs
  }


  export type date_and_hour_of_workInclude = {
    day_of_week?: boolean | day_of_weekArgs
    fair_date_hour_of_work?: boolean | date_and_hour_of_work$fair_date_hour_of_workArgs
    _count?: boolean | Date_and_hour_of_workCountOutputTypeArgs
  }

  export type date_and_hour_of_workGetPayload<S extends boolean | null | undefined | date_and_hour_of_workArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? date_and_hour_of_work :
    S extends undefined ? never :
    S extends { include: any } & (date_and_hour_of_workArgs | date_and_hour_of_workFindManyArgs)
    ? date_and_hour_of_work  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'day_of_week' ? day_of_weekGetPayload<S['include'][P]> :
        P extends 'fair_date_hour_of_work' ? Array < fair_date_hour_of_workGetPayload<S['include'][P]>>  :
        P extends '_count' ? Date_and_hour_of_workCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (date_and_hour_of_workArgs | date_and_hour_of_workFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'day_of_week' ? day_of_weekGetPayload<S['select'][P]> :
        P extends 'fair_date_hour_of_work' ? Array < fair_date_hour_of_workGetPayload<S['select'][P]>>  :
        P extends '_count' ? Date_and_hour_of_workCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof date_and_hour_of_work ? date_and_hour_of_work[P] : never
  } 
      : date_and_hour_of_work


  type date_and_hour_of_workCountArgs = 
    Omit<date_and_hour_of_workFindManyArgs, 'select' | 'include'> & {
      select?: Date_and_hour_of_workCountAggregateInputType | true
    }

  export interface date_and_hour_of_workDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Date_and_hour_of_work that matches the filter.
     * @param {date_and_hour_of_workFindUniqueArgs} args - Arguments to find a Date_and_hour_of_work
     * @example
     * // Get one Date_and_hour_of_work
     * const date_and_hour_of_work = await prisma.date_and_hour_of_work.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends date_and_hour_of_workFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, date_and_hour_of_workFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'date_and_hour_of_work'> extends True ? Prisma__date_and_hour_of_workClient<date_and_hour_of_workGetPayload<T>> : Prisma__date_and_hour_of_workClient<date_and_hour_of_workGetPayload<T> | null, null>

    /**
     * Find one Date_and_hour_of_work that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {date_and_hour_of_workFindUniqueOrThrowArgs} args - Arguments to find a Date_and_hour_of_work
     * @example
     * // Get one Date_and_hour_of_work
     * const date_and_hour_of_work = await prisma.date_and_hour_of_work.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends date_and_hour_of_workFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, date_and_hour_of_workFindUniqueOrThrowArgs>
    ): Prisma__date_and_hour_of_workClient<date_and_hour_of_workGetPayload<T>>

    /**
     * Find the first Date_and_hour_of_work that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {date_and_hour_of_workFindFirstArgs} args - Arguments to find a Date_and_hour_of_work
     * @example
     * // Get one Date_and_hour_of_work
     * const date_and_hour_of_work = await prisma.date_and_hour_of_work.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends date_and_hour_of_workFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, date_and_hour_of_workFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'date_and_hour_of_work'> extends True ? Prisma__date_and_hour_of_workClient<date_and_hour_of_workGetPayload<T>> : Prisma__date_and_hour_of_workClient<date_and_hour_of_workGetPayload<T> | null, null>

    /**
     * Find the first Date_and_hour_of_work that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {date_and_hour_of_workFindFirstOrThrowArgs} args - Arguments to find a Date_and_hour_of_work
     * @example
     * // Get one Date_and_hour_of_work
     * const date_and_hour_of_work = await prisma.date_and_hour_of_work.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends date_and_hour_of_workFindFirstOrThrowArgs>(
      args?: SelectSubset<T, date_and_hour_of_workFindFirstOrThrowArgs>
    ): Prisma__date_and_hour_of_workClient<date_and_hour_of_workGetPayload<T>>

    /**
     * Find zero or more Date_and_hour_of_works that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {date_and_hour_of_workFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Date_and_hour_of_works
     * const date_and_hour_of_works = await prisma.date_and_hour_of_work.findMany()
     * 
     * // Get first 10 Date_and_hour_of_works
     * const date_and_hour_of_works = await prisma.date_and_hour_of_work.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const date_and_hour_of_workWithIdOnly = await prisma.date_and_hour_of_work.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends date_and_hour_of_workFindManyArgs>(
      args?: SelectSubset<T, date_and_hour_of_workFindManyArgs>
    ): Prisma.PrismaPromise<Array<date_and_hour_of_workGetPayload<T>>>

    /**
     * Create a Date_and_hour_of_work.
     * @param {date_and_hour_of_workCreateArgs} args - Arguments to create a Date_and_hour_of_work.
     * @example
     * // Create one Date_and_hour_of_work
     * const Date_and_hour_of_work = await prisma.date_and_hour_of_work.create({
     *   data: {
     *     // ... data to create a Date_and_hour_of_work
     *   }
     * })
     * 
    **/
    create<T extends date_and_hour_of_workCreateArgs>(
      args: SelectSubset<T, date_and_hour_of_workCreateArgs>
    ): Prisma__date_and_hour_of_workClient<date_and_hour_of_workGetPayload<T>>

    /**
     * Create many Date_and_hour_of_works.
     *     @param {date_and_hour_of_workCreateManyArgs} args - Arguments to create many Date_and_hour_of_works.
     *     @example
     *     // Create many Date_and_hour_of_works
     *     const date_and_hour_of_work = await prisma.date_and_hour_of_work.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends date_and_hour_of_workCreateManyArgs>(
      args?: SelectSubset<T, date_and_hour_of_workCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Date_and_hour_of_work.
     * @param {date_and_hour_of_workDeleteArgs} args - Arguments to delete one Date_and_hour_of_work.
     * @example
     * // Delete one Date_and_hour_of_work
     * const Date_and_hour_of_work = await prisma.date_and_hour_of_work.delete({
     *   where: {
     *     // ... filter to delete one Date_and_hour_of_work
     *   }
     * })
     * 
    **/
    delete<T extends date_and_hour_of_workDeleteArgs>(
      args: SelectSubset<T, date_and_hour_of_workDeleteArgs>
    ): Prisma__date_and_hour_of_workClient<date_and_hour_of_workGetPayload<T>>

    /**
     * Update one Date_and_hour_of_work.
     * @param {date_and_hour_of_workUpdateArgs} args - Arguments to update one Date_and_hour_of_work.
     * @example
     * // Update one Date_and_hour_of_work
     * const date_and_hour_of_work = await prisma.date_and_hour_of_work.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends date_and_hour_of_workUpdateArgs>(
      args: SelectSubset<T, date_and_hour_of_workUpdateArgs>
    ): Prisma__date_and_hour_of_workClient<date_and_hour_of_workGetPayload<T>>

    /**
     * Delete zero or more Date_and_hour_of_works.
     * @param {date_and_hour_of_workDeleteManyArgs} args - Arguments to filter Date_and_hour_of_works to delete.
     * @example
     * // Delete a few Date_and_hour_of_works
     * const { count } = await prisma.date_and_hour_of_work.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends date_and_hour_of_workDeleteManyArgs>(
      args?: SelectSubset<T, date_and_hour_of_workDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Date_and_hour_of_works.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {date_and_hour_of_workUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Date_and_hour_of_works
     * const date_and_hour_of_work = await prisma.date_and_hour_of_work.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends date_and_hour_of_workUpdateManyArgs>(
      args: SelectSubset<T, date_and_hour_of_workUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Date_and_hour_of_work.
     * @param {date_and_hour_of_workUpsertArgs} args - Arguments to update or create a Date_and_hour_of_work.
     * @example
     * // Update or create a Date_and_hour_of_work
     * const date_and_hour_of_work = await prisma.date_and_hour_of_work.upsert({
     *   create: {
     *     // ... data to create a Date_and_hour_of_work
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Date_and_hour_of_work we want to update
     *   }
     * })
    **/
    upsert<T extends date_and_hour_of_workUpsertArgs>(
      args: SelectSubset<T, date_and_hour_of_workUpsertArgs>
    ): Prisma__date_and_hour_of_workClient<date_and_hour_of_workGetPayload<T>>

    /**
     * Count the number of Date_and_hour_of_works.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {date_and_hour_of_workCountArgs} args - Arguments to filter Date_and_hour_of_works to count.
     * @example
     * // Count the number of Date_and_hour_of_works
     * const count = await prisma.date_and_hour_of_work.count({
     *   where: {
     *     // ... the filter for the Date_and_hour_of_works we want to count
     *   }
     * })
    **/
    count<T extends date_and_hour_of_workCountArgs>(
      args?: Subset<T, date_and_hour_of_workCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Date_and_hour_of_workCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Date_and_hour_of_work.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Date_and_hour_of_workAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Date_and_hour_of_workAggregateArgs>(args: Subset<T, Date_and_hour_of_workAggregateArgs>): Prisma.PrismaPromise<GetDate_and_hour_of_workAggregateType<T>>

    /**
     * Group by Date_and_hour_of_work.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Date_and_hour_of_workGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Date_and_hour_of_workGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Date_and_hour_of_workGroupByArgs['orderBy'] }
        : { orderBy?: Date_and_hour_of_workGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Date_and_hour_of_workGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDate_and_hour_of_workGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for date_and_hour_of_work.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__date_and_hour_of_workClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    day_of_week<T extends day_of_weekArgs= {}>(args?: Subset<T, day_of_weekArgs>): Prisma__day_of_weekClient<day_of_weekGetPayload<T> | Null>;

    fair_date_hour_of_work<T extends date_and_hour_of_work$fair_date_hour_of_workArgs= {}>(args?: Subset<T, date_and_hour_of_work$fair_date_hour_of_workArgs>): Prisma.PrismaPromise<Array<fair_date_hour_of_workGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * date_and_hour_of_work base type for findUnique actions
   */
  export type date_and_hour_of_workFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the date_and_hour_of_work
     */
    select?: date_and_hour_of_workSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: date_and_hour_of_workInclude | null
    /**
     * Filter, which date_and_hour_of_work to fetch.
     */
    where: date_and_hour_of_workWhereUniqueInput
  }

  /**
   * date_and_hour_of_work findUnique
   */
  export interface date_and_hour_of_workFindUniqueArgs extends date_and_hour_of_workFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * date_and_hour_of_work findUniqueOrThrow
   */
  export type date_and_hour_of_workFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the date_and_hour_of_work
     */
    select?: date_and_hour_of_workSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: date_and_hour_of_workInclude | null
    /**
     * Filter, which date_and_hour_of_work to fetch.
     */
    where: date_and_hour_of_workWhereUniqueInput
  }


  /**
   * date_and_hour_of_work base type for findFirst actions
   */
  export type date_and_hour_of_workFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the date_and_hour_of_work
     */
    select?: date_and_hour_of_workSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: date_and_hour_of_workInclude | null
    /**
     * Filter, which date_and_hour_of_work to fetch.
     */
    where?: date_and_hour_of_workWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of date_and_hour_of_works to fetch.
     */
    orderBy?: Enumerable<date_and_hour_of_workOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for date_and_hour_of_works.
     */
    cursor?: date_and_hour_of_workWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` date_and_hour_of_works from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` date_and_hour_of_works.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of date_and_hour_of_works.
     */
    distinct?: Enumerable<Date_and_hour_of_workScalarFieldEnum>
  }

  /**
   * date_and_hour_of_work findFirst
   */
  export interface date_and_hour_of_workFindFirstArgs extends date_and_hour_of_workFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * date_and_hour_of_work findFirstOrThrow
   */
  export type date_and_hour_of_workFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the date_and_hour_of_work
     */
    select?: date_and_hour_of_workSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: date_and_hour_of_workInclude | null
    /**
     * Filter, which date_and_hour_of_work to fetch.
     */
    where?: date_and_hour_of_workWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of date_and_hour_of_works to fetch.
     */
    orderBy?: Enumerable<date_and_hour_of_workOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for date_and_hour_of_works.
     */
    cursor?: date_and_hour_of_workWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` date_and_hour_of_works from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` date_and_hour_of_works.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of date_and_hour_of_works.
     */
    distinct?: Enumerable<Date_and_hour_of_workScalarFieldEnum>
  }


  /**
   * date_and_hour_of_work findMany
   */
  export type date_and_hour_of_workFindManyArgs = {
    /**
     * Select specific fields to fetch from the date_and_hour_of_work
     */
    select?: date_and_hour_of_workSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: date_and_hour_of_workInclude | null
    /**
     * Filter, which date_and_hour_of_works to fetch.
     */
    where?: date_and_hour_of_workWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of date_and_hour_of_works to fetch.
     */
    orderBy?: Enumerable<date_and_hour_of_workOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing date_and_hour_of_works.
     */
    cursor?: date_and_hour_of_workWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` date_and_hour_of_works from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` date_and_hour_of_works.
     */
    skip?: number
    distinct?: Enumerable<Date_and_hour_of_workScalarFieldEnum>
  }


  /**
   * date_and_hour_of_work create
   */
  export type date_and_hour_of_workCreateArgs = {
    /**
     * Select specific fields to fetch from the date_and_hour_of_work
     */
    select?: date_and_hour_of_workSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: date_and_hour_of_workInclude | null
    /**
     * The data needed to create a date_and_hour_of_work.
     */
    data: XOR<date_and_hour_of_workCreateInput, date_and_hour_of_workUncheckedCreateInput>
  }


  /**
   * date_and_hour_of_work createMany
   */
  export type date_and_hour_of_workCreateManyArgs = {
    /**
     * The data used to create many date_and_hour_of_works.
     */
    data: Enumerable<date_and_hour_of_workCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * date_and_hour_of_work update
   */
  export type date_and_hour_of_workUpdateArgs = {
    /**
     * Select specific fields to fetch from the date_and_hour_of_work
     */
    select?: date_and_hour_of_workSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: date_and_hour_of_workInclude | null
    /**
     * The data needed to update a date_and_hour_of_work.
     */
    data: XOR<date_and_hour_of_workUpdateInput, date_and_hour_of_workUncheckedUpdateInput>
    /**
     * Choose, which date_and_hour_of_work to update.
     */
    where: date_and_hour_of_workWhereUniqueInput
  }


  /**
   * date_and_hour_of_work updateMany
   */
  export type date_and_hour_of_workUpdateManyArgs = {
    /**
     * The data used to update date_and_hour_of_works.
     */
    data: XOR<date_and_hour_of_workUpdateManyMutationInput, date_and_hour_of_workUncheckedUpdateManyInput>
    /**
     * Filter which date_and_hour_of_works to update
     */
    where?: date_and_hour_of_workWhereInput
  }


  /**
   * date_and_hour_of_work upsert
   */
  export type date_and_hour_of_workUpsertArgs = {
    /**
     * Select specific fields to fetch from the date_and_hour_of_work
     */
    select?: date_and_hour_of_workSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: date_and_hour_of_workInclude | null
    /**
     * The filter to search for the date_and_hour_of_work to update in case it exists.
     */
    where: date_and_hour_of_workWhereUniqueInput
    /**
     * In case the date_and_hour_of_work found by the `where` argument doesn't exist, create a new date_and_hour_of_work with this data.
     */
    create: XOR<date_and_hour_of_workCreateInput, date_and_hour_of_workUncheckedCreateInput>
    /**
     * In case the date_and_hour_of_work was found with the provided `where` argument, update it with this data.
     */
    update: XOR<date_and_hour_of_workUpdateInput, date_and_hour_of_workUncheckedUpdateInput>
  }


  /**
   * date_and_hour_of_work delete
   */
  export type date_and_hour_of_workDeleteArgs = {
    /**
     * Select specific fields to fetch from the date_and_hour_of_work
     */
    select?: date_and_hour_of_workSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: date_and_hour_of_workInclude | null
    /**
     * Filter which date_and_hour_of_work to delete.
     */
    where: date_and_hour_of_workWhereUniqueInput
  }


  /**
   * date_and_hour_of_work deleteMany
   */
  export type date_and_hour_of_workDeleteManyArgs = {
    /**
     * Filter which date_and_hour_of_works to delete
     */
    where?: date_and_hour_of_workWhereInput
  }


  /**
   * date_and_hour_of_work.fair_date_hour_of_work
   */
  export type date_and_hour_of_work$fair_date_hour_of_workArgs = {
    /**
     * Select specific fields to fetch from the fair_date_hour_of_work
     */
    select?: fair_date_hour_of_workSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fair_date_hour_of_workInclude | null
    where?: fair_date_hour_of_workWhereInput
    orderBy?: Enumerable<fair_date_hour_of_workOrderByWithRelationInput>
    cursor?: fair_date_hour_of_workWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Fair_date_hour_of_workScalarFieldEnum>
  }


  /**
   * date_and_hour_of_work without action
   */
  export type date_and_hour_of_workArgs = {
    /**
     * Select specific fields to fetch from the date_and_hour_of_work
     */
    select?: date_and_hour_of_workSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: date_and_hour_of_workInclude | null
  }



  /**
   * Model day_of_week
   */


  export type AggregateDay_of_week = {
    _count: Day_of_weekCountAggregateOutputType | null
    _avg: Day_of_weekAvgAggregateOutputType | null
    _sum: Day_of_weekSumAggregateOutputType | null
    _min: Day_of_weekMinAggregateOutputType | null
    _max: Day_of_weekMaxAggregateOutputType | null
  }

  export type Day_of_weekAvgAggregateOutputType = {
    id: number | null
  }

  export type Day_of_weekSumAggregateOutputType = {
    id: number | null
  }

  export type Day_of_weekMinAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Day_of_weekMaxAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Day_of_weekCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Day_of_weekAvgAggregateInputType = {
    id?: true
  }

  export type Day_of_weekSumAggregateInputType = {
    id?: true
  }

  export type Day_of_weekMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type Day_of_weekMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type Day_of_weekCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Day_of_weekAggregateArgs = {
    /**
     * Filter which day_of_week to aggregate.
     */
    where?: day_of_weekWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of day_of_weeks to fetch.
     */
    orderBy?: Enumerable<day_of_weekOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: day_of_weekWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` day_of_weeks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` day_of_weeks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned day_of_weeks
    **/
    _count?: true | Day_of_weekCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Day_of_weekAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Day_of_weekSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Day_of_weekMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Day_of_weekMaxAggregateInputType
  }

  export type GetDay_of_weekAggregateType<T extends Day_of_weekAggregateArgs> = {
        [P in keyof T & keyof AggregateDay_of_week]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDay_of_week[P]>
      : GetScalarType<T[P], AggregateDay_of_week[P]>
  }




  export type Day_of_weekGroupByArgs = {
    where?: day_of_weekWhereInput
    orderBy?: Enumerable<day_of_weekOrderByWithAggregationInput>
    by: Day_of_weekScalarFieldEnum[]
    having?: day_of_weekScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Day_of_weekCountAggregateInputType | true
    _avg?: Day_of_weekAvgAggregateInputType
    _sum?: Day_of_weekSumAggregateInputType
    _min?: Day_of_weekMinAggregateInputType
    _max?: Day_of_weekMaxAggregateInputType
  }


  export type Day_of_weekGroupByOutputType = {
    id: number
    name: string
    created_at: Date
    updated_at: Date
    _count: Day_of_weekCountAggregateOutputType | null
    _avg: Day_of_weekAvgAggregateOutputType | null
    _sum: Day_of_weekSumAggregateOutputType | null
    _min: Day_of_weekMinAggregateOutputType | null
    _max: Day_of_weekMaxAggregateOutputType | null
  }

  type GetDay_of_weekGroupByPayload<T extends Day_of_weekGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Day_of_weekGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Day_of_weekGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Day_of_weekGroupByOutputType[P]>
            : GetScalarType<T[P], Day_of_weekGroupByOutputType[P]>
        }
      >
    >


  export type day_of_weekSelect = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    date_and_hour_of_work?: boolean | day_of_week$date_and_hour_of_workArgs
    _count?: boolean | Day_of_weekCountOutputTypeArgs
  }


  export type day_of_weekInclude = {
    date_and_hour_of_work?: boolean | day_of_week$date_and_hour_of_workArgs
    _count?: boolean | Day_of_weekCountOutputTypeArgs
  }

  export type day_of_weekGetPayload<S extends boolean | null | undefined | day_of_weekArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? day_of_week :
    S extends undefined ? never :
    S extends { include: any } & (day_of_weekArgs | day_of_weekFindManyArgs)
    ? day_of_week  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'date_and_hour_of_work' ? Array < date_and_hour_of_workGetPayload<S['include'][P]>>  :
        P extends '_count' ? Day_of_weekCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (day_of_weekArgs | day_of_weekFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'date_and_hour_of_work' ? Array < date_and_hour_of_workGetPayload<S['select'][P]>>  :
        P extends '_count' ? Day_of_weekCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof day_of_week ? day_of_week[P] : never
  } 
      : day_of_week


  type day_of_weekCountArgs = 
    Omit<day_of_weekFindManyArgs, 'select' | 'include'> & {
      select?: Day_of_weekCountAggregateInputType | true
    }

  export interface day_of_weekDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Day_of_week that matches the filter.
     * @param {day_of_weekFindUniqueArgs} args - Arguments to find a Day_of_week
     * @example
     * // Get one Day_of_week
     * const day_of_week = await prisma.day_of_week.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends day_of_weekFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, day_of_weekFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'day_of_week'> extends True ? Prisma__day_of_weekClient<day_of_weekGetPayload<T>> : Prisma__day_of_weekClient<day_of_weekGetPayload<T> | null, null>

    /**
     * Find one Day_of_week that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {day_of_weekFindUniqueOrThrowArgs} args - Arguments to find a Day_of_week
     * @example
     * // Get one Day_of_week
     * const day_of_week = await prisma.day_of_week.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends day_of_weekFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, day_of_weekFindUniqueOrThrowArgs>
    ): Prisma__day_of_weekClient<day_of_weekGetPayload<T>>

    /**
     * Find the first Day_of_week that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {day_of_weekFindFirstArgs} args - Arguments to find a Day_of_week
     * @example
     * // Get one Day_of_week
     * const day_of_week = await prisma.day_of_week.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends day_of_weekFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, day_of_weekFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'day_of_week'> extends True ? Prisma__day_of_weekClient<day_of_weekGetPayload<T>> : Prisma__day_of_weekClient<day_of_weekGetPayload<T> | null, null>

    /**
     * Find the first Day_of_week that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {day_of_weekFindFirstOrThrowArgs} args - Arguments to find a Day_of_week
     * @example
     * // Get one Day_of_week
     * const day_of_week = await prisma.day_of_week.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends day_of_weekFindFirstOrThrowArgs>(
      args?: SelectSubset<T, day_of_weekFindFirstOrThrowArgs>
    ): Prisma__day_of_weekClient<day_of_weekGetPayload<T>>

    /**
     * Find zero or more Day_of_weeks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {day_of_weekFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Day_of_weeks
     * const day_of_weeks = await prisma.day_of_week.findMany()
     * 
     * // Get first 10 Day_of_weeks
     * const day_of_weeks = await prisma.day_of_week.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const day_of_weekWithIdOnly = await prisma.day_of_week.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends day_of_weekFindManyArgs>(
      args?: SelectSubset<T, day_of_weekFindManyArgs>
    ): Prisma.PrismaPromise<Array<day_of_weekGetPayload<T>>>

    /**
     * Create a Day_of_week.
     * @param {day_of_weekCreateArgs} args - Arguments to create a Day_of_week.
     * @example
     * // Create one Day_of_week
     * const Day_of_week = await prisma.day_of_week.create({
     *   data: {
     *     // ... data to create a Day_of_week
     *   }
     * })
     * 
    **/
    create<T extends day_of_weekCreateArgs>(
      args: SelectSubset<T, day_of_weekCreateArgs>
    ): Prisma__day_of_weekClient<day_of_weekGetPayload<T>>

    /**
     * Create many Day_of_weeks.
     *     @param {day_of_weekCreateManyArgs} args - Arguments to create many Day_of_weeks.
     *     @example
     *     // Create many Day_of_weeks
     *     const day_of_week = await prisma.day_of_week.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends day_of_weekCreateManyArgs>(
      args?: SelectSubset<T, day_of_weekCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Day_of_week.
     * @param {day_of_weekDeleteArgs} args - Arguments to delete one Day_of_week.
     * @example
     * // Delete one Day_of_week
     * const Day_of_week = await prisma.day_of_week.delete({
     *   where: {
     *     // ... filter to delete one Day_of_week
     *   }
     * })
     * 
    **/
    delete<T extends day_of_weekDeleteArgs>(
      args: SelectSubset<T, day_of_weekDeleteArgs>
    ): Prisma__day_of_weekClient<day_of_weekGetPayload<T>>

    /**
     * Update one Day_of_week.
     * @param {day_of_weekUpdateArgs} args - Arguments to update one Day_of_week.
     * @example
     * // Update one Day_of_week
     * const day_of_week = await prisma.day_of_week.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends day_of_weekUpdateArgs>(
      args: SelectSubset<T, day_of_weekUpdateArgs>
    ): Prisma__day_of_weekClient<day_of_weekGetPayload<T>>

    /**
     * Delete zero or more Day_of_weeks.
     * @param {day_of_weekDeleteManyArgs} args - Arguments to filter Day_of_weeks to delete.
     * @example
     * // Delete a few Day_of_weeks
     * const { count } = await prisma.day_of_week.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends day_of_weekDeleteManyArgs>(
      args?: SelectSubset<T, day_of_weekDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Day_of_weeks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {day_of_weekUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Day_of_weeks
     * const day_of_week = await prisma.day_of_week.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends day_of_weekUpdateManyArgs>(
      args: SelectSubset<T, day_of_weekUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Day_of_week.
     * @param {day_of_weekUpsertArgs} args - Arguments to update or create a Day_of_week.
     * @example
     * // Update or create a Day_of_week
     * const day_of_week = await prisma.day_of_week.upsert({
     *   create: {
     *     // ... data to create a Day_of_week
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Day_of_week we want to update
     *   }
     * })
    **/
    upsert<T extends day_of_weekUpsertArgs>(
      args: SelectSubset<T, day_of_weekUpsertArgs>
    ): Prisma__day_of_weekClient<day_of_weekGetPayload<T>>

    /**
     * Count the number of Day_of_weeks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {day_of_weekCountArgs} args - Arguments to filter Day_of_weeks to count.
     * @example
     * // Count the number of Day_of_weeks
     * const count = await prisma.day_of_week.count({
     *   where: {
     *     // ... the filter for the Day_of_weeks we want to count
     *   }
     * })
    **/
    count<T extends day_of_weekCountArgs>(
      args?: Subset<T, day_of_weekCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Day_of_weekCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Day_of_week.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Day_of_weekAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Day_of_weekAggregateArgs>(args: Subset<T, Day_of_weekAggregateArgs>): Prisma.PrismaPromise<GetDay_of_weekAggregateType<T>>

    /**
     * Group by Day_of_week.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Day_of_weekGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Day_of_weekGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Day_of_weekGroupByArgs['orderBy'] }
        : { orderBy?: Day_of_weekGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Day_of_weekGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDay_of_weekGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for day_of_week.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__day_of_weekClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    date_and_hour_of_work<T extends day_of_week$date_and_hour_of_workArgs= {}>(args?: Subset<T, day_of_week$date_and_hour_of_workArgs>): Prisma.PrismaPromise<Array<date_and_hour_of_workGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * day_of_week base type for findUnique actions
   */
  export type day_of_weekFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the day_of_week
     */
    select?: day_of_weekSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: day_of_weekInclude | null
    /**
     * Filter, which day_of_week to fetch.
     */
    where: day_of_weekWhereUniqueInput
  }

  /**
   * day_of_week findUnique
   */
  export interface day_of_weekFindUniqueArgs extends day_of_weekFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * day_of_week findUniqueOrThrow
   */
  export type day_of_weekFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the day_of_week
     */
    select?: day_of_weekSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: day_of_weekInclude | null
    /**
     * Filter, which day_of_week to fetch.
     */
    where: day_of_weekWhereUniqueInput
  }


  /**
   * day_of_week base type for findFirst actions
   */
  export type day_of_weekFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the day_of_week
     */
    select?: day_of_weekSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: day_of_weekInclude | null
    /**
     * Filter, which day_of_week to fetch.
     */
    where?: day_of_weekWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of day_of_weeks to fetch.
     */
    orderBy?: Enumerable<day_of_weekOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for day_of_weeks.
     */
    cursor?: day_of_weekWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` day_of_weeks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` day_of_weeks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of day_of_weeks.
     */
    distinct?: Enumerable<Day_of_weekScalarFieldEnum>
  }

  /**
   * day_of_week findFirst
   */
  export interface day_of_weekFindFirstArgs extends day_of_weekFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * day_of_week findFirstOrThrow
   */
  export type day_of_weekFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the day_of_week
     */
    select?: day_of_weekSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: day_of_weekInclude | null
    /**
     * Filter, which day_of_week to fetch.
     */
    where?: day_of_weekWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of day_of_weeks to fetch.
     */
    orderBy?: Enumerable<day_of_weekOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for day_of_weeks.
     */
    cursor?: day_of_weekWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` day_of_weeks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` day_of_weeks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of day_of_weeks.
     */
    distinct?: Enumerable<Day_of_weekScalarFieldEnum>
  }


  /**
   * day_of_week findMany
   */
  export type day_of_weekFindManyArgs = {
    /**
     * Select specific fields to fetch from the day_of_week
     */
    select?: day_of_weekSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: day_of_weekInclude | null
    /**
     * Filter, which day_of_weeks to fetch.
     */
    where?: day_of_weekWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of day_of_weeks to fetch.
     */
    orderBy?: Enumerable<day_of_weekOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing day_of_weeks.
     */
    cursor?: day_of_weekWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` day_of_weeks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` day_of_weeks.
     */
    skip?: number
    distinct?: Enumerable<Day_of_weekScalarFieldEnum>
  }


  /**
   * day_of_week create
   */
  export type day_of_weekCreateArgs = {
    /**
     * Select specific fields to fetch from the day_of_week
     */
    select?: day_of_weekSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: day_of_weekInclude | null
    /**
     * The data needed to create a day_of_week.
     */
    data: XOR<day_of_weekCreateInput, day_of_weekUncheckedCreateInput>
  }


  /**
   * day_of_week createMany
   */
  export type day_of_weekCreateManyArgs = {
    /**
     * The data used to create many day_of_weeks.
     */
    data: Enumerable<day_of_weekCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * day_of_week update
   */
  export type day_of_weekUpdateArgs = {
    /**
     * Select specific fields to fetch from the day_of_week
     */
    select?: day_of_weekSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: day_of_weekInclude | null
    /**
     * The data needed to update a day_of_week.
     */
    data: XOR<day_of_weekUpdateInput, day_of_weekUncheckedUpdateInput>
    /**
     * Choose, which day_of_week to update.
     */
    where: day_of_weekWhereUniqueInput
  }


  /**
   * day_of_week updateMany
   */
  export type day_of_weekUpdateManyArgs = {
    /**
     * The data used to update day_of_weeks.
     */
    data: XOR<day_of_weekUpdateManyMutationInput, day_of_weekUncheckedUpdateManyInput>
    /**
     * Filter which day_of_weeks to update
     */
    where?: day_of_weekWhereInput
  }


  /**
   * day_of_week upsert
   */
  export type day_of_weekUpsertArgs = {
    /**
     * Select specific fields to fetch from the day_of_week
     */
    select?: day_of_weekSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: day_of_weekInclude | null
    /**
     * The filter to search for the day_of_week to update in case it exists.
     */
    where: day_of_weekWhereUniqueInput
    /**
     * In case the day_of_week found by the `where` argument doesn't exist, create a new day_of_week with this data.
     */
    create: XOR<day_of_weekCreateInput, day_of_weekUncheckedCreateInput>
    /**
     * In case the day_of_week was found with the provided `where` argument, update it with this data.
     */
    update: XOR<day_of_weekUpdateInput, day_of_weekUncheckedUpdateInput>
  }


  /**
   * day_of_week delete
   */
  export type day_of_weekDeleteArgs = {
    /**
     * Select specific fields to fetch from the day_of_week
     */
    select?: day_of_weekSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: day_of_weekInclude | null
    /**
     * Filter which day_of_week to delete.
     */
    where: day_of_weekWhereUniqueInput
  }


  /**
   * day_of_week deleteMany
   */
  export type day_of_weekDeleteManyArgs = {
    /**
     * Filter which day_of_weeks to delete
     */
    where?: day_of_weekWhereInput
  }


  /**
   * day_of_week.date_and_hour_of_work
   */
  export type day_of_week$date_and_hour_of_workArgs = {
    /**
     * Select specific fields to fetch from the date_and_hour_of_work
     */
    select?: date_and_hour_of_workSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: date_and_hour_of_workInclude | null
    where?: date_and_hour_of_workWhereInput
    orderBy?: Enumerable<date_and_hour_of_workOrderByWithRelationInput>
    cursor?: date_and_hour_of_workWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Date_and_hour_of_workScalarFieldEnum>
  }


  /**
   * day_of_week without action
   */
  export type day_of_weekArgs = {
    /**
     * Select specific fields to fetch from the day_of_week
     */
    select?: day_of_weekSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: day_of_weekInclude | null
  }



  /**
   * Model gender
   */


  export type AggregateGender = {
    _count: GenderCountAggregateOutputType | null
    _avg: GenderAvgAggregateOutputType | null
    _sum: GenderSumAggregateOutputType | null
    _min: GenderMinAggregateOutputType | null
    _max: GenderMaxAggregateOutputType | null
  }

  export type GenderAvgAggregateOutputType = {
    id: number | null
  }

  export type GenderSumAggregateOutputType = {
    id: number | null
  }

  export type GenderMinAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type GenderMaxAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type GenderCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type GenderAvgAggregateInputType = {
    id?: true
  }

  export type GenderSumAggregateInputType = {
    id?: true
  }

  export type GenderMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type GenderMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
  }

  export type GenderCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type GenderAggregateArgs = {
    /**
     * Filter which gender to aggregate.
     */
    where?: genderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of genders to fetch.
     */
    orderBy?: Enumerable<genderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: genderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` genders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` genders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned genders
    **/
    _count?: true | GenderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GenderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GenderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenderMaxAggregateInputType
  }

  export type GetGenderAggregateType<T extends GenderAggregateArgs> = {
        [P in keyof T & keyof AggregateGender]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGender[P]>
      : GetScalarType<T[P], AggregateGender[P]>
  }




  export type GenderGroupByArgs = {
    where?: genderWhereInput
    orderBy?: Enumerable<genderOrderByWithAggregationInput>
    by: GenderScalarFieldEnum[]
    having?: genderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenderCountAggregateInputType | true
    _avg?: GenderAvgAggregateInputType
    _sum?: GenderSumAggregateInputType
    _min?: GenderMinAggregateInputType
    _max?: GenderMaxAggregateInputType
  }


  export type GenderGroupByOutputType = {
    id: number
    name: string
    created_at: Date
    updated_at: Date
    _count: GenderCountAggregateOutputType | null
    _avg: GenderAvgAggregateOutputType | null
    _sum: GenderSumAggregateOutputType | null
    _min: GenderMinAggregateOutputType | null
    _max: GenderMaxAggregateOutputType | null
  }

  type GetGenderGroupByPayload<T extends GenderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<GenderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenderGroupByOutputType[P]>
            : GetScalarType<T[P], GenderGroupByOutputType[P]>
        }
      >
    >


  export type genderSelect = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    updated_at?: boolean
    costumer?: boolean | gender$costumerArgs
    deliveryman?: boolean | gender$deliverymanArgs
    marketer?: boolean | gender$marketerArgs
    _count?: boolean | GenderCountOutputTypeArgs
  }


  export type genderInclude = {
    costumer?: boolean | gender$costumerArgs
    deliveryman?: boolean | gender$deliverymanArgs
    marketer?: boolean | gender$marketerArgs
    _count?: boolean | GenderCountOutputTypeArgs
  }

  export type genderGetPayload<S extends boolean | null | undefined | genderArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? gender :
    S extends undefined ? never :
    S extends { include: any } & (genderArgs | genderFindManyArgs)
    ? gender  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'costumer' ? Array < costumerGetPayload<S['include'][P]>>  :
        P extends 'deliveryman' ? Array < deliverymanGetPayload<S['include'][P]>>  :
        P extends 'marketer' ? Array < marketerGetPayload<S['include'][P]>>  :
        P extends '_count' ? GenderCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (genderArgs | genderFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'costumer' ? Array < costumerGetPayload<S['select'][P]>>  :
        P extends 'deliveryman' ? Array < deliverymanGetPayload<S['select'][P]>>  :
        P extends 'marketer' ? Array < marketerGetPayload<S['select'][P]>>  :
        P extends '_count' ? GenderCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof gender ? gender[P] : never
  } 
      : gender


  type genderCountArgs = 
    Omit<genderFindManyArgs, 'select' | 'include'> & {
      select?: GenderCountAggregateInputType | true
    }

  export interface genderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Gender that matches the filter.
     * @param {genderFindUniqueArgs} args - Arguments to find a Gender
     * @example
     * // Get one Gender
     * const gender = await prisma.gender.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends genderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, genderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'gender'> extends True ? Prisma__genderClient<genderGetPayload<T>> : Prisma__genderClient<genderGetPayload<T> | null, null>

    /**
     * Find one Gender that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {genderFindUniqueOrThrowArgs} args - Arguments to find a Gender
     * @example
     * // Get one Gender
     * const gender = await prisma.gender.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends genderFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, genderFindUniqueOrThrowArgs>
    ): Prisma__genderClient<genderGetPayload<T>>

    /**
     * Find the first Gender that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {genderFindFirstArgs} args - Arguments to find a Gender
     * @example
     * // Get one Gender
     * const gender = await prisma.gender.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends genderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, genderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'gender'> extends True ? Prisma__genderClient<genderGetPayload<T>> : Prisma__genderClient<genderGetPayload<T> | null, null>

    /**
     * Find the first Gender that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {genderFindFirstOrThrowArgs} args - Arguments to find a Gender
     * @example
     * // Get one Gender
     * const gender = await prisma.gender.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends genderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, genderFindFirstOrThrowArgs>
    ): Prisma__genderClient<genderGetPayload<T>>

    /**
     * Find zero or more Genders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {genderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Genders
     * const genders = await prisma.gender.findMany()
     * 
     * // Get first 10 Genders
     * const genders = await prisma.gender.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const genderWithIdOnly = await prisma.gender.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends genderFindManyArgs>(
      args?: SelectSubset<T, genderFindManyArgs>
    ): Prisma.PrismaPromise<Array<genderGetPayload<T>>>

    /**
     * Create a Gender.
     * @param {genderCreateArgs} args - Arguments to create a Gender.
     * @example
     * // Create one Gender
     * const Gender = await prisma.gender.create({
     *   data: {
     *     // ... data to create a Gender
     *   }
     * })
     * 
    **/
    create<T extends genderCreateArgs>(
      args: SelectSubset<T, genderCreateArgs>
    ): Prisma__genderClient<genderGetPayload<T>>

    /**
     * Create many Genders.
     *     @param {genderCreateManyArgs} args - Arguments to create many Genders.
     *     @example
     *     // Create many Genders
     *     const gender = await prisma.gender.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends genderCreateManyArgs>(
      args?: SelectSubset<T, genderCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gender.
     * @param {genderDeleteArgs} args - Arguments to delete one Gender.
     * @example
     * // Delete one Gender
     * const Gender = await prisma.gender.delete({
     *   where: {
     *     // ... filter to delete one Gender
     *   }
     * })
     * 
    **/
    delete<T extends genderDeleteArgs>(
      args: SelectSubset<T, genderDeleteArgs>
    ): Prisma__genderClient<genderGetPayload<T>>

    /**
     * Update one Gender.
     * @param {genderUpdateArgs} args - Arguments to update one Gender.
     * @example
     * // Update one Gender
     * const gender = await prisma.gender.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends genderUpdateArgs>(
      args: SelectSubset<T, genderUpdateArgs>
    ): Prisma__genderClient<genderGetPayload<T>>

    /**
     * Delete zero or more Genders.
     * @param {genderDeleteManyArgs} args - Arguments to filter Genders to delete.
     * @example
     * // Delete a few Genders
     * const { count } = await prisma.gender.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends genderDeleteManyArgs>(
      args?: SelectSubset<T, genderDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {genderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Genders
     * const gender = await prisma.gender.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends genderUpdateManyArgs>(
      args: SelectSubset<T, genderUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gender.
     * @param {genderUpsertArgs} args - Arguments to update or create a Gender.
     * @example
     * // Update or create a Gender
     * const gender = await prisma.gender.upsert({
     *   create: {
     *     // ... data to create a Gender
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gender we want to update
     *   }
     * })
    **/
    upsert<T extends genderUpsertArgs>(
      args: SelectSubset<T, genderUpsertArgs>
    ): Prisma__genderClient<genderGetPayload<T>>

    /**
     * Count the number of Genders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {genderCountArgs} args - Arguments to filter Genders to count.
     * @example
     * // Count the number of Genders
     * const count = await prisma.gender.count({
     *   where: {
     *     // ... the filter for the Genders we want to count
     *   }
     * })
    **/
    count<T extends genderCountArgs>(
      args?: Subset<T, genderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gender.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenderAggregateArgs>(args: Subset<T, GenderAggregateArgs>): Prisma.PrismaPromise<GetGenderAggregateType<T>>

    /**
     * Group by Gender.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GenderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GenderGroupByArgs['orderBy'] }
        : { orderBy?: GenderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GenderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for gender.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__genderClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    costumer<T extends gender$costumerArgs= {}>(args?: Subset<T, gender$costumerArgs>): Prisma.PrismaPromise<Array<costumerGetPayload<T>>| Null>;

    deliveryman<T extends gender$deliverymanArgs= {}>(args?: Subset<T, gender$deliverymanArgs>): Prisma.PrismaPromise<Array<deliverymanGetPayload<T>>| Null>;

    marketer<T extends gender$marketerArgs= {}>(args?: Subset<T, gender$marketerArgs>): Prisma.PrismaPromise<Array<marketerGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * gender base type for findUnique actions
   */
  export type genderFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the gender
     */
    select?: genderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: genderInclude | null
    /**
     * Filter, which gender to fetch.
     */
    where: genderWhereUniqueInput
  }

  /**
   * gender findUnique
   */
  export interface genderFindUniqueArgs extends genderFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * gender findUniqueOrThrow
   */
  export type genderFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the gender
     */
    select?: genderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: genderInclude | null
    /**
     * Filter, which gender to fetch.
     */
    where: genderWhereUniqueInput
  }


  /**
   * gender base type for findFirst actions
   */
  export type genderFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the gender
     */
    select?: genderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: genderInclude | null
    /**
     * Filter, which gender to fetch.
     */
    where?: genderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of genders to fetch.
     */
    orderBy?: Enumerable<genderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for genders.
     */
    cursor?: genderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` genders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` genders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of genders.
     */
    distinct?: Enumerable<GenderScalarFieldEnum>
  }

  /**
   * gender findFirst
   */
  export interface genderFindFirstArgs extends genderFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * gender findFirstOrThrow
   */
  export type genderFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the gender
     */
    select?: genderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: genderInclude | null
    /**
     * Filter, which gender to fetch.
     */
    where?: genderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of genders to fetch.
     */
    orderBy?: Enumerable<genderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for genders.
     */
    cursor?: genderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` genders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` genders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of genders.
     */
    distinct?: Enumerable<GenderScalarFieldEnum>
  }


  /**
   * gender findMany
   */
  export type genderFindManyArgs = {
    /**
     * Select specific fields to fetch from the gender
     */
    select?: genderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: genderInclude | null
    /**
     * Filter, which genders to fetch.
     */
    where?: genderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of genders to fetch.
     */
    orderBy?: Enumerable<genderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing genders.
     */
    cursor?: genderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` genders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` genders.
     */
    skip?: number
    distinct?: Enumerable<GenderScalarFieldEnum>
  }


  /**
   * gender create
   */
  export type genderCreateArgs = {
    /**
     * Select specific fields to fetch from the gender
     */
    select?: genderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: genderInclude | null
    /**
     * The data needed to create a gender.
     */
    data: XOR<genderCreateInput, genderUncheckedCreateInput>
  }


  /**
   * gender createMany
   */
  export type genderCreateManyArgs = {
    /**
     * The data used to create many genders.
     */
    data: Enumerable<genderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * gender update
   */
  export type genderUpdateArgs = {
    /**
     * Select specific fields to fetch from the gender
     */
    select?: genderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: genderInclude | null
    /**
     * The data needed to update a gender.
     */
    data: XOR<genderUpdateInput, genderUncheckedUpdateInput>
    /**
     * Choose, which gender to update.
     */
    where: genderWhereUniqueInput
  }


  /**
   * gender updateMany
   */
  export type genderUpdateManyArgs = {
    /**
     * The data used to update genders.
     */
    data: XOR<genderUpdateManyMutationInput, genderUncheckedUpdateManyInput>
    /**
     * Filter which genders to update
     */
    where?: genderWhereInput
  }


  /**
   * gender upsert
   */
  export type genderUpsertArgs = {
    /**
     * Select specific fields to fetch from the gender
     */
    select?: genderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: genderInclude | null
    /**
     * The filter to search for the gender to update in case it exists.
     */
    where: genderWhereUniqueInput
    /**
     * In case the gender found by the `where` argument doesn't exist, create a new gender with this data.
     */
    create: XOR<genderCreateInput, genderUncheckedCreateInput>
    /**
     * In case the gender was found with the provided `where` argument, update it with this data.
     */
    update: XOR<genderUpdateInput, genderUncheckedUpdateInput>
  }


  /**
   * gender delete
   */
  export type genderDeleteArgs = {
    /**
     * Select specific fields to fetch from the gender
     */
    select?: genderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: genderInclude | null
    /**
     * Filter which gender to delete.
     */
    where: genderWhereUniqueInput
  }


  /**
   * gender deleteMany
   */
  export type genderDeleteManyArgs = {
    /**
     * Filter which genders to delete
     */
    where?: genderWhereInput
  }


  /**
   * gender.costumer
   */
  export type gender$costumerArgs = {
    /**
     * Select specific fields to fetch from the costumer
     */
    select?: costumerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: costumerInclude | null
    where?: costumerWhereInput
    orderBy?: Enumerable<costumerOrderByWithRelationInput>
    cursor?: costumerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CostumerScalarFieldEnum>
  }


  /**
   * gender.deliveryman
   */
  export type gender$deliverymanArgs = {
    /**
     * Select specific fields to fetch from the deliveryman
     */
    select?: deliverymanSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: deliverymanInclude | null
    where?: deliverymanWhereInput
    orderBy?: Enumerable<deliverymanOrderByWithRelationInput>
    cursor?: deliverymanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DeliverymanScalarFieldEnum>
  }


  /**
   * gender.marketer
   */
  export type gender$marketerArgs = {
    /**
     * Select specific fields to fetch from the marketer
     */
    select?: marketerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: marketerInclude | null
    where?: marketerWhereInput
    orderBy?: Enumerable<marketerOrderByWithRelationInput>
    cursor?: marketerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MarketerScalarFieldEnum>
  }


  /**
   * gender without action
   */
  export type genderArgs = {
    /**
     * Select specific fields to fetch from the gender
     */
    select?: genderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: genderInclude | null
  }



  /**
   * Model city
   */


  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityAvgAggregateOutputType = {
    id: number | null
  }

  export type CitySumAggregateOutputType = {
    id: number | null
  }

  export type CityMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type CityMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type CityAvgAggregateInputType = {
    id?: true
  }

  export type CitySumAggregateInputType = {
    id?: true
  }

  export type CityMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type CityAggregateArgs = {
    /**
     * Filter which city to aggregate.
     */
    where?: cityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     */
    orderBy?: Enumerable<cityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs = {
    where?: cityWhereInput
    orderBy?: Enumerable<cityOrderByWithAggregationInput>
    by: CityScalarFieldEnum[]
    having?: cityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _avg?: CityAvgAggregateInputType
    _sum?: CitySumAggregateInputType
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }


  export type CityGroupByOutputType = {
    id: number
    name: string
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type citySelect = {
    id?: boolean
    name?: boolean
    address?: boolean | city$addressArgs
    _count?: boolean | CityCountOutputTypeArgs
  }


  export type cityInclude = {
    address?: boolean | city$addressArgs
    _count?: boolean | CityCountOutputTypeArgs
  }

  export type cityGetPayload<S extends boolean | null | undefined | cityArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? city :
    S extends undefined ? never :
    S extends { include: any } & (cityArgs | cityFindManyArgs)
    ? city  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'address' ? Array < addressGetPayload<S['include'][P]>>  :
        P extends '_count' ? CityCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (cityArgs | cityFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'address' ? Array < addressGetPayload<S['select'][P]>>  :
        P extends '_count' ? CityCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof city ? city[P] : never
  } 
      : city


  type cityCountArgs = 
    Omit<cityFindManyArgs, 'select' | 'include'> & {
      select?: CityCountAggregateInputType | true
    }

  export interface cityDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one City that matches the filter.
     * @param {cityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends cityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, cityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'city'> extends True ? Prisma__cityClient<cityGetPayload<T>> : Prisma__cityClient<cityGetPayload<T> | null, null>

    /**
     * Find one City that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {cityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends cityFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, cityFindUniqueOrThrowArgs>
    ): Prisma__cityClient<cityGetPayload<T>>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends cityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, cityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'city'> extends True ? Prisma__cityClient<cityGetPayload<T>> : Prisma__cityClient<cityGetPayload<T> | null, null>

    /**
     * Find the first City that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends cityFindFirstOrThrowArgs>(
      args?: SelectSubset<T, cityFindFirstOrThrowArgs>
    ): Prisma__cityClient<cityGetPayload<T>>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends cityFindManyArgs>(
      args?: SelectSubset<T, cityFindManyArgs>
    ): Prisma.PrismaPromise<Array<cityGetPayload<T>>>

    /**
     * Create a City.
     * @param {cityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
    **/
    create<T extends cityCreateArgs>(
      args: SelectSubset<T, cityCreateArgs>
    ): Prisma__cityClient<cityGetPayload<T>>

    /**
     * Create many Cities.
     *     @param {cityCreateManyArgs} args - Arguments to create many Cities.
     *     @example
     *     // Create many Cities
     *     const city = await prisma.city.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends cityCreateManyArgs>(
      args?: SelectSubset<T, cityCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a City.
     * @param {cityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
    **/
    delete<T extends cityDeleteArgs>(
      args: SelectSubset<T, cityDeleteArgs>
    ): Prisma__cityClient<cityGetPayload<T>>

    /**
     * Update one City.
     * @param {cityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends cityUpdateArgs>(
      args: SelectSubset<T, cityUpdateArgs>
    ): Prisma__cityClient<cityGetPayload<T>>

    /**
     * Delete zero or more Cities.
     * @param {cityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends cityDeleteManyArgs>(
      args?: SelectSubset<T, cityDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends cityUpdateManyArgs>(
      args: SelectSubset<T, cityUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one City.
     * @param {cityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
    **/
    upsert<T extends cityUpsertArgs>(
      args: SelectSubset<T, cityUpsertArgs>
    ): Prisma__cityClient<cityGetPayload<T>>

    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends cityCountArgs>(
      args?: Subset<T, cityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): Prisma.PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for city.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__cityClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    address<T extends city$addressArgs= {}>(args?: Subset<T, city$addressArgs>): Prisma.PrismaPromise<Array<addressGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * city base type for findUnique actions
   */
  export type cityFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cityInclude | null
    /**
     * Filter, which city to fetch.
     */
    where: cityWhereUniqueInput
  }

  /**
   * city findUnique
   */
  export interface cityFindUniqueArgs extends cityFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * city findUniqueOrThrow
   */
  export type cityFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cityInclude | null
    /**
     * Filter, which city to fetch.
     */
    where: cityWhereUniqueInput
  }


  /**
   * city base type for findFirst actions
   */
  export type cityFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cityInclude | null
    /**
     * Filter, which city to fetch.
     */
    where?: cityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     */
    orderBy?: Enumerable<cityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cities.
     */
    cursor?: cityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cities.
     */
    distinct?: Enumerable<CityScalarFieldEnum>
  }

  /**
   * city findFirst
   */
  export interface cityFindFirstArgs extends cityFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * city findFirstOrThrow
   */
  export type cityFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cityInclude | null
    /**
     * Filter, which city to fetch.
     */
    where?: cityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     */
    orderBy?: Enumerable<cityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cities.
     */
    cursor?: cityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cities.
     */
    distinct?: Enumerable<CityScalarFieldEnum>
  }


  /**
   * city findMany
   */
  export type cityFindManyArgs = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cityInclude | null
    /**
     * Filter, which cities to fetch.
     */
    where?: cityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     */
    orderBy?: Enumerable<cityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cities.
     */
    cursor?: cityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     */
    skip?: number
    distinct?: Enumerable<CityScalarFieldEnum>
  }


  /**
   * city create
   */
  export type cityCreateArgs = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cityInclude | null
    /**
     * The data needed to create a city.
     */
    data: XOR<cityCreateInput, cityUncheckedCreateInput>
  }


  /**
   * city createMany
   */
  export type cityCreateManyArgs = {
    /**
     * The data used to create many cities.
     */
    data: Enumerable<cityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * city update
   */
  export type cityUpdateArgs = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cityInclude | null
    /**
     * The data needed to update a city.
     */
    data: XOR<cityUpdateInput, cityUncheckedUpdateInput>
    /**
     * Choose, which city to update.
     */
    where: cityWhereUniqueInput
  }


  /**
   * city updateMany
   */
  export type cityUpdateManyArgs = {
    /**
     * The data used to update cities.
     */
    data: XOR<cityUpdateManyMutationInput, cityUncheckedUpdateManyInput>
    /**
     * Filter which cities to update
     */
    where?: cityWhereInput
  }


  /**
   * city upsert
   */
  export type cityUpsertArgs = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cityInclude | null
    /**
     * The filter to search for the city to update in case it exists.
     */
    where: cityWhereUniqueInput
    /**
     * In case the city found by the `where` argument doesn't exist, create a new city with this data.
     */
    create: XOR<cityCreateInput, cityUncheckedCreateInput>
    /**
     * In case the city was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cityUpdateInput, cityUncheckedUpdateInput>
  }


  /**
   * city delete
   */
  export type cityDeleteArgs = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cityInclude | null
    /**
     * Filter which city to delete.
     */
    where: cityWhereUniqueInput
  }


  /**
   * city deleteMany
   */
  export type cityDeleteManyArgs = {
    /**
     * Filter which cities to delete
     */
    where?: cityWhereInput
  }


  /**
   * city.address
   */
  export type city$addressArgs = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude | null
    where?: addressWhereInput
    orderBy?: Enumerable<addressOrderByWithRelationInput>
    cursor?: addressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * city without action
   */
  export type cityArgs = {
    /**
     * Select specific fields to fetch from the city
     */
    select?: citySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cityInclude | null
  }



  /**
   * Model neighborhood
   */


  export type AggregateNeighborhood = {
    _count: NeighborhoodCountAggregateOutputType | null
    _avg: NeighborhoodAvgAggregateOutputType | null
    _sum: NeighborhoodSumAggregateOutputType | null
    _min: NeighborhoodMinAggregateOutputType | null
    _max: NeighborhoodMaxAggregateOutputType | null
  }

  export type NeighborhoodAvgAggregateOutputType = {
    id: number | null
  }

  export type NeighborhoodSumAggregateOutputType = {
    id: number | null
  }

  export type NeighborhoodMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type NeighborhoodMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type NeighborhoodCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type NeighborhoodAvgAggregateInputType = {
    id?: true
  }

  export type NeighborhoodSumAggregateInputType = {
    id?: true
  }

  export type NeighborhoodMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type NeighborhoodMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type NeighborhoodCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type NeighborhoodAggregateArgs = {
    /**
     * Filter which neighborhood to aggregate.
     */
    where?: neighborhoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of neighborhoods to fetch.
     */
    orderBy?: Enumerable<neighborhoodOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: neighborhoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` neighborhoods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` neighborhoods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned neighborhoods
    **/
    _count?: true | NeighborhoodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NeighborhoodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NeighborhoodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NeighborhoodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NeighborhoodMaxAggregateInputType
  }

  export type GetNeighborhoodAggregateType<T extends NeighborhoodAggregateArgs> = {
        [P in keyof T & keyof AggregateNeighborhood]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNeighborhood[P]>
      : GetScalarType<T[P], AggregateNeighborhood[P]>
  }




  export type NeighborhoodGroupByArgs = {
    where?: neighborhoodWhereInput
    orderBy?: Enumerable<neighborhoodOrderByWithAggregationInput>
    by: NeighborhoodScalarFieldEnum[]
    having?: neighborhoodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NeighborhoodCountAggregateInputType | true
    _avg?: NeighborhoodAvgAggregateInputType
    _sum?: NeighborhoodSumAggregateInputType
    _min?: NeighborhoodMinAggregateInputType
    _max?: NeighborhoodMaxAggregateInputType
  }


  export type NeighborhoodGroupByOutputType = {
    id: number
    name: string
    _count: NeighborhoodCountAggregateOutputType | null
    _avg: NeighborhoodAvgAggregateOutputType | null
    _sum: NeighborhoodSumAggregateOutputType | null
    _min: NeighborhoodMinAggregateOutputType | null
    _max: NeighborhoodMaxAggregateOutputType | null
  }

  type GetNeighborhoodGroupByPayload<T extends NeighborhoodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<NeighborhoodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NeighborhoodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NeighborhoodGroupByOutputType[P]>
            : GetScalarType<T[P], NeighborhoodGroupByOutputType[P]>
        }
      >
    >


  export type neighborhoodSelect = {
    id?: boolean
    name?: boolean
    address?: boolean | neighborhood$addressArgs
    _count?: boolean | NeighborhoodCountOutputTypeArgs
  }


  export type neighborhoodInclude = {
    address?: boolean | neighborhood$addressArgs
    _count?: boolean | NeighborhoodCountOutputTypeArgs
  }

  export type neighborhoodGetPayload<S extends boolean | null | undefined | neighborhoodArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? neighborhood :
    S extends undefined ? never :
    S extends { include: any } & (neighborhoodArgs | neighborhoodFindManyArgs)
    ? neighborhood  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'address' ? Array < addressGetPayload<S['include'][P]>>  :
        P extends '_count' ? NeighborhoodCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (neighborhoodArgs | neighborhoodFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'address' ? Array < addressGetPayload<S['select'][P]>>  :
        P extends '_count' ? NeighborhoodCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof neighborhood ? neighborhood[P] : never
  } 
      : neighborhood


  type neighborhoodCountArgs = 
    Omit<neighborhoodFindManyArgs, 'select' | 'include'> & {
      select?: NeighborhoodCountAggregateInputType | true
    }

  export interface neighborhoodDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Neighborhood that matches the filter.
     * @param {neighborhoodFindUniqueArgs} args - Arguments to find a Neighborhood
     * @example
     * // Get one Neighborhood
     * const neighborhood = await prisma.neighborhood.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends neighborhoodFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, neighborhoodFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'neighborhood'> extends True ? Prisma__neighborhoodClient<neighborhoodGetPayload<T>> : Prisma__neighborhoodClient<neighborhoodGetPayload<T> | null, null>

    /**
     * Find one Neighborhood that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {neighborhoodFindUniqueOrThrowArgs} args - Arguments to find a Neighborhood
     * @example
     * // Get one Neighborhood
     * const neighborhood = await prisma.neighborhood.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends neighborhoodFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, neighborhoodFindUniqueOrThrowArgs>
    ): Prisma__neighborhoodClient<neighborhoodGetPayload<T>>

    /**
     * Find the first Neighborhood that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {neighborhoodFindFirstArgs} args - Arguments to find a Neighborhood
     * @example
     * // Get one Neighborhood
     * const neighborhood = await prisma.neighborhood.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends neighborhoodFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, neighborhoodFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'neighborhood'> extends True ? Prisma__neighborhoodClient<neighborhoodGetPayload<T>> : Prisma__neighborhoodClient<neighborhoodGetPayload<T> | null, null>

    /**
     * Find the first Neighborhood that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {neighborhoodFindFirstOrThrowArgs} args - Arguments to find a Neighborhood
     * @example
     * // Get one Neighborhood
     * const neighborhood = await prisma.neighborhood.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends neighborhoodFindFirstOrThrowArgs>(
      args?: SelectSubset<T, neighborhoodFindFirstOrThrowArgs>
    ): Prisma__neighborhoodClient<neighborhoodGetPayload<T>>

    /**
     * Find zero or more Neighborhoods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {neighborhoodFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Neighborhoods
     * const neighborhoods = await prisma.neighborhood.findMany()
     * 
     * // Get first 10 Neighborhoods
     * const neighborhoods = await prisma.neighborhood.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const neighborhoodWithIdOnly = await prisma.neighborhood.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends neighborhoodFindManyArgs>(
      args?: SelectSubset<T, neighborhoodFindManyArgs>
    ): Prisma.PrismaPromise<Array<neighborhoodGetPayload<T>>>

    /**
     * Create a Neighborhood.
     * @param {neighborhoodCreateArgs} args - Arguments to create a Neighborhood.
     * @example
     * // Create one Neighborhood
     * const Neighborhood = await prisma.neighborhood.create({
     *   data: {
     *     // ... data to create a Neighborhood
     *   }
     * })
     * 
    **/
    create<T extends neighborhoodCreateArgs>(
      args: SelectSubset<T, neighborhoodCreateArgs>
    ): Prisma__neighborhoodClient<neighborhoodGetPayload<T>>

    /**
     * Create many Neighborhoods.
     *     @param {neighborhoodCreateManyArgs} args - Arguments to create many Neighborhoods.
     *     @example
     *     // Create many Neighborhoods
     *     const neighborhood = await prisma.neighborhood.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends neighborhoodCreateManyArgs>(
      args?: SelectSubset<T, neighborhoodCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Neighborhood.
     * @param {neighborhoodDeleteArgs} args - Arguments to delete one Neighborhood.
     * @example
     * // Delete one Neighborhood
     * const Neighborhood = await prisma.neighborhood.delete({
     *   where: {
     *     // ... filter to delete one Neighborhood
     *   }
     * })
     * 
    **/
    delete<T extends neighborhoodDeleteArgs>(
      args: SelectSubset<T, neighborhoodDeleteArgs>
    ): Prisma__neighborhoodClient<neighborhoodGetPayload<T>>

    /**
     * Update one Neighborhood.
     * @param {neighborhoodUpdateArgs} args - Arguments to update one Neighborhood.
     * @example
     * // Update one Neighborhood
     * const neighborhood = await prisma.neighborhood.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends neighborhoodUpdateArgs>(
      args: SelectSubset<T, neighborhoodUpdateArgs>
    ): Prisma__neighborhoodClient<neighborhoodGetPayload<T>>

    /**
     * Delete zero or more Neighborhoods.
     * @param {neighborhoodDeleteManyArgs} args - Arguments to filter Neighborhoods to delete.
     * @example
     * // Delete a few Neighborhoods
     * const { count } = await prisma.neighborhood.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends neighborhoodDeleteManyArgs>(
      args?: SelectSubset<T, neighborhoodDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Neighborhoods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {neighborhoodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Neighborhoods
     * const neighborhood = await prisma.neighborhood.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends neighborhoodUpdateManyArgs>(
      args: SelectSubset<T, neighborhoodUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Neighborhood.
     * @param {neighborhoodUpsertArgs} args - Arguments to update or create a Neighborhood.
     * @example
     * // Update or create a Neighborhood
     * const neighborhood = await prisma.neighborhood.upsert({
     *   create: {
     *     // ... data to create a Neighborhood
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Neighborhood we want to update
     *   }
     * })
    **/
    upsert<T extends neighborhoodUpsertArgs>(
      args: SelectSubset<T, neighborhoodUpsertArgs>
    ): Prisma__neighborhoodClient<neighborhoodGetPayload<T>>

    /**
     * Count the number of Neighborhoods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {neighborhoodCountArgs} args - Arguments to filter Neighborhoods to count.
     * @example
     * // Count the number of Neighborhoods
     * const count = await prisma.neighborhood.count({
     *   where: {
     *     // ... the filter for the Neighborhoods we want to count
     *   }
     * })
    **/
    count<T extends neighborhoodCountArgs>(
      args?: Subset<T, neighborhoodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NeighborhoodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Neighborhood.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeighborhoodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NeighborhoodAggregateArgs>(args: Subset<T, NeighborhoodAggregateArgs>): Prisma.PrismaPromise<GetNeighborhoodAggregateType<T>>

    /**
     * Group by Neighborhood.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeighborhoodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NeighborhoodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NeighborhoodGroupByArgs['orderBy'] }
        : { orderBy?: NeighborhoodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NeighborhoodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNeighborhoodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for neighborhood.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__neighborhoodClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    address<T extends neighborhood$addressArgs= {}>(args?: Subset<T, neighborhood$addressArgs>): Prisma.PrismaPromise<Array<addressGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * neighborhood base type for findUnique actions
   */
  export type neighborhoodFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the neighborhood
     */
    select?: neighborhoodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: neighborhoodInclude | null
    /**
     * Filter, which neighborhood to fetch.
     */
    where: neighborhoodWhereUniqueInput
  }

  /**
   * neighborhood findUnique
   */
  export interface neighborhoodFindUniqueArgs extends neighborhoodFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * neighborhood findUniqueOrThrow
   */
  export type neighborhoodFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the neighborhood
     */
    select?: neighborhoodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: neighborhoodInclude | null
    /**
     * Filter, which neighborhood to fetch.
     */
    where: neighborhoodWhereUniqueInput
  }


  /**
   * neighborhood base type for findFirst actions
   */
  export type neighborhoodFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the neighborhood
     */
    select?: neighborhoodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: neighborhoodInclude | null
    /**
     * Filter, which neighborhood to fetch.
     */
    where?: neighborhoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of neighborhoods to fetch.
     */
    orderBy?: Enumerable<neighborhoodOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for neighborhoods.
     */
    cursor?: neighborhoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` neighborhoods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` neighborhoods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of neighborhoods.
     */
    distinct?: Enumerable<NeighborhoodScalarFieldEnum>
  }

  /**
   * neighborhood findFirst
   */
  export interface neighborhoodFindFirstArgs extends neighborhoodFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * neighborhood findFirstOrThrow
   */
  export type neighborhoodFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the neighborhood
     */
    select?: neighborhoodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: neighborhoodInclude | null
    /**
     * Filter, which neighborhood to fetch.
     */
    where?: neighborhoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of neighborhoods to fetch.
     */
    orderBy?: Enumerable<neighborhoodOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for neighborhoods.
     */
    cursor?: neighborhoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` neighborhoods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` neighborhoods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of neighborhoods.
     */
    distinct?: Enumerable<NeighborhoodScalarFieldEnum>
  }


  /**
   * neighborhood findMany
   */
  export type neighborhoodFindManyArgs = {
    /**
     * Select specific fields to fetch from the neighborhood
     */
    select?: neighborhoodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: neighborhoodInclude | null
    /**
     * Filter, which neighborhoods to fetch.
     */
    where?: neighborhoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of neighborhoods to fetch.
     */
    orderBy?: Enumerable<neighborhoodOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing neighborhoods.
     */
    cursor?: neighborhoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` neighborhoods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` neighborhoods.
     */
    skip?: number
    distinct?: Enumerable<NeighborhoodScalarFieldEnum>
  }


  /**
   * neighborhood create
   */
  export type neighborhoodCreateArgs = {
    /**
     * Select specific fields to fetch from the neighborhood
     */
    select?: neighborhoodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: neighborhoodInclude | null
    /**
     * The data needed to create a neighborhood.
     */
    data: XOR<neighborhoodCreateInput, neighborhoodUncheckedCreateInput>
  }


  /**
   * neighborhood createMany
   */
  export type neighborhoodCreateManyArgs = {
    /**
     * The data used to create many neighborhoods.
     */
    data: Enumerable<neighborhoodCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * neighborhood update
   */
  export type neighborhoodUpdateArgs = {
    /**
     * Select specific fields to fetch from the neighborhood
     */
    select?: neighborhoodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: neighborhoodInclude | null
    /**
     * The data needed to update a neighborhood.
     */
    data: XOR<neighborhoodUpdateInput, neighborhoodUncheckedUpdateInput>
    /**
     * Choose, which neighborhood to update.
     */
    where: neighborhoodWhereUniqueInput
  }


  /**
   * neighborhood updateMany
   */
  export type neighborhoodUpdateManyArgs = {
    /**
     * The data used to update neighborhoods.
     */
    data: XOR<neighborhoodUpdateManyMutationInput, neighborhoodUncheckedUpdateManyInput>
    /**
     * Filter which neighborhoods to update
     */
    where?: neighborhoodWhereInput
  }


  /**
   * neighborhood upsert
   */
  export type neighborhoodUpsertArgs = {
    /**
     * Select specific fields to fetch from the neighborhood
     */
    select?: neighborhoodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: neighborhoodInclude | null
    /**
     * The filter to search for the neighborhood to update in case it exists.
     */
    where: neighborhoodWhereUniqueInput
    /**
     * In case the neighborhood found by the `where` argument doesn't exist, create a new neighborhood with this data.
     */
    create: XOR<neighborhoodCreateInput, neighborhoodUncheckedCreateInput>
    /**
     * In case the neighborhood was found with the provided `where` argument, update it with this data.
     */
    update: XOR<neighborhoodUpdateInput, neighborhoodUncheckedUpdateInput>
  }


  /**
   * neighborhood delete
   */
  export type neighborhoodDeleteArgs = {
    /**
     * Select specific fields to fetch from the neighborhood
     */
    select?: neighborhoodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: neighborhoodInclude | null
    /**
     * Filter which neighborhood to delete.
     */
    where: neighborhoodWhereUniqueInput
  }


  /**
   * neighborhood deleteMany
   */
  export type neighborhoodDeleteManyArgs = {
    /**
     * Filter which neighborhoods to delete
     */
    where?: neighborhoodWhereInput
  }


  /**
   * neighborhood.address
   */
  export type neighborhood$addressArgs = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude | null
    where?: addressWhereInput
    orderBy?: Enumerable<addressOrderByWithRelationInput>
    cursor?: addressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * neighborhood without action
   */
  export type neighborhoodArgs = {
    /**
     * Select specific fields to fetch from the neighborhood
     */
    select?: neighborhoodSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: neighborhoodInclude | null
  }



  /**
   * Model uf
   */


  export type AggregateUf = {
    _count: UfCountAggregateOutputType | null
    _avg: UfAvgAggregateOutputType | null
    _sum: UfSumAggregateOutputType | null
    _min: UfMinAggregateOutputType | null
    _max: UfMaxAggregateOutputType | null
  }

  export type UfAvgAggregateOutputType = {
    id: number | null
  }

  export type UfSumAggregateOutputType = {
    id: number | null
  }

  export type UfMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type UfMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type UfCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type UfAvgAggregateInputType = {
    id?: true
  }

  export type UfSumAggregateInputType = {
    id?: true
  }

  export type UfMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type UfMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type UfCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type UfAggregateArgs = {
    /**
     * Filter which uf to aggregate.
     */
    where?: ufWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ufs to fetch.
     */
    orderBy?: Enumerable<ufOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ufWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ufs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ufs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ufs
    **/
    _count?: true | UfCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UfAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UfSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UfMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UfMaxAggregateInputType
  }

  export type GetUfAggregateType<T extends UfAggregateArgs> = {
        [P in keyof T & keyof AggregateUf]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUf[P]>
      : GetScalarType<T[P], AggregateUf[P]>
  }




  export type UfGroupByArgs = {
    where?: ufWhereInput
    orderBy?: Enumerable<ufOrderByWithAggregationInput>
    by: UfScalarFieldEnum[]
    having?: ufScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UfCountAggregateInputType | true
    _avg?: UfAvgAggregateInputType
    _sum?: UfSumAggregateInputType
    _min?: UfMinAggregateInputType
    _max?: UfMaxAggregateInputType
  }


  export type UfGroupByOutputType = {
    id: number
    name: string
    _count: UfCountAggregateOutputType | null
    _avg: UfAvgAggregateOutputType | null
    _sum: UfSumAggregateOutputType | null
    _min: UfMinAggregateOutputType | null
    _max: UfMaxAggregateOutputType | null
  }

  type GetUfGroupByPayload<T extends UfGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UfGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UfGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UfGroupByOutputType[P]>
            : GetScalarType<T[P], UfGroupByOutputType[P]>
        }
      >
    >


  export type ufSelect = {
    id?: boolean
    name?: boolean
    address?: boolean | uf$addressArgs
    _count?: boolean | UfCountOutputTypeArgs
  }


  export type ufInclude = {
    address?: boolean | uf$addressArgs
    _count?: boolean | UfCountOutputTypeArgs
  }

  export type ufGetPayload<S extends boolean | null | undefined | ufArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? uf :
    S extends undefined ? never :
    S extends { include: any } & (ufArgs | ufFindManyArgs)
    ? uf  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'address' ? Array < addressGetPayload<S['include'][P]>>  :
        P extends '_count' ? UfCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ufArgs | ufFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'address' ? Array < addressGetPayload<S['select'][P]>>  :
        P extends '_count' ? UfCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof uf ? uf[P] : never
  } 
      : uf


  type ufCountArgs = 
    Omit<ufFindManyArgs, 'select' | 'include'> & {
      select?: UfCountAggregateInputType | true
    }

  export interface ufDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Uf that matches the filter.
     * @param {ufFindUniqueArgs} args - Arguments to find a Uf
     * @example
     * // Get one Uf
     * const uf = await prisma.uf.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ufFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ufFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'uf'> extends True ? Prisma__ufClient<ufGetPayload<T>> : Prisma__ufClient<ufGetPayload<T> | null, null>

    /**
     * Find one Uf that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ufFindUniqueOrThrowArgs} args - Arguments to find a Uf
     * @example
     * // Get one Uf
     * const uf = await prisma.uf.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ufFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ufFindUniqueOrThrowArgs>
    ): Prisma__ufClient<ufGetPayload<T>>

    /**
     * Find the first Uf that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ufFindFirstArgs} args - Arguments to find a Uf
     * @example
     * // Get one Uf
     * const uf = await prisma.uf.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ufFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ufFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'uf'> extends True ? Prisma__ufClient<ufGetPayload<T>> : Prisma__ufClient<ufGetPayload<T> | null, null>

    /**
     * Find the first Uf that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ufFindFirstOrThrowArgs} args - Arguments to find a Uf
     * @example
     * // Get one Uf
     * const uf = await prisma.uf.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ufFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ufFindFirstOrThrowArgs>
    ): Prisma__ufClient<ufGetPayload<T>>

    /**
     * Find zero or more Ufs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ufFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ufs
     * const ufs = await prisma.uf.findMany()
     * 
     * // Get first 10 Ufs
     * const ufs = await prisma.uf.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ufWithIdOnly = await prisma.uf.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ufFindManyArgs>(
      args?: SelectSubset<T, ufFindManyArgs>
    ): Prisma.PrismaPromise<Array<ufGetPayload<T>>>

    /**
     * Create a Uf.
     * @param {ufCreateArgs} args - Arguments to create a Uf.
     * @example
     * // Create one Uf
     * const Uf = await prisma.uf.create({
     *   data: {
     *     // ... data to create a Uf
     *   }
     * })
     * 
    **/
    create<T extends ufCreateArgs>(
      args: SelectSubset<T, ufCreateArgs>
    ): Prisma__ufClient<ufGetPayload<T>>

    /**
     * Create many Ufs.
     *     @param {ufCreateManyArgs} args - Arguments to create many Ufs.
     *     @example
     *     // Create many Ufs
     *     const uf = await prisma.uf.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ufCreateManyArgs>(
      args?: SelectSubset<T, ufCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Uf.
     * @param {ufDeleteArgs} args - Arguments to delete one Uf.
     * @example
     * // Delete one Uf
     * const Uf = await prisma.uf.delete({
     *   where: {
     *     // ... filter to delete one Uf
     *   }
     * })
     * 
    **/
    delete<T extends ufDeleteArgs>(
      args: SelectSubset<T, ufDeleteArgs>
    ): Prisma__ufClient<ufGetPayload<T>>

    /**
     * Update one Uf.
     * @param {ufUpdateArgs} args - Arguments to update one Uf.
     * @example
     * // Update one Uf
     * const uf = await prisma.uf.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ufUpdateArgs>(
      args: SelectSubset<T, ufUpdateArgs>
    ): Prisma__ufClient<ufGetPayload<T>>

    /**
     * Delete zero or more Ufs.
     * @param {ufDeleteManyArgs} args - Arguments to filter Ufs to delete.
     * @example
     * // Delete a few Ufs
     * const { count } = await prisma.uf.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ufDeleteManyArgs>(
      args?: SelectSubset<T, ufDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ufs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ufUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ufs
     * const uf = await prisma.uf.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ufUpdateManyArgs>(
      args: SelectSubset<T, ufUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Uf.
     * @param {ufUpsertArgs} args - Arguments to update or create a Uf.
     * @example
     * // Update or create a Uf
     * const uf = await prisma.uf.upsert({
     *   create: {
     *     // ... data to create a Uf
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Uf we want to update
     *   }
     * })
    **/
    upsert<T extends ufUpsertArgs>(
      args: SelectSubset<T, ufUpsertArgs>
    ): Prisma__ufClient<ufGetPayload<T>>

    /**
     * Count the number of Ufs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ufCountArgs} args - Arguments to filter Ufs to count.
     * @example
     * // Count the number of Ufs
     * const count = await prisma.uf.count({
     *   where: {
     *     // ... the filter for the Ufs we want to count
     *   }
     * })
    **/
    count<T extends ufCountArgs>(
      args?: Subset<T, ufCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UfCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Uf.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UfAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UfAggregateArgs>(args: Subset<T, UfAggregateArgs>): Prisma.PrismaPromise<GetUfAggregateType<T>>

    /**
     * Group by Uf.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UfGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UfGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UfGroupByArgs['orderBy'] }
        : { orderBy?: UfGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UfGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUfGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for uf.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ufClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    address<T extends uf$addressArgs= {}>(args?: Subset<T, uf$addressArgs>): Prisma.PrismaPromise<Array<addressGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * uf base type for findUnique actions
   */
  export type ufFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the uf
     */
    select?: ufSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ufInclude | null
    /**
     * Filter, which uf to fetch.
     */
    where: ufWhereUniqueInput
  }

  /**
   * uf findUnique
   */
  export interface ufFindUniqueArgs extends ufFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * uf findUniqueOrThrow
   */
  export type ufFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the uf
     */
    select?: ufSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ufInclude | null
    /**
     * Filter, which uf to fetch.
     */
    where: ufWhereUniqueInput
  }


  /**
   * uf base type for findFirst actions
   */
  export type ufFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the uf
     */
    select?: ufSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ufInclude | null
    /**
     * Filter, which uf to fetch.
     */
    where?: ufWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ufs to fetch.
     */
    orderBy?: Enumerable<ufOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ufs.
     */
    cursor?: ufWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ufs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ufs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ufs.
     */
    distinct?: Enumerable<UfScalarFieldEnum>
  }

  /**
   * uf findFirst
   */
  export interface ufFindFirstArgs extends ufFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * uf findFirstOrThrow
   */
  export type ufFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the uf
     */
    select?: ufSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ufInclude | null
    /**
     * Filter, which uf to fetch.
     */
    where?: ufWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ufs to fetch.
     */
    orderBy?: Enumerable<ufOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ufs.
     */
    cursor?: ufWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ufs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ufs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ufs.
     */
    distinct?: Enumerable<UfScalarFieldEnum>
  }


  /**
   * uf findMany
   */
  export type ufFindManyArgs = {
    /**
     * Select specific fields to fetch from the uf
     */
    select?: ufSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ufInclude | null
    /**
     * Filter, which ufs to fetch.
     */
    where?: ufWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ufs to fetch.
     */
    orderBy?: Enumerable<ufOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ufs.
     */
    cursor?: ufWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ufs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ufs.
     */
    skip?: number
    distinct?: Enumerable<UfScalarFieldEnum>
  }


  /**
   * uf create
   */
  export type ufCreateArgs = {
    /**
     * Select specific fields to fetch from the uf
     */
    select?: ufSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ufInclude | null
    /**
     * The data needed to create a uf.
     */
    data: XOR<ufCreateInput, ufUncheckedCreateInput>
  }


  /**
   * uf createMany
   */
  export type ufCreateManyArgs = {
    /**
     * The data used to create many ufs.
     */
    data: Enumerable<ufCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * uf update
   */
  export type ufUpdateArgs = {
    /**
     * Select specific fields to fetch from the uf
     */
    select?: ufSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ufInclude | null
    /**
     * The data needed to update a uf.
     */
    data: XOR<ufUpdateInput, ufUncheckedUpdateInput>
    /**
     * Choose, which uf to update.
     */
    where: ufWhereUniqueInput
  }


  /**
   * uf updateMany
   */
  export type ufUpdateManyArgs = {
    /**
     * The data used to update ufs.
     */
    data: XOR<ufUpdateManyMutationInput, ufUncheckedUpdateManyInput>
    /**
     * Filter which ufs to update
     */
    where?: ufWhereInput
  }


  /**
   * uf upsert
   */
  export type ufUpsertArgs = {
    /**
     * Select specific fields to fetch from the uf
     */
    select?: ufSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ufInclude | null
    /**
     * The filter to search for the uf to update in case it exists.
     */
    where: ufWhereUniqueInput
    /**
     * In case the uf found by the `where` argument doesn't exist, create a new uf with this data.
     */
    create: XOR<ufCreateInput, ufUncheckedCreateInput>
    /**
     * In case the uf was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ufUpdateInput, ufUncheckedUpdateInput>
  }


  /**
   * uf delete
   */
  export type ufDeleteArgs = {
    /**
     * Select specific fields to fetch from the uf
     */
    select?: ufSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ufInclude | null
    /**
     * Filter which uf to delete.
     */
    where: ufWhereUniqueInput
  }


  /**
   * uf deleteMany
   */
  export type ufDeleteManyArgs = {
    /**
     * Filter which ufs to delete
     */
    where?: ufWhereInput
  }


  /**
   * uf.address
   */
  export type uf$addressArgs = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude | null
    where?: addressWhereInput
    orderBy?: Enumerable<addressOrderByWithRelationInput>
    cursor?: addressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * uf without action
   */
  export type ufArgs = {
    /**
     * Select specific fields to fetch from the uf
     */
    select?: ufSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ufInclude | null
  }



  /**
   * Model category_of_product
   */


  export type AggregateCategory_of_product = {
    _count: Category_of_productCountAggregateOutputType | null
    _avg: Category_of_productAvgAggregateOutputType | null
    _sum: Category_of_productSumAggregateOutputType | null
    _min: Category_of_productMinAggregateOutputType | null
    _max: Category_of_productMaxAggregateOutputType | null
  }

  export type Category_of_productAvgAggregateOutputType = {
    id: number | null
    imageId: number | null
  }

  export type Category_of_productSumAggregateOutputType = {
    id: number | null
    imageId: number | null
  }

  export type Category_of_productMinAggregateOutputType = {
    id: number | null
    imageId: number | null
    name: string | null
  }

  export type Category_of_productMaxAggregateOutputType = {
    id: number | null
    imageId: number | null
    name: string | null
  }

  export type Category_of_productCountAggregateOutputType = {
    id: number
    imageId: number
    name: number
    _all: number
  }


  export type Category_of_productAvgAggregateInputType = {
    id?: true
    imageId?: true
  }

  export type Category_of_productSumAggregateInputType = {
    id?: true
    imageId?: true
  }

  export type Category_of_productMinAggregateInputType = {
    id?: true
    imageId?: true
    name?: true
  }

  export type Category_of_productMaxAggregateInputType = {
    id?: true
    imageId?: true
    name?: true
  }

  export type Category_of_productCountAggregateInputType = {
    id?: true
    imageId?: true
    name?: true
    _all?: true
  }

  export type Category_of_productAggregateArgs = {
    /**
     * Filter which category_of_product to aggregate.
     */
    where?: category_of_productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of category_of_products to fetch.
     */
    orderBy?: Enumerable<category_of_productOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: category_of_productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` category_of_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` category_of_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned category_of_products
    **/
    _count?: true | Category_of_productCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Category_of_productAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Category_of_productSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Category_of_productMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Category_of_productMaxAggregateInputType
  }

  export type GetCategory_of_productAggregateType<T extends Category_of_productAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory_of_product]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory_of_product[P]>
      : GetScalarType<T[P], AggregateCategory_of_product[P]>
  }




  export type Category_of_productGroupByArgs = {
    where?: category_of_productWhereInput
    orderBy?: Enumerable<category_of_productOrderByWithAggregationInput>
    by: Category_of_productScalarFieldEnum[]
    having?: category_of_productScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Category_of_productCountAggregateInputType | true
    _avg?: Category_of_productAvgAggregateInputType
    _sum?: Category_of_productSumAggregateInputType
    _min?: Category_of_productMinAggregateInputType
    _max?: Category_of_productMaxAggregateInputType
  }


  export type Category_of_productGroupByOutputType = {
    id: number
    imageId: number
    name: string
    _count: Category_of_productCountAggregateOutputType | null
    _avg: Category_of_productAvgAggregateOutputType | null
    _sum: Category_of_productSumAggregateOutputType | null
    _min: Category_of_productMinAggregateOutputType | null
    _max: Category_of_productMaxAggregateOutputType | null
  }

  type GetCategory_of_productGroupByPayload<T extends Category_of_productGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Category_of_productGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Category_of_productGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Category_of_productGroupByOutputType[P]>
            : GetScalarType<T[P], Category_of_productGroupByOutputType[P]>
        }
      >
    >


  export type category_of_productSelect = {
    id?: boolean
    imageId?: boolean
    name?: boolean
    image?: boolean | imageArgs
    product?: boolean | category_of_product$productArgs
    _count?: boolean | Category_of_productCountOutputTypeArgs
  }


  export type category_of_productInclude = {
    image?: boolean | imageArgs
    product?: boolean | category_of_product$productArgs
    _count?: boolean | Category_of_productCountOutputTypeArgs
  }

  export type category_of_productGetPayload<S extends boolean | null | undefined | category_of_productArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? category_of_product :
    S extends undefined ? never :
    S extends { include: any } & (category_of_productArgs | category_of_productFindManyArgs)
    ? category_of_product  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'image' ? imageGetPayload<S['include'][P]> :
        P extends 'product' ? Array < productGetPayload<S['include'][P]>>  :
        P extends '_count' ? Category_of_productCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (category_of_productArgs | category_of_productFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'image' ? imageGetPayload<S['select'][P]> :
        P extends 'product' ? Array < productGetPayload<S['select'][P]>>  :
        P extends '_count' ? Category_of_productCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof category_of_product ? category_of_product[P] : never
  } 
      : category_of_product


  type category_of_productCountArgs = 
    Omit<category_of_productFindManyArgs, 'select' | 'include'> & {
      select?: Category_of_productCountAggregateInputType | true
    }

  export interface category_of_productDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Category_of_product that matches the filter.
     * @param {category_of_productFindUniqueArgs} args - Arguments to find a Category_of_product
     * @example
     * // Get one Category_of_product
     * const category_of_product = await prisma.category_of_product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends category_of_productFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, category_of_productFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'category_of_product'> extends True ? Prisma__category_of_productClient<category_of_productGetPayload<T>> : Prisma__category_of_productClient<category_of_productGetPayload<T> | null, null>

    /**
     * Find one Category_of_product that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {category_of_productFindUniqueOrThrowArgs} args - Arguments to find a Category_of_product
     * @example
     * // Get one Category_of_product
     * const category_of_product = await prisma.category_of_product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends category_of_productFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, category_of_productFindUniqueOrThrowArgs>
    ): Prisma__category_of_productClient<category_of_productGetPayload<T>>

    /**
     * Find the first Category_of_product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_of_productFindFirstArgs} args - Arguments to find a Category_of_product
     * @example
     * // Get one Category_of_product
     * const category_of_product = await prisma.category_of_product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends category_of_productFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, category_of_productFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'category_of_product'> extends True ? Prisma__category_of_productClient<category_of_productGetPayload<T>> : Prisma__category_of_productClient<category_of_productGetPayload<T> | null, null>

    /**
     * Find the first Category_of_product that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_of_productFindFirstOrThrowArgs} args - Arguments to find a Category_of_product
     * @example
     * // Get one Category_of_product
     * const category_of_product = await prisma.category_of_product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends category_of_productFindFirstOrThrowArgs>(
      args?: SelectSubset<T, category_of_productFindFirstOrThrowArgs>
    ): Prisma__category_of_productClient<category_of_productGetPayload<T>>

    /**
     * Find zero or more Category_of_products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_of_productFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Category_of_products
     * const category_of_products = await prisma.category_of_product.findMany()
     * 
     * // Get first 10 Category_of_products
     * const category_of_products = await prisma.category_of_product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const category_of_productWithIdOnly = await prisma.category_of_product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends category_of_productFindManyArgs>(
      args?: SelectSubset<T, category_of_productFindManyArgs>
    ): Prisma.PrismaPromise<Array<category_of_productGetPayload<T>>>

    /**
     * Create a Category_of_product.
     * @param {category_of_productCreateArgs} args - Arguments to create a Category_of_product.
     * @example
     * // Create one Category_of_product
     * const Category_of_product = await prisma.category_of_product.create({
     *   data: {
     *     // ... data to create a Category_of_product
     *   }
     * })
     * 
    **/
    create<T extends category_of_productCreateArgs>(
      args: SelectSubset<T, category_of_productCreateArgs>
    ): Prisma__category_of_productClient<category_of_productGetPayload<T>>

    /**
     * Create many Category_of_products.
     *     @param {category_of_productCreateManyArgs} args - Arguments to create many Category_of_products.
     *     @example
     *     // Create many Category_of_products
     *     const category_of_product = await prisma.category_of_product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends category_of_productCreateManyArgs>(
      args?: SelectSubset<T, category_of_productCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category_of_product.
     * @param {category_of_productDeleteArgs} args - Arguments to delete one Category_of_product.
     * @example
     * // Delete one Category_of_product
     * const Category_of_product = await prisma.category_of_product.delete({
     *   where: {
     *     // ... filter to delete one Category_of_product
     *   }
     * })
     * 
    **/
    delete<T extends category_of_productDeleteArgs>(
      args: SelectSubset<T, category_of_productDeleteArgs>
    ): Prisma__category_of_productClient<category_of_productGetPayload<T>>

    /**
     * Update one Category_of_product.
     * @param {category_of_productUpdateArgs} args - Arguments to update one Category_of_product.
     * @example
     * // Update one Category_of_product
     * const category_of_product = await prisma.category_of_product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends category_of_productUpdateArgs>(
      args: SelectSubset<T, category_of_productUpdateArgs>
    ): Prisma__category_of_productClient<category_of_productGetPayload<T>>

    /**
     * Delete zero or more Category_of_products.
     * @param {category_of_productDeleteManyArgs} args - Arguments to filter Category_of_products to delete.
     * @example
     * // Delete a few Category_of_products
     * const { count } = await prisma.category_of_product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends category_of_productDeleteManyArgs>(
      args?: SelectSubset<T, category_of_productDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Category_of_products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_of_productUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Category_of_products
     * const category_of_product = await prisma.category_of_product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends category_of_productUpdateManyArgs>(
      args: SelectSubset<T, category_of_productUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category_of_product.
     * @param {category_of_productUpsertArgs} args - Arguments to update or create a Category_of_product.
     * @example
     * // Update or create a Category_of_product
     * const category_of_product = await prisma.category_of_product.upsert({
     *   create: {
     *     // ... data to create a Category_of_product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category_of_product we want to update
     *   }
     * })
    **/
    upsert<T extends category_of_productUpsertArgs>(
      args: SelectSubset<T, category_of_productUpsertArgs>
    ): Prisma__category_of_productClient<category_of_productGetPayload<T>>

    /**
     * Count the number of Category_of_products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {category_of_productCountArgs} args - Arguments to filter Category_of_products to count.
     * @example
     * // Count the number of Category_of_products
     * const count = await prisma.category_of_product.count({
     *   where: {
     *     // ... the filter for the Category_of_products we want to count
     *   }
     * })
    **/
    count<T extends category_of_productCountArgs>(
      args?: Subset<T, category_of_productCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Category_of_productCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category_of_product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Category_of_productAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Category_of_productAggregateArgs>(args: Subset<T, Category_of_productAggregateArgs>): Prisma.PrismaPromise<GetCategory_of_productAggregateType<T>>

    /**
     * Group by Category_of_product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Category_of_productGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Category_of_productGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Category_of_productGroupByArgs['orderBy'] }
        : { orderBy?: Category_of_productGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Category_of_productGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategory_of_productGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for category_of_product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__category_of_productClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    image<T extends imageArgs= {}>(args?: Subset<T, imageArgs>): Prisma__imageClient<imageGetPayload<T> | Null>;

    product<T extends category_of_product$productArgs= {}>(args?: Subset<T, category_of_product$productArgs>): Prisma.PrismaPromise<Array<productGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * category_of_product base type for findUnique actions
   */
  export type category_of_productFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the category_of_product
     */
    select?: category_of_productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: category_of_productInclude | null
    /**
     * Filter, which category_of_product to fetch.
     */
    where: category_of_productWhereUniqueInput
  }

  /**
   * category_of_product findUnique
   */
  export interface category_of_productFindUniqueArgs extends category_of_productFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * category_of_product findUniqueOrThrow
   */
  export type category_of_productFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the category_of_product
     */
    select?: category_of_productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: category_of_productInclude | null
    /**
     * Filter, which category_of_product to fetch.
     */
    where: category_of_productWhereUniqueInput
  }


  /**
   * category_of_product base type for findFirst actions
   */
  export type category_of_productFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the category_of_product
     */
    select?: category_of_productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: category_of_productInclude | null
    /**
     * Filter, which category_of_product to fetch.
     */
    where?: category_of_productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of category_of_products to fetch.
     */
    orderBy?: Enumerable<category_of_productOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for category_of_products.
     */
    cursor?: category_of_productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` category_of_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` category_of_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of category_of_products.
     */
    distinct?: Enumerable<Category_of_productScalarFieldEnum>
  }

  /**
   * category_of_product findFirst
   */
  export interface category_of_productFindFirstArgs extends category_of_productFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * category_of_product findFirstOrThrow
   */
  export type category_of_productFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the category_of_product
     */
    select?: category_of_productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: category_of_productInclude | null
    /**
     * Filter, which category_of_product to fetch.
     */
    where?: category_of_productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of category_of_products to fetch.
     */
    orderBy?: Enumerable<category_of_productOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for category_of_products.
     */
    cursor?: category_of_productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` category_of_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` category_of_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of category_of_products.
     */
    distinct?: Enumerable<Category_of_productScalarFieldEnum>
  }


  /**
   * category_of_product findMany
   */
  export type category_of_productFindManyArgs = {
    /**
     * Select specific fields to fetch from the category_of_product
     */
    select?: category_of_productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: category_of_productInclude | null
    /**
     * Filter, which category_of_products to fetch.
     */
    where?: category_of_productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of category_of_products to fetch.
     */
    orderBy?: Enumerable<category_of_productOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing category_of_products.
     */
    cursor?: category_of_productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` category_of_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` category_of_products.
     */
    skip?: number
    distinct?: Enumerable<Category_of_productScalarFieldEnum>
  }


  /**
   * category_of_product create
   */
  export type category_of_productCreateArgs = {
    /**
     * Select specific fields to fetch from the category_of_product
     */
    select?: category_of_productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: category_of_productInclude | null
    /**
     * The data needed to create a category_of_product.
     */
    data: XOR<category_of_productCreateInput, category_of_productUncheckedCreateInput>
  }


  /**
   * category_of_product createMany
   */
  export type category_of_productCreateManyArgs = {
    /**
     * The data used to create many category_of_products.
     */
    data: Enumerable<category_of_productCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * category_of_product update
   */
  export type category_of_productUpdateArgs = {
    /**
     * Select specific fields to fetch from the category_of_product
     */
    select?: category_of_productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: category_of_productInclude | null
    /**
     * The data needed to update a category_of_product.
     */
    data: XOR<category_of_productUpdateInput, category_of_productUncheckedUpdateInput>
    /**
     * Choose, which category_of_product to update.
     */
    where: category_of_productWhereUniqueInput
  }


  /**
   * category_of_product updateMany
   */
  export type category_of_productUpdateManyArgs = {
    /**
     * The data used to update category_of_products.
     */
    data: XOR<category_of_productUpdateManyMutationInput, category_of_productUncheckedUpdateManyInput>
    /**
     * Filter which category_of_products to update
     */
    where?: category_of_productWhereInput
  }


  /**
   * category_of_product upsert
   */
  export type category_of_productUpsertArgs = {
    /**
     * Select specific fields to fetch from the category_of_product
     */
    select?: category_of_productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: category_of_productInclude | null
    /**
     * The filter to search for the category_of_product to update in case it exists.
     */
    where: category_of_productWhereUniqueInput
    /**
     * In case the category_of_product found by the `where` argument doesn't exist, create a new category_of_product with this data.
     */
    create: XOR<category_of_productCreateInput, category_of_productUncheckedCreateInput>
    /**
     * In case the category_of_product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<category_of_productUpdateInput, category_of_productUncheckedUpdateInput>
  }


  /**
   * category_of_product delete
   */
  export type category_of_productDeleteArgs = {
    /**
     * Select specific fields to fetch from the category_of_product
     */
    select?: category_of_productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: category_of_productInclude | null
    /**
     * Filter which category_of_product to delete.
     */
    where: category_of_productWhereUniqueInput
  }


  /**
   * category_of_product deleteMany
   */
  export type category_of_productDeleteManyArgs = {
    /**
     * Filter which category_of_products to delete
     */
    where?: category_of_productWhereInput
  }


  /**
   * category_of_product.product
   */
  export type category_of_product$productArgs = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude | null
    where?: productWhereInput
    orderBy?: Enumerable<productOrderByWithRelationInput>
    cursor?: productWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * category_of_product without action
   */
  export type category_of_productArgs = {
    /**
     * Select specific fields to fetch from the category_of_product
     */
    select?: category_of_productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: category_of_productInclude | null
  }



  /**
   * Model sale_off
   */


  export type AggregateSale_off = {
    _count: Sale_offCountAggregateOutputType | null
    _avg: Sale_offAvgAggregateOutputType | null
    _sum: Sale_offSumAggregateOutputType | null
    _min: Sale_offMinAggregateOutputType | null
    _max: Sale_offMaxAggregateOutputType | null
  }

  export type Sale_offAvgAggregateOutputType = {
    id: number | null
    value: number | null
    productId: number | null
  }

  export type Sale_offSumAggregateOutputType = {
    id: number | null
    value: number | null
    productId: number | null
  }

  export type Sale_offMinAggregateOutputType = {
    id: number | null
    value: number | null
    productId: number | null
  }

  export type Sale_offMaxAggregateOutputType = {
    id: number | null
    value: number | null
    productId: number | null
  }

  export type Sale_offCountAggregateOutputType = {
    id: number
    value: number
    productId: number
    _all: number
  }


  export type Sale_offAvgAggregateInputType = {
    id?: true
    value?: true
    productId?: true
  }

  export type Sale_offSumAggregateInputType = {
    id?: true
    value?: true
    productId?: true
  }

  export type Sale_offMinAggregateInputType = {
    id?: true
    value?: true
    productId?: true
  }

  export type Sale_offMaxAggregateInputType = {
    id?: true
    value?: true
    productId?: true
  }

  export type Sale_offCountAggregateInputType = {
    id?: true
    value?: true
    productId?: true
    _all?: true
  }

  export type Sale_offAggregateArgs = {
    /**
     * Filter which sale_off to aggregate.
     */
    where?: sale_offWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sale_offs to fetch.
     */
    orderBy?: Enumerable<sale_offOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sale_offWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sale_offs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sale_offs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sale_offs
    **/
    _count?: true | Sale_offCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Sale_offAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Sale_offSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sale_offMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sale_offMaxAggregateInputType
  }

  export type GetSale_offAggregateType<T extends Sale_offAggregateArgs> = {
        [P in keyof T & keyof AggregateSale_off]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSale_off[P]>
      : GetScalarType<T[P], AggregateSale_off[P]>
  }




  export type Sale_offGroupByArgs = {
    where?: sale_offWhereInput
    orderBy?: Enumerable<sale_offOrderByWithAggregationInput>
    by: Sale_offScalarFieldEnum[]
    having?: sale_offScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sale_offCountAggregateInputType | true
    _avg?: Sale_offAvgAggregateInputType
    _sum?: Sale_offSumAggregateInputType
    _min?: Sale_offMinAggregateInputType
    _max?: Sale_offMaxAggregateInputType
  }


  export type Sale_offGroupByOutputType = {
    id: number
    value: number
    productId: number
    _count: Sale_offCountAggregateOutputType | null
    _avg: Sale_offAvgAggregateOutputType | null
    _sum: Sale_offSumAggregateOutputType | null
    _min: Sale_offMinAggregateOutputType | null
    _max: Sale_offMaxAggregateOutputType | null
  }

  type GetSale_offGroupByPayload<T extends Sale_offGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Sale_offGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sale_offGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sale_offGroupByOutputType[P]>
            : GetScalarType<T[P], Sale_offGroupByOutputType[P]>
        }
      >
    >


  export type sale_offSelect = {
    id?: boolean
    value?: boolean
    productId?: boolean
    product?: boolean | productArgs
  }


  export type sale_offInclude = {
    product?: boolean | productArgs
  }

  export type sale_offGetPayload<S extends boolean | null | undefined | sale_offArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? sale_off :
    S extends undefined ? never :
    S extends { include: any } & (sale_offArgs | sale_offFindManyArgs)
    ? sale_off  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'product' ? productGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (sale_offArgs | sale_offFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'product' ? productGetPayload<S['select'][P]> :  P extends keyof sale_off ? sale_off[P] : never
  } 
      : sale_off


  type sale_offCountArgs = 
    Omit<sale_offFindManyArgs, 'select' | 'include'> & {
      select?: Sale_offCountAggregateInputType | true
    }

  export interface sale_offDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Sale_off that matches the filter.
     * @param {sale_offFindUniqueArgs} args - Arguments to find a Sale_off
     * @example
     * // Get one Sale_off
     * const sale_off = await prisma.sale_off.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sale_offFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, sale_offFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'sale_off'> extends True ? Prisma__sale_offClient<sale_offGetPayload<T>> : Prisma__sale_offClient<sale_offGetPayload<T> | null, null>

    /**
     * Find one Sale_off that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {sale_offFindUniqueOrThrowArgs} args - Arguments to find a Sale_off
     * @example
     * // Get one Sale_off
     * const sale_off = await prisma.sale_off.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends sale_offFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, sale_offFindUniqueOrThrowArgs>
    ): Prisma__sale_offClient<sale_offGetPayload<T>>

    /**
     * Find the first Sale_off that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sale_offFindFirstArgs} args - Arguments to find a Sale_off
     * @example
     * // Get one Sale_off
     * const sale_off = await prisma.sale_off.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sale_offFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, sale_offFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'sale_off'> extends True ? Prisma__sale_offClient<sale_offGetPayload<T>> : Prisma__sale_offClient<sale_offGetPayload<T> | null, null>

    /**
     * Find the first Sale_off that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sale_offFindFirstOrThrowArgs} args - Arguments to find a Sale_off
     * @example
     * // Get one Sale_off
     * const sale_off = await prisma.sale_off.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends sale_offFindFirstOrThrowArgs>(
      args?: SelectSubset<T, sale_offFindFirstOrThrowArgs>
    ): Prisma__sale_offClient<sale_offGetPayload<T>>

    /**
     * Find zero or more Sale_offs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sale_offFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sale_offs
     * const sale_offs = await prisma.sale_off.findMany()
     * 
     * // Get first 10 Sale_offs
     * const sale_offs = await prisma.sale_off.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sale_offWithIdOnly = await prisma.sale_off.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends sale_offFindManyArgs>(
      args?: SelectSubset<T, sale_offFindManyArgs>
    ): Prisma.PrismaPromise<Array<sale_offGetPayload<T>>>

    /**
     * Create a Sale_off.
     * @param {sale_offCreateArgs} args - Arguments to create a Sale_off.
     * @example
     * // Create one Sale_off
     * const Sale_off = await prisma.sale_off.create({
     *   data: {
     *     // ... data to create a Sale_off
     *   }
     * })
     * 
    **/
    create<T extends sale_offCreateArgs>(
      args: SelectSubset<T, sale_offCreateArgs>
    ): Prisma__sale_offClient<sale_offGetPayload<T>>

    /**
     * Create many Sale_offs.
     *     @param {sale_offCreateManyArgs} args - Arguments to create many Sale_offs.
     *     @example
     *     // Create many Sale_offs
     *     const sale_off = await prisma.sale_off.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends sale_offCreateManyArgs>(
      args?: SelectSubset<T, sale_offCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sale_off.
     * @param {sale_offDeleteArgs} args - Arguments to delete one Sale_off.
     * @example
     * // Delete one Sale_off
     * const Sale_off = await prisma.sale_off.delete({
     *   where: {
     *     // ... filter to delete one Sale_off
     *   }
     * })
     * 
    **/
    delete<T extends sale_offDeleteArgs>(
      args: SelectSubset<T, sale_offDeleteArgs>
    ): Prisma__sale_offClient<sale_offGetPayload<T>>

    /**
     * Update one Sale_off.
     * @param {sale_offUpdateArgs} args - Arguments to update one Sale_off.
     * @example
     * // Update one Sale_off
     * const sale_off = await prisma.sale_off.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sale_offUpdateArgs>(
      args: SelectSubset<T, sale_offUpdateArgs>
    ): Prisma__sale_offClient<sale_offGetPayload<T>>

    /**
     * Delete zero or more Sale_offs.
     * @param {sale_offDeleteManyArgs} args - Arguments to filter Sale_offs to delete.
     * @example
     * // Delete a few Sale_offs
     * const { count } = await prisma.sale_off.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sale_offDeleteManyArgs>(
      args?: SelectSubset<T, sale_offDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sale_offs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sale_offUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sale_offs
     * const sale_off = await prisma.sale_off.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sale_offUpdateManyArgs>(
      args: SelectSubset<T, sale_offUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sale_off.
     * @param {sale_offUpsertArgs} args - Arguments to update or create a Sale_off.
     * @example
     * // Update or create a Sale_off
     * const sale_off = await prisma.sale_off.upsert({
     *   create: {
     *     // ... data to create a Sale_off
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sale_off we want to update
     *   }
     * })
    **/
    upsert<T extends sale_offUpsertArgs>(
      args: SelectSubset<T, sale_offUpsertArgs>
    ): Prisma__sale_offClient<sale_offGetPayload<T>>

    /**
     * Count the number of Sale_offs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sale_offCountArgs} args - Arguments to filter Sale_offs to count.
     * @example
     * // Count the number of Sale_offs
     * const count = await prisma.sale_off.count({
     *   where: {
     *     // ... the filter for the Sale_offs we want to count
     *   }
     * })
    **/
    count<T extends sale_offCountArgs>(
      args?: Subset<T, sale_offCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sale_offCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sale_off.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sale_offAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sale_offAggregateArgs>(args: Subset<T, Sale_offAggregateArgs>): Prisma.PrismaPromise<GetSale_offAggregateType<T>>

    /**
     * Group by Sale_off.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sale_offGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Sale_offGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Sale_offGroupByArgs['orderBy'] }
        : { orderBy?: Sale_offGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Sale_offGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSale_offGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for sale_off.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__sale_offClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    product<T extends productArgs= {}>(args?: Subset<T, productArgs>): Prisma__productClient<productGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * sale_off base type for findUnique actions
   */
  export type sale_offFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the sale_off
     */
    select?: sale_offSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sale_offInclude | null
    /**
     * Filter, which sale_off to fetch.
     */
    where: sale_offWhereUniqueInput
  }

  /**
   * sale_off findUnique
   */
  export interface sale_offFindUniqueArgs extends sale_offFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * sale_off findUniqueOrThrow
   */
  export type sale_offFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the sale_off
     */
    select?: sale_offSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sale_offInclude | null
    /**
     * Filter, which sale_off to fetch.
     */
    where: sale_offWhereUniqueInput
  }


  /**
   * sale_off base type for findFirst actions
   */
  export type sale_offFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the sale_off
     */
    select?: sale_offSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sale_offInclude | null
    /**
     * Filter, which sale_off to fetch.
     */
    where?: sale_offWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sale_offs to fetch.
     */
    orderBy?: Enumerable<sale_offOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sale_offs.
     */
    cursor?: sale_offWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sale_offs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sale_offs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sale_offs.
     */
    distinct?: Enumerable<Sale_offScalarFieldEnum>
  }

  /**
   * sale_off findFirst
   */
  export interface sale_offFindFirstArgs extends sale_offFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * sale_off findFirstOrThrow
   */
  export type sale_offFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the sale_off
     */
    select?: sale_offSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sale_offInclude | null
    /**
     * Filter, which sale_off to fetch.
     */
    where?: sale_offWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sale_offs to fetch.
     */
    orderBy?: Enumerable<sale_offOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sale_offs.
     */
    cursor?: sale_offWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sale_offs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sale_offs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sale_offs.
     */
    distinct?: Enumerable<Sale_offScalarFieldEnum>
  }


  /**
   * sale_off findMany
   */
  export type sale_offFindManyArgs = {
    /**
     * Select specific fields to fetch from the sale_off
     */
    select?: sale_offSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sale_offInclude | null
    /**
     * Filter, which sale_offs to fetch.
     */
    where?: sale_offWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sale_offs to fetch.
     */
    orderBy?: Enumerable<sale_offOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sale_offs.
     */
    cursor?: sale_offWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sale_offs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sale_offs.
     */
    skip?: number
    distinct?: Enumerable<Sale_offScalarFieldEnum>
  }


  /**
   * sale_off create
   */
  export type sale_offCreateArgs = {
    /**
     * Select specific fields to fetch from the sale_off
     */
    select?: sale_offSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sale_offInclude | null
    /**
     * The data needed to create a sale_off.
     */
    data: XOR<sale_offCreateInput, sale_offUncheckedCreateInput>
  }


  /**
   * sale_off createMany
   */
  export type sale_offCreateManyArgs = {
    /**
     * The data used to create many sale_offs.
     */
    data: Enumerable<sale_offCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * sale_off update
   */
  export type sale_offUpdateArgs = {
    /**
     * Select specific fields to fetch from the sale_off
     */
    select?: sale_offSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sale_offInclude | null
    /**
     * The data needed to update a sale_off.
     */
    data: XOR<sale_offUpdateInput, sale_offUncheckedUpdateInput>
    /**
     * Choose, which sale_off to update.
     */
    where: sale_offWhereUniqueInput
  }


  /**
   * sale_off updateMany
   */
  export type sale_offUpdateManyArgs = {
    /**
     * The data used to update sale_offs.
     */
    data: XOR<sale_offUpdateManyMutationInput, sale_offUncheckedUpdateManyInput>
    /**
     * Filter which sale_offs to update
     */
    where?: sale_offWhereInput
  }


  /**
   * sale_off upsert
   */
  export type sale_offUpsertArgs = {
    /**
     * Select specific fields to fetch from the sale_off
     */
    select?: sale_offSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sale_offInclude | null
    /**
     * The filter to search for the sale_off to update in case it exists.
     */
    where: sale_offWhereUniqueInput
    /**
     * In case the sale_off found by the `where` argument doesn't exist, create a new sale_off with this data.
     */
    create: XOR<sale_offCreateInput, sale_offUncheckedCreateInput>
    /**
     * In case the sale_off was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sale_offUpdateInput, sale_offUncheckedUpdateInput>
  }


  /**
   * sale_off delete
   */
  export type sale_offDeleteArgs = {
    /**
     * Select specific fields to fetch from the sale_off
     */
    select?: sale_offSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sale_offInclude | null
    /**
     * Filter which sale_off to delete.
     */
    where: sale_offWhereUniqueInput
  }


  /**
   * sale_off deleteMany
   */
  export type sale_offDeleteManyArgs = {
    /**
     * Filter which sale_offs to delete
     */
    where?: sale_offWhereInput
  }


  /**
   * sale_off without action
   */
  export type sale_offArgs = {
    /**
     * Select specific fields to fetch from the sale_off
     */
    select?: sale_offSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: sale_offInclude | null
  }



  /**
   * Model type_of_price
   */


  export type AggregateType_of_price = {
    _count: Type_of_priceCountAggregateOutputType | null
    _avg: Type_of_priceAvgAggregateOutputType | null
    _sum: Type_of_priceSumAggregateOutputType | null
    _min: Type_of_priceMinAggregateOutputType | null
    _max: Type_of_priceMaxAggregateOutputType | null
  }

  export type Type_of_priceAvgAggregateOutputType = {
    id: number | null
  }

  export type Type_of_priceSumAggregateOutputType = {
    id: number | null
  }

  export type Type_of_priceMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type Type_of_priceMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type Type_of_priceCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type Type_of_priceAvgAggregateInputType = {
    id?: true
  }

  export type Type_of_priceSumAggregateInputType = {
    id?: true
  }

  export type Type_of_priceMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Type_of_priceMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Type_of_priceCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Type_of_priceAggregateArgs = {
    /**
     * Filter which type_of_price to aggregate.
     */
    where?: type_of_priceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of type_of_prices to fetch.
     */
    orderBy?: Enumerable<type_of_priceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: type_of_priceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` type_of_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` type_of_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned type_of_prices
    **/
    _count?: true | Type_of_priceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Type_of_priceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Type_of_priceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Type_of_priceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Type_of_priceMaxAggregateInputType
  }

  export type GetType_of_priceAggregateType<T extends Type_of_priceAggregateArgs> = {
        [P in keyof T & keyof AggregateType_of_price]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateType_of_price[P]>
      : GetScalarType<T[P], AggregateType_of_price[P]>
  }




  export type Type_of_priceGroupByArgs = {
    where?: type_of_priceWhereInput
    orderBy?: Enumerable<type_of_priceOrderByWithAggregationInput>
    by: Type_of_priceScalarFieldEnum[]
    having?: type_of_priceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Type_of_priceCountAggregateInputType | true
    _avg?: Type_of_priceAvgAggregateInputType
    _sum?: Type_of_priceSumAggregateInputType
    _min?: Type_of_priceMinAggregateInputType
    _max?: Type_of_priceMaxAggregateInputType
  }


  export type Type_of_priceGroupByOutputType = {
    id: number
    name: string
    _count: Type_of_priceCountAggregateOutputType | null
    _avg: Type_of_priceAvgAggregateOutputType | null
    _sum: Type_of_priceSumAggregateOutputType | null
    _min: Type_of_priceMinAggregateOutputType | null
    _max: Type_of_priceMaxAggregateOutputType | null
  }

  type GetType_of_priceGroupByPayload<T extends Type_of_priceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Type_of_priceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Type_of_priceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Type_of_priceGroupByOutputType[P]>
            : GetScalarType<T[P], Type_of_priceGroupByOutputType[P]>
        }
      >
    >


  export type type_of_priceSelect = {
    id?: boolean
    name?: boolean
    product?: boolean | type_of_price$productArgs
    _count?: boolean | Type_of_priceCountOutputTypeArgs
  }


  export type type_of_priceInclude = {
    product?: boolean | type_of_price$productArgs
    _count?: boolean | Type_of_priceCountOutputTypeArgs
  }

  export type type_of_priceGetPayload<S extends boolean | null | undefined | type_of_priceArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? type_of_price :
    S extends undefined ? never :
    S extends { include: any } & (type_of_priceArgs | type_of_priceFindManyArgs)
    ? type_of_price  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'product' ? Array < productGetPayload<S['include'][P]>>  :
        P extends '_count' ? Type_of_priceCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (type_of_priceArgs | type_of_priceFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'product' ? Array < productGetPayload<S['select'][P]>>  :
        P extends '_count' ? Type_of_priceCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof type_of_price ? type_of_price[P] : never
  } 
      : type_of_price


  type type_of_priceCountArgs = 
    Omit<type_of_priceFindManyArgs, 'select' | 'include'> & {
      select?: Type_of_priceCountAggregateInputType | true
    }

  export interface type_of_priceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Type_of_price that matches the filter.
     * @param {type_of_priceFindUniqueArgs} args - Arguments to find a Type_of_price
     * @example
     * // Get one Type_of_price
     * const type_of_price = await prisma.type_of_price.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends type_of_priceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, type_of_priceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'type_of_price'> extends True ? Prisma__type_of_priceClient<type_of_priceGetPayload<T>> : Prisma__type_of_priceClient<type_of_priceGetPayload<T> | null, null>

    /**
     * Find one Type_of_price that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {type_of_priceFindUniqueOrThrowArgs} args - Arguments to find a Type_of_price
     * @example
     * // Get one Type_of_price
     * const type_of_price = await prisma.type_of_price.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends type_of_priceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, type_of_priceFindUniqueOrThrowArgs>
    ): Prisma__type_of_priceClient<type_of_priceGetPayload<T>>

    /**
     * Find the first Type_of_price that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_of_priceFindFirstArgs} args - Arguments to find a Type_of_price
     * @example
     * // Get one Type_of_price
     * const type_of_price = await prisma.type_of_price.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends type_of_priceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, type_of_priceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'type_of_price'> extends True ? Prisma__type_of_priceClient<type_of_priceGetPayload<T>> : Prisma__type_of_priceClient<type_of_priceGetPayload<T> | null, null>

    /**
     * Find the first Type_of_price that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_of_priceFindFirstOrThrowArgs} args - Arguments to find a Type_of_price
     * @example
     * // Get one Type_of_price
     * const type_of_price = await prisma.type_of_price.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends type_of_priceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, type_of_priceFindFirstOrThrowArgs>
    ): Prisma__type_of_priceClient<type_of_priceGetPayload<T>>

    /**
     * Find zero or more Type_of_prices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_of_priceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Type_of_prices
     * const type_of_prices = await prisma.type_of_price.findMany()
     * 
     * // Get first 10 Type_of_prices
     * const type_of_prices = await prisma.type_of_price.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const type_of_priceWithIdOnly = await prisma.type_of_price.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends type_of_priceFindManyArgs>(
      args?: SelectSubset<T, type_of_priceFindManyArgs>
    ): Prisma.PrismaPromise<Array<type_of_priceGetPayload<T>>>

    /**
     * Create a Type_of_price.
     * @param {type_of_priceCreateArgs} args - Arguments to create a Type_of_price.
     * @example
     * // Create one Type_of_price
     * const Type_of_price = await prisma.type_of_price.create({
     *   data: {
     *     // ... data to create a Type_of_price
     *   }
     * })
     * 
    **/
    create<T extends type_of_priceCreateArgs>(
      args: SelectSubset<T, type_of_priceCreateArgs>
    ): Prisma__type_of_priceClient<type_of_priceGetPayload<T>>

    /**
     * Create many Type_of_prices.
     *     @param {type_of_priceCreateManyArgs} args - Arguments to create many Type_of_prices.
     *     @example
     *     // Create many Type_of_prices
     *     const type_of_price = await prisma.type_of_price.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends type_of_priceCreateManyArgs>(
      args?: SelectSubset<T, type_of_priceCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Type_of_price.
     * @param {type_of_priceDeleteArgs} args - Arguments to delete one Type_of_price.
     * @example
     * // Delete one Type_of_price
     * const Type_of_price = await prisma.type_of_price.delete({
     *   where: {
     *     // ... filter to delete one Type_of_price
     *   }
     * })
     * 
    **/
    delete<T extends type_of_priceDeleteArgs>(
      args: SelectSubset<T, type_of_priceDeleteArgs>
    ): Prisma__type_of_priceClient<type_of_priceGetPayload<T>>

    /**
     * Update one Type_of_price.
     * @param {type_of_priceUpdateArgs} args - Arguments to update one Type_of_price.
     * @example
     * // Update one Type_of_price
     * const type_of_price = await prisma.type_of_price.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends type_of_priceUpdateArgs>(
      args: SelectSubset<T, type_of_priceUpdateArgs>
    ): Prisma__type_of_priceClient<type_of_priceGetPayload<T>>

    /**
     * Delete zero or more Type_of_prices.
     * @param {type_of_priceDeleteManyArgs} args - Arguments to filter Type_of_prices to delete.
     * @example
     * // Delete a few Type_of_prices
     * const { count } = await prisma.type_of_price.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends type_of_priceDeleteManyArgs>(
      args?: SelectSubset<T, type_of_priceDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Type_of_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_of_priceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Type_of_prices
     * const type_of_price = await prisma.type_of_price.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends type_of_priceUpdateManyArgs>(
      args: SelectSubset<T, type_of_priceUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Type_of_price.
     * @param {type_of_priceUpsertArgs} args - Arguments to update or create a Type_of_price.
     * @example
     * // Update or create a Type_of_price
     * const type_of_price = await prisma.type_of_price.upsert({
     *   create: {
     *     // ... data to create a Type_of_price
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Type_of_price we want to update
     *   }
     * })
    **/
    upsert<T extends type_of_priceUpsertArgs>(
      args: SelectSubset<T, type_of_priceUpsertArgs>
    ): Prisma__type_of_priceClient<type_of_priceGetPayload<T>>

    /**
     * Count the number of Type_of_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {type_of_priceCountArgs} args - Arguments to filter Type_of_prices to count.
     * @example
     * // Count the number of Type_of_prices
     * const count = await prisma.type_of_price.count({
     *   where: {
     *     // ... the filter for the Type_of_prices we want to count
     *   }
     * })
    **/
    count<T extends type_of_priceCountArgs>(
      args?: Subset<T, type_of_priceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Type_of_priceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Type_of_price.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Type_of_priceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Type_of_priceAggregateArgs>(args: Subset<T, Type_of_priceAggregateArgs>): Prisma.PrismaPromise<GetType_of_priceAggregateType<T>>

    /**
     * Group by Type_of_price.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Type_of_priceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Type_of_priceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Type_of_priceGroupByArgs['orderBy'] }
        : { orderBy?: Type_of_priceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Type_of_priceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetType_of_priceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for type_of_price.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__type_of_priceClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    product<T extends type_of_price$productArgs= {}>(args?: Subset<T, type_of_price$productArgs>): Prisma.PrismaPromise<Array<productGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * type_of_price base type for findUnique actions
   */
  export type type_of_priceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the type_of_price
     */
    select?: type_of_priceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: type_of_priceInclude | null
    /**
     * Filter, which type_of_price to fetch.
     */
    where: type_of_priceWhereUniqueInput
  }

  /**
   * type_of_price findUnique
   */
  export interface type_of_priceFindUniqueArgs extends type_of_priceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * type_of_price findUniqueOrThrow
   */
  export type type_of_priceFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the type_of_price
     */
    select?: type_of_priceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: type_of_priceInclude | null
    /**
     * Filter, which type_of_price to fetch.
     */
    where: type_of_priceWhereUniqueInput
  }


  /**
   * type_of_price base type for findFirst actions
   */
  export type type_of_priceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the type_of_price
     */
    select?: type_of_priceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: type_of_priceInclude | null
    /**
     * Filter, which type_of_price to fetch.
     */
    where?: type_of_priceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of type_of_prices to fetch.
     */
    orderBy?: Enumerable<type_of_priceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for type_of_prices.
     */
    cursor?: type_of_priceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` type_of_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` type_of_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of type_of_prices.
     */
    distinct?: Enumerable<Type_of_priceScalarFieldEnum>
  }

  /**
   * type_of_price findFirst
   */
  export interface type_of_priceFindFirstArgs extends type_of_priceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * type_of_price findFirstOrThrow
   */
  export type type_of_priceFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the type_of_price
     */
    select?: type_of_priceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: type_of_priceInclude | null
    /**
     * Filter, which type_of_price to fetch.
     */
    where?: type_of_priceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of type_of_prices to fetch.
     */
    orderBy?: Enumerable<type_of_priceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for type_of_prices.
     */
    cursor?: type_of_priceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` type_of_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` type_of_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of type_of_prices.
     */
    distinct?: Enumerable<Type_of_priceScalarFieldEnum>
  }


  /**
   * type_of_price findMany
   */
  export type type_of_priceFindManyArgs = {
    /**
     * Select specific fields to fetch from the type_of_price
     */
    select?: type_of_priceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: type_of_priceInclude | null
    /**
     * Filter, which type_of_prices to fetch.
     */
    where?: type_of_priceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of type_of_prices to fetch.
     */
    orderBy?: Enumerable<type_of_priceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing type_of_prices.
     */
    cursor?: type_of_priceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` type_of_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` type_of_prices.
     */
    skip?: number
    distinct?: Enumerable<Type_of_priceScalarFieldEnum>
  }


  /**
   * type_of_price create
   */
  export type type_of_priceCreateArgs = {
    /**
     * Select specific fields to fetch from the type_of_price
     */
    select?: type_of_priceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: type_of_priceInclude | null
    /**
     * The data needed to create a type_of_price.
     */
    data: XOR<type_of_priceCreateInput, type_of_priceUncheckedCreateInput>
  }


  /**
   * type_of_price createMany
   */
  export type type_of_priceCreateManyArgs = {
    /**
     * The data used to create many type_of_prices.
     */
    data: Enumerable<type_of_priceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * type_of_price update
   */
  export type type_of_priceUpdateArgs = {
    /**
     * Select specific fields to fetch from the type_of_price
     */
    select?: type_of_priceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: type_of_priceInclude | null
    /**
     * The data needed to update a type_of_price.
     */
    data: XOR<type_of_priceUpdateInput, type_of_priceUncheckedUpdateInput>
    /**
     * Choose, which type_of_price to update.
     */
    where: type_of_priceWhereUniqueInput
  }


  /**
   * type_of_price updateMany
   */
  export type type_of_priceUpdateManyArgs = {
    /**
     * The data used to update type_of_prices.
     */
    data: XOR<type_of_priceUpdateManyMutationInput, type_of_priceUncheckedUpdateManyInput>
    /**
     * Filter which type_of_prices to update
     */
    where?: type_of_priceWhereInput
  }


  /**
   * type_of_price upsert
   */
  export type type_of_priceUpsertArgs = {
    /**
     * Select specific fields to fetch from the type_of_price
     */
    select?: type_of_priceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: type_of_priceInclude | null
    /**
     * The filter to search for the type_of_price to update in case it exists.
     */
    where: type_of_priceWhereUniqueInput
    /**
     * In case the type_of_price found by the `where` argument doesn't exist, create a new type_of_price with this data.
     */
    create: XOR<type_of_priceCreateInput, type_of_priceUncheckedCreateInput>
    /**
     * In case the type_of_price was found with the provided `where` argument, update it with this data.
     */
    update: XOR<type_of_priceUpdateInput, type_of_priceUncheckedUpdateInput>
  }


  /**
   * type_of_price delete
   */
  export type type_of_priceDeleteArgs = {
    /**
     * Select specific fields to fetch from the type_of_price
     */
    select?: type_of_priceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: type_of_priceInclude | null
    /**
     * Filter which type_of_price to delete.
     */
    where: type_of_priceWhereUniqueInput
  }


  /**
   * type_of_price deleteMany
   */
  export type type_of_priceDeleteManyArgs = {
    /**
     * Filter which type_of_prices to delete
     */
    where?: type_of_priceWhereInput
  }


  /**
   * type_of_price.product
   */
  export type type_of_price$productArgs = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude | null
    where?: productWhereInput
    orderBy?: Enumerable<productOrderByWithRelationInput>
    cursor?: productWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * type_of_price without action
   */
  export type type_of_priceArgs = {
    /**
     * Select specific fields to fetch from the type_of_price
     */
    select?: type_of_priceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: type_of_priceInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AddressScalarFieldEnum: {
    id: 'id',
    cep: 'cep',
    logradouro: 'logradouro',
    number: 'number',
    created_at: 'created_at',
    updated_at: 'updated_at',
    address_typeId: 'address_typeId',
    complemento: 'complemento',
    cityId: 'cityId',
    uFId: 'uFId',
    neighborhoodId: 'neighborhoodId',
    locationId: 'locationId'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const Address_typeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Address_typeScalarFieldEnum = (typeof Address_typeScalarFieldEnum)[keyof typeof Address_typeScalarFieldEnum]


  export const Category_of_productScalarFieldEnum: {
    id: 'id',
    imageId: 'imageId',
    name: 'name'
  };

  export type Category_of_productScalarFieldEnum = (typeof Category_of_productScalarFieldEnum)[keyof typeof Category_of_productScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const CostumerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password_hash: 'password_hash',
    picture_uri: 'picture_uri',
    created_at: 'created_at',
    updated_at: 'updated_at',
    genderId: 'genderId',
    birthday: 'birthday',
    cpf: 'cpf'
  };

  export type CostumerScalarFieldEnum = (typeof CostumerScalarFieldEnum)[keyof typeof CostumerScalarFieldEnum]


  export const Costumer_addressesScalarFieldEnum: {
    id: 'id',
    addressId: 'addressId',
    costumerId: 'costumerId',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Costumer_addressesScalarFieldEnum = (typeof Costumer_addressesScalarFieldEnum)[keyof typeof Costumer_addressesScalarFieldEnum]


  export const Date_and_hour_of_workScalarFieldEnum: {
    id: 'id',
    open_datetime: 'open_datetime',
    close_datetime: 'close_datetime',
    created_at: 'created_at',
    updated_at: 'updated_at',
    day_of_weekId: 'day_of_weekId'
  };

  export type Date_and_hour_of_workScalarFieldEnum = (typeof Date_and_hour_of_workScalarFieldEnum)[keyof typeof Date_and_hour_of_workScalarFieldEnum]


  export const Day_of_weekScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Day_of_weekScalarFieldEnum = (typeof Day_of_weekScalarFieldEnum)[keyof typeof Day_of_weekScalarFieldEnum]


  export const DeliverymanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password_hash: 'password_hash',
    picture_uri: 'picture_uri',
    locationId: 'locationId',
    online: 'online',
    created_at: 'created_at',
    updated_at: 'updated_at',
    genderId: 'genderId',
    birthday: 'birthday'
  };

  export type DeliverymanScalarFieldEnum = (typeof DeliverymanScalarFieldEnum)[keyof typeof DeliverymanScalarFieldEnum]


  export const FairScalarFieldEnum: {
    name: 'name',
    id: 'id',
    review: 'review',
    addressId: 'addressId',
    created_at: 'created_at',
    updated_at: 'updated_at',
    locationId: 'locationId'
  };

  export type FairScalarFieldEnum = (typeof FairScalarFieldEnum)[keyof typeof FairScalarFieldEnum]


  export const Fair_date_hour_of_workScalarFieldEnum: {
    id: 'id',
    fairId: 'fairId',
    date_and_hour_of_workId: 'date_and_hour_of_workId',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Fair_date_hour_of_workScalarFieldEnum = (typeof Fair_date_hour_of_workScalarFieldEnum)[keyof typeof Fair_date_hour_of_workScalarFieldEnum]


  export const Fair_marketersScalarFieldEnum: {
    id: 'id',
    fairId: 'fairId',
    marketerId: 'marketerId',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Fair_marketersScalarFieldEnum = (typeof Fair_marketersScalarFieldEnum)[keyof typeof Fair_marketersScalarFieldEnum]


  export const GenderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type GenderScalarFieldEnum = (typeof GenderScalarFieldEnum)[keyof typeof GenderScalarFieldEnum]


  export const ImageScalarFieldEnum: {
    id: 'id',
    uri: 'uri',
    created_at: 'created_at',
    updated_at: 'updated_at',
    fairId: 'fairId'
  };

  export type ImageScalarFieldEnum = (typeof ImageScalarFieldEnum)[keyof typeof ImageScalarFieldEnum]


  export const Image_of_productScalarFieldEnum: {
    id: 'id',
    imageId: 'imageId',
    productId: 'productId',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Image_of_productScalarFieldEnum = (typeof Image_of_productScalarFieldEnum)[keyof typeof Image_of_productScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    longitude: 'longitude',
    latitude: 'latitude',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const MarketerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password_hash: 'password_hash',
    picture_uri: 'picture_uri',
    review: 'review',
    online: 'online',
    locationId: 'locationId',
    created_at: 'created_at',
    birthday: 'birthday',
    updated_at: 'updated_at',
    genderId: 'genderId',
    cnpj: 'cnpj',
    cpf: 'cpf',
    phone: 'phone',
    tent_name: 'tent_name'
  };

  export type MarketerScalarFieldEnum = (typeof MarketerScalarFieldEnum)[keyof typeof MarketerScalarFieldEnum]


  export const NeighborhoodScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type NeighborhoodScalarFieldEnum = (typeof NeighborhoodScalarFieldEnum)[keyof typeof NeighborhoodScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    accepted_status: 'accepted_status',
    delivered_status_for_client: 'delivered_status_for_client',
    retreat_products_status: 'retreat_products_status',
    deliverymanId: 'deliverymanId',
    shopping_listId: 'shopping_listId',
    created_at: 'created_at',
    updated_at: 'updated_at',
    costumer_addressesId: 'costumer_addressesId',
    intent_payment_id: 'intent_payment_id'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    status: 'status',
    details: 'details',
    payment_methodId: 'payment_methodId',
    orderId: 'orderId',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const Payment_methodScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Payment_methodScalarFieldEnum = (typeof Payment_methodScalarFieldEnum)[keyof typeof Payment_methodScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    quantity: 'quantity',
    review: 'review',
    active_for_selling: 'active_for_selling',
    available_quantity: 'available_quantity',
    marketerId: 'marketerId',
    created_at: 'created_at',
    updated_at: 'updated_at',
    description: 'description',
    category_of_productId: 'category_of_productId',
    type_of_productId: 'type_of_productId'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const Products_in_shopping_listScalarFieldEnum: {
    id: 'id',
    shopping_listId: 'shopping_listId',
    productId: 'productId',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Products_in_shopping_listScalarFieldEnum = (typeof Products_in_shopping_listScalarFieldEnum)[keyof typeof Products_in_shopping_listScalarFieldEnum]


  export const Sale_offScalarFieldEnum: {
    id: 'id',
    value: 'value',
    productId: 'productId'
  };

  export type Sale_offScalarFieldEnum = (typeof Sale_offScalarFieldEnum)[keyof typeof Sale_offScalarFieldEnum]


  export const Shopping_listScalarFieldEnum: {
    id: 'id',
    freight: 'freight',
    total: 'total',
    costumerId: 'costumerId',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Shopping_listScalarFieldEnum = (typeof Shopping_listScalarFieldEnum)[keyof typeof Shopping_listScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Type_of_priceScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Type_of_priceScalarFieldEnum = (typeof Type_of_priceScalarFieldEnum)[keyof typeof Type_of_priceScalarFieldEnum]


  export const UfScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type UfScalarFieldEnum = (typeof UfScalarFieldEnum)[keyof typeof UfScalarFieldEnum]


  export const VeiculeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type VeiculeScalarFieldEnum = (typeof VeiculeScalarFieldEnum)[keyof typeof VeiculeScalarFieldEnum]


  export const Veicule_deliverymanScalarFieldEnum: {
    id: 'id',
    veiculeId: 'veiculeId',
    deliverymanId: 'deliverymanId',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Veicule_deliverymanScalarFieldEnum = (typeof Veicule_deliverymanScalarFieldEnum)[keyof typeof Veicule_deliverymanScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type costumerWhereInput = {
    AND?: Enumerable<costumerWhereInput>
    OR?: Enumerable<costumerWhereInput>
    NOT?: Enumerable<costumerWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    email?: StringFilter | string
    password_hash?: StringFilter | string
    picture_uri?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    genderId?: IntFilter | number
    birthday?: StringFilter | string
    cpf?: StringNullableFilter | string | null
    gender?: XOR<GenderRelationFilter, genderWhereInput>
    costumer_addresses?: Costumer_addressesListRelationFilter
    shopping_lists?: Shopping_listListRelationFilter
  }

  export type costumerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    picture_uri?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    genderId?: SortOrder
    birthday?: SortOrder
    cpf?: SortOrder
    gender?: genderOrderByWithRelationInput
    costumer_addresses?: costumer_addressesOrderByRelationAggregateInput
    shopping_lists?: shopping_listOrderByRelationAggregateInput
  }

  export type costumerWhereUniqueInput = {
    id?: number
    email?: string
    cpf?: string
  }

  export type costumerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    picture_uri?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    genderId?: SortOrder
    birthday?: SortOrder
    cpf?: SortOrder
    _count?: costumerCountOrderByAggregateInput
    _avg?: costumerAvgOrderByAggregateInput
    _max?: costumerMaxOrderByAggregateInput
    _min?: costumerMinOrderByAggregateInput
    _sum?: costumerSumOrderByAggregateInput
  }

  export type costumerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<costumerScalarWhereWithAggregatesInput>
    OR?: Enumerable<costumerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<costumerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    password_hash?: StringWithAggregatesFilter | string
    picture_uri?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    genderId?: IntWithAggregatesFilter | number
    birthday?: StringWithAggregatesFilter | string
    cpf?: StringNullableWithAggregatesFilter | string | null
  }

  export type deliverymanWhereInput = {
    AND?: Enumerable<deliverymanWhereInput>
    OR?: Enumerable<deliverymanWhereInput>
    NOT?: Enumerable<deliverymanWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    email?: StringFilter | string
    password_hash?: StringFilter | string
    picture_uri?: StringFilter | string
    locationId?: IntFilter | number
    online?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    genderId?: IntFilter | number
    birthday?: StringFilter | string
    gender?: XOR<GenderRelationFilter, genderWhereInput>
    location?: XOR<LocationRelationFilter, locationWhereInput>
    order?: OrderListRelationFilter
    veicule_deliveryman?: Veicule_deliverymanListRelationFilter
  }

  export type deliverymanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    picture_uri?: SortOrder
    locationId?: SortOrder
    online?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    genderId?: SortOrder
    birthday?: SortOrder
    gender?: genderOrderByWithRelationInput
    location?: locationOrderByWithRelationInput
    order?: orderOrderByRelationAggregateInput
    veicule_deliveryman?: veicule_deliverymanOrderByRelationAggregateInput
  }

  export type deliverymanWhereUniqueInput = {
    id?: number
    email?: string
    locationId?: number
  }

  export type deliverymanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    picture_uri?: SortOrder
    locationId?: SortOrder
    online?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    genderId?: SortOrder
    birthday?: SortOrder
    _count?: deliverymanCountOrderByAggregateInput
    _avg?: deliverymanAvgOrderByAggregateInput
    _max?: deliverymanMaxOrderByAggregateInput
    _min?: deliverymanMinOrderByAggregateInput
    _sum?: deliverymanSumOrderByAggregateInput
  }

  export type deliverymanScalarWhereWithAggregatesInput = {
    AND?: Enumerable<deliverymanScalarWhereWithAggregatesInput>
    OR?: Enumerable<deliverymanScalarWhereWithAggregatesInput>
    NOT?: Enumerable<deliverymanScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    password_hash?: StringWithAggregatesFilter | string
    picture_uri?: StringWithAggregatesFilter | string
    locationId?: IntWithAggregatesFilter | number
    online?: BoolWithAggregatesFilter | boolean
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    genderId?: IntWithAggregatesFilter | number
    birthday?: StringWithAggregatesFilter | string
  }

  export type veicule_deliverymanWhereInput = {
    AND?: Enumerable<veicule_deliverymanWhereInput>
    OR?: Enumerable<veicule_deliverymanWhereInput>
    NOT?: Enumerable<veicule_deliverymanWhereInput>
    id?: IntFilter | number
    veiculeId?: IntFilter | number
    deliverymanId?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    owner?: XOR<DeliverymanRelationFilter, deliverymanWhereInput>
    veicule?: XOR<VeiculeRelationFilter, veiculeWhereInput>
  }

  export type veicule_deliverymanOrderByWithRelationInput = {
    id?: SortOrder
    veiculeId?: SortOrder
    deliverymanId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    owner?: deliverymanOrderByWithRelationInput
    veicule?: veiculeOrderByWithRelationInput
  }

  export type veicule_deliverymanWhereUniqueInput = {
    id?: number
  }

  export type veicule_deliverymanOrderByWithAggregationInput = {
    id?: SortOrder
    veiculeId?: SortOrder
    deliverymanId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: veicule_deliverymanCountOrderByAggregateInput
    _avg?: veicule_deliverymanAvgOrderByAggregateInput
    _max?: veicule_deliverymanMaxOrderByAggregateInput
    _min?: veicule_deliverymanMinOrderByAggregateInput
    _sum?: veicule_deliverymanSumOrderByAggregateInput
  }

  export type veicule_deliverymanScalarWhereWithAggregatesInput = {
    AND?: Enumerable<veicule_deliverymanScalarWhereWithAggregatesInput>
    OR?: Enumerable<veicule_deliverymanScalarWhereWithAggregatesInput>
    NOT?: Enumerable<veicule_deliverymanScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    veiculeId?: IntWithAggregatesFilter | number
    deliverymanId?: IntWithAggregatesFilter | number
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type paymentWhereInput = {
    AND?: Enumerable<paymentWhereInput>
    OR?: Enumerable<paymentWhereInput>
    NOT?: Enumerable<paymentWhereInput>
    id?: IntFilter | number
    status?: BoolFilter | boolean
    details?: StringFilter | string
    payment_methodId?: IntFilter | number
    orderId?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    order?: XOR<OrderRelationFilter, orderWhereInput>
    payment_method?: XOR<Payment_methodRelationFilter, payment_methodWhereInput>
  }

  export type paymentOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    details?: SortOrder
    payment_methodId?: SortOrder
    orderId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    order?: orderOrderByWithRelationInput
    payment_method?: payment_methodOrderByWithRelationInput
  }

  export type paymentWhereUniqueInput = {
    id?: number
    orderId?: number
  }

  export type paymentOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    details?: SortOrder
    payment_methodId?: SortOrder
    orderId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: paymentCountOrderByAggregateInput
    _avg?: paymentAvgOrderByAggregateInput
    _max?: paymentMaxOrderByAggregateInput
    _min?: paymentMinOrderByAggregateInput
    _sum?: paymentSumOrderByAggregateInput
  }

  export type paymentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<paymentScalarWhereWithAggregatesInput>
    OR?: Enumerable<paymentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<paymentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    status?: BoolWithAggregatesFilter | boolean
    details?: StringWithAggregatesFilter | string
    payment_methodId?: IntWithAggregatesFilter | number
    orderId?: IntWithAggregatesFilter | number
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type orderWhereInput = {
    AND?: Enumerable<orderWhereInput>
    OR?: Enumerable<orderWhereInput>
    NOT?: Enumerable<orderWhereInput>
    id?: IntFilter | number
    accepted_status?: BoolFilter | boolean
    delivered_status_for_client?: BoolFilter | boolean
    retreat_products_status?: BoolFilter | boolean
    deliverymanId?: IntNullableFilter | number | null
    shopping_listId?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    costumer_addressesId?: IntFilter | number
    intent_payment_id?: StringFilter | string
    costumer_addresses?: XOR<Costumer_addressesRelationFilter, costumer_addressesWhereInput>
    deliveryman?: XOR<DeliverymanRelationFilter, deliverymanWhereInput> | null
    shopping_list?: XOR<Shopping_listRelationFilter, shopping_listWhereInput>
    payment?: XOR<PaymentRelationFilter, paymentWhereInput> | null
  }

  export type orderOrderByWithRelationInput = {
    id?: SortOrder
    accepted_status?: SortOrder
    delivered_status_for_client?: SortOrder
    retreat_products_status?: SortOrder
    deliverymanId?: SortOrder
    shopping_listId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    costumer_addressesId?: SortOrder
    intent_payment_id?: SortOrder
    costumer_addresses?: costumer_addressesOrderByWithRelationInput
    deliveryman?: deliverymanOrderByWithRelationInput
    shopping_list?: shopping_listOrderByWithRelationInput
    payment?: paymentOrderByWithRelationInput
  }

  export type orderWhereUniqueInput = {
    id?: number
    shopping_listId?: number
    intent_payment_id?: string
  }

  export type orderOrderByWithAggregationInput = {
    id?: SortOrder
    accepted_status?: SortOrder
    delivered_status_for_client?: SortOrder
    retreat_products_status?: SortOrder
    deliverymanId?: SortOrder
    shopping_listId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    costumer_addressesId?: SortOrder
    intent_payment_id?: SortOrder
    _count?: orderCountOrderByAggregateInput
    _avg?: orderAvgOrderByAggregateInput
    _max?: orderMaxOrderByAggregateInput
    _min?: orderMinOrderByAggregateInput
    _sum?: orderSumOrderByAggregateInput
  }

  export type orderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<orderScalarWhereWithAggregatesInput>
    OR?: Enumerable<orderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<orderScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    accepted_status?: BoolWithAggregatesFilter | boolean
    delivered_status_for_client?: BoolWithAggregatesFilter | boolean
    retreat_products_status?: BoolWithAggregatesFilter | boolean
    deliverymanId?: IntNullableWithAggregatesFilter | number | null
    shopping_listId?: IntWithAggregatesFilter | number
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    costumer_addressesId?: IntWithAggregatesFilter | number
    intent_payment_id?: StringWithAggregatesFilter | string
  }

  export type shopping_listWhereInput = {
    AND?: Enumerable<shopping_listWhereInput>
    OR?: Enumerable<shopping_listWhereInput>
    NOT?: Enumerable<shopping_listWhereInput>
    id?: IntFilter | number
    freight?: FloatNullableFilter | number | null
    total?: FloatFilter | number
    costumerId?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    order?: XOR<OrderRelationFilter, orderWhereInput> | null
    products_in_shopping_list?: Products_in_shopping_listListRelationFilter
    costumer?: XOR<CostumerRelationFilter, costumerWhereInput>
  }

  export type shopping_listOrderByWithRelationInput = {
    id?: SortOrder
    freight?: SortOrder
    total?: SortOrder
    costumerId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    order?: orderOrderByWithRelationInput
    products_in_shopping_list?: products_in_shopping_listOrderByRelationAggregateInput
    costumer?: costumerOrderByWithRelationInput
  }

  export type shopping_listWhereUniqueInput = {
    id?: number
  }

  export type shopping_listOrderByWithAggregationInput = {
    id?: SortOrder
    freight?: SortOrder
    total?: SortOrder
    costumerId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: shopping_listCountOrderByAggregateInput
    _avg?: shopping_listAvgOrderByAggregateInput
    _max?: shopping_listMaxOrderByAggregateInput
    _min?: shopping_listMinOrderByAggregateInput
    _sum?: shopping_listSumOrderByAggregateInput
  }

  export type shopping_listScalarWhereWithAggregatesInput = {
    AND?: Enumerable<shopping_listScalarWhereWithAggregatesInput>
    OR?: Enumerable<shopping_listScalarWhereWithAggregatesInput>
    NOT?: Enumerable<shopping_listScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    freight?: FloatNullableWithAggregatesFilter | number | null
    total?: FloatWithAggregatesFilter | number
    costumerId?: IntWithAggregatesFilter | number
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type products_in_shopping_listWhereInput = {
    AND?: Enumerable<products_in_shopping_listWhereInput>
    OR?: Enumerable<products_in_shopping_listWhereInput>
    NOT?: Enumerable<products_in_shopping_listWhereInput>
    id?: IntFilter | number
    shopping_listId?: IntFilter | number
    productId?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    product?: XOR<ProductRelationFilter, productWhereInput>
    shopping_list?: XOR<Shopping_listRelationFilter, shopping_listWhereInput>
  }

  export type products_in_shopping_listOrderByWithRelationInput = {
    id?: SortOrder
    shopping_listId?: SortOrder
    productId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    product?: productOrderByWithRelationInput
    shopping_list?: shopping_listOrderByWithRelationInput
  }

  export type products_in_shopping_listWhereUniqueInput = {
    id?: number
  }

  export type products_in_shopping_listOrderByWithAggregationInput = {
    id?: SortOrder
    shopping_listId?: SortOrder
    productId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: products_in_shopping_listCountOrderByAggregateInput
    _avg?: products_in_shopping_listAvgOrderByAggregateInput
    _max?: products_in_shopping_listMaxOrderByAggregateInput
    _min?: products_in_shopping_listMinOrderByAggregateInput
    _sum?: products_in_shopping_listSumOrderByAggregateInput
  }

  export type products_in_shopping_listScalarWhereWithAggregatesInput = {
    AND?: Enumerable<products_in_shopping_listScalarWhereWithAggregatesInput>
    OR?: Enumerable<products_in_shopping_listScalarWhereWithAggregatesInput>
    NOT?: Enumerable<products_in_shopping_listScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    shopping_listId?: IntWithAggregatesFilter | number
    productId?: IntWithAggregatesFilter | number
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type productWhereInput = {
    AND?: Enumerable<productWhereInput>
    OR?: Enumerable<productWhereInput>
    NOT?: Enumerable<productWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    price?: FloatFilter | number
    quantity?: FloatNullableFilter | number | null
    review?: FloatFilter | number
    active_for_selling?: BoolFilter | boolean
    available_quantity?: IntFilter | number
    marketerId?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    description?: StringFilter | string
    category_of_productId?: IntFilter | number
    type_of_productId?: IntFilter | number
    image_of_product?: Image_of_productListRelationFilter
    category_of_product?: XOR<Category_of_productRelationFilter, category_of_productWhereInput>
    marketer?: XOR<MarketerRelationFilter, marketerWhereInput>
    type_of_price?: XOR<Type_of_priceRelationFilter, type_of_priceWhereInput>
    products_in_shopping_list?: Products_in_shopping_listListRelationFilter
    sale_off?: Sale_offListRelationFilter
  }

  export type productOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    review?: SortOrder
    active_for_selling?: SortOrder
    available_quantity?: SortOrder
    marketerId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    description?: SortOrder
    category_of_productId?: SortOrder
    type_of_productId?: SortOrder
    image_of_product?: image_of_productOrderByRelationAggregateInput
    category_of_product?: category_of_productOrderByWithRelationInput
    marketer?: marketerOrderByWithRelationInput
    type_of_price?: type_of_priceOrderByWithRelationInput
    products_in_shopping_list?: products_in_shopping_listOrderByRelationAggregateInput
    sale_off?: sale_offOrderByRelationAggregateInput
  }

  export type productWhereUniqueInput = {
    id?: number
  }

  export type productOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    review?: SortOrder
    active_for_selling?: SortOrder
    available_quantity?: SortOrder
    marketerId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    description?: SortOrder
    category_of_productId?: SortOrder
    type_of_productId?: SortOrder
    _count?: productCountOrderByAggregateInput
    _avg?: productAvgOrderByAggregateInput
    _max?: productMaxOrderByAggregateInput
    _min?: productMinOrderByAggregateInput
    _sum?: productSumOrderByAggregateInput
  }

  export type productScalarWhereWithAggregatesInput = {
    AND?: Enumerable<productScalarWhereWithAggregatesInput>
    OR?: Enumerable<productScalarWhereWithAggregatesInput>
    NOT?: Enumerable<productScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    price?: FloatWithAggregatesFilter | number
    quantity?: FloatNullableWithAggregatesFilter | number | null
    review?: FloatWithAggregatesFilter | number
    active_for_selling?: BoolWithAggregatesFilter | boolean
    available_quantity?: IntWithAggregatesFilter | number
    marketerId?: IntWithAggregatesFilter | number
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    description?: StringWithAggregatesFilter | string
    category_of_productId?: IntWithAggregatesFilter | number
    type_of_productId?: IntWithAggregatesFilter | number
  }

  export type marketerWhereInput = {
    AND?: Enumerable<marketerWhereInput>
    OR?: Enumerable<marketerWhereInput>
    NOT?: Enumerable<marketerWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    email?: StringFilter | string
    password_hash?: StringFilter | string
    picture_uri?: StringNullableFilter | string | null
    review?: FloatFilter | number
    online?: BoolFilter | boolean
    locationId?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    birthday?: StringFilter | string
    updated_at?: DateTimeFilter | Date | string
    genderId?: IntFilter | number
    cnpj?: StringNullableFilter | string | null
    cpf?: StringNullableFilter | string | null
    phone?: StringFilter | string
    tent_name?: StringFilter | string
    fair_marketers?: Fair_marketersListRelationFilter
    gender?: XOR<GenderRelationFilter, genderWhereInput>
    location?: XOR<LocationRelationFilter, locationWhereInput>
    products?: ProductListRelationFilter
  }

  export type marketerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    picture_uri?: SortOrder
    review?: SortOrder
    online?: SortOrder
    locationId?: SortOrder
    created_at?: SortOrder
    birthday?: SortOrder
    updated_at?: SortOrder
    genderId?: SortOrder
    cnpj?: SortOrder
    cpf?: SortOrder
    phone?: SortOrder
    tent_name?: SortOrder
    fair_marketers?: fair_marketersOrderByRelationAggregateInput
    gender?: genderOrderByWithRelationInput
    location?: locationOrderByWithRelationInput
    products?: productOrderByRelationAggregateInput
  }

  export type marketerWhereUniqueInput = {
    id?: number
    email?: string
    locationId?: number
    cnpj?: string
    cpf?: string
  }

  export type marketerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    picture_uri?: SortOrder
    review?: SortOrder
    online?: SortOrder
    locationId?: SortOrder
    created_at?: SortOrder
    birthday?: SortOrder
    updated_at?: SortOrder
    genderId?: SortOrder
    cnpj?: SortOrder
    cpf?: SortOrder
    phone?: SortOrder
    tent_name?: SortOrder
    _count?: marketerCountOrderByAggregateInput
    _avg?: marketerAvgOrderByAggregateInput
    _max?: marketerMaxOrderByAggregateInput
    _min?: marketerMinOrderByAggregateInput
    _sum?: marketerSumOrderByAggregateInput
  }

  export type marketerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<marketerScalarWhereWithAggregatesInput>
    OR?: Enumerable<marketerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<marketerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    password_hash?: StringWithAggregatesFilter | string
    picture_uri?: StringNullableWithAggregatesFilter | string | null
    review?: FloatWithAggregatesFilter | number
    online?: BoolWithAggregatesFilter | boolean
    locationId?: IntWithAggregatesFilter | number
    created_at?: DateTimeWithAggregatesFilter | Date | string
    birthday?: StringWithAggregatesFilter | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    genderId?: IntWithAggregatesFilter | number
    cnpj?: StringNullableWithAggregatesFilter | string | null
    cpf?: StringNullableWithAggregatesFilter | string | null
    phone?: StringWithAggregatesFilter | string
    tent_name?: StringWithAggregatesFilter | string
  }

  export type fairWhereInput = {
    AND?: Enumerable<fairWhereInput>
    OR?: Enumerable<fairWhereInput>
    NOT?: Enumerable<fairWhereInput>
    name?: StringFilter | string
    id?: IntFilter | number
    review?: FloatFilter | number
    addressId?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    locationId?: IntFilter | number
    address?: XOR<AddressRelationFilter, addressWhereInput>
    location?: XOR<LocationRelationFilter, locationWhereInput>
    fair_date_hour_of_work?: Fair_date_hour_of_workListRelationFilter
    fair_marketers?: Fair_marketersListRelationFilter
    image?: ImageListRelationFilter
  }

  export type fairOrderByWithRelationInput = {
    name?: SortOrder
    id?: SortOrder
    review?: SortOrder
    addressId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    locationId?: SortOrder
    address?: addressOrderByWithRelationInput
    location?: locationOrderByWithRelationInput
    fair_date_hour_of_work?: fair_date_hour_of_workOrderByRelationAggregateInput
    fair_marketers?: fair_marketersOrderByRelationAggregateInput
    image?: imageOrderByRelationAggregateInput
  }

  export type fairWhereUniqueInput = {
    id?: number
    addressId?: number
  }

  export type fairOrderByWithAggregationInput = {
    name?: SortOrder
    id?: SortOrder
    review?: SortOrder
    addressId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    locationId?: SortOrder
    _count?: fairCountOrderByAggregateInput
    _avg?: fairAvgOrderByAggregateInput
    _max?: fairMaxOrderByAggregateInput
    _min?: fairMinOrderByAggregateInput
    _sum?: fairSumOrderByAggregateInput
  }

  export type fairScalarWhereWithAggregatesInput = {
    AND?: Enumerable<fairScalarWhereWithAggregatesInput>
    OR?: Enumerable<fairScalarWhereWithAggregatesInput>
    NOT?: Enumerable<fairScalarWhereWithAggregatesInput>
    name?: StringWithAggregatesFilter | string
    id?: IntWithAggregatesFilter | number
    review?: FloatWithAggregatesFilter | number
    addressId?: IntWithAggregatesFilter | number
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    locationId?: IntWithAggregatesFilter | number
  }

  export type fair_marketersWhereInput = {
    AND?: Enumerable<fair_marketersWhereInput>
    OR?: Enumerable<fair_marketersWhereInput>
    NOT?: Enumerable<fair_marketersWhereInput>
    id?: IntFilter | number
    fairId?: IntFilter | number
    marketerId?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    fair?: XOR<FairRelationFilter, fairWhereInput>
    marketer?: XOR<MarketerRelationFilter, marketerWhereInput>
  }

  export type fair_marketersOrderByWithRelationInput = {
    id?: SortOrder
    fairId?: SortOrder
    marketerId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    fair?: fairOrderByWithRelationInput
    marketer?: marketerOrderByWithRelationInput
  }

  export type fair_marketersWhereUniqueInput = {
    id?: number
    fairId_marketerId?: fair_marketersFairIdMarketerIdCompoundUniqueInput
  }

  export type fair_marketersOrderByWithAggregationInput = {
    id?: SortOrder
    fairId?: SortOrder
    marketerId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: fair_marketersCountOrderByAggregateInput
    _avg?: fair_marketersAvgOrderByAggregateInput
    _max?: fair_marketersMaxOrderByAggregateInput
    _min?: fair_marketersMinOrderByAggregateInput
    _sum?: fair_marketersSumOrderByAggregateInput
  }

  export type fair_marketersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<fair_marketersScalarWhereWithAggregatesInput>
    OR?: Enumerable<fair_marketersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<fair_marketersScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    fairId?: IntWithAggregatesFilter | number
    marketerId?: IntWithAggregatesFilter | number
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type costumer_addressesWhereInput = {
    AND?: Enumerable<costumer_addressesWhereInput>
    OR?: Enumerable<costumer_addressesWhereInput>
    NOT?: Enumerable<costumer_addressesWhereInput>
    id?: IntFilter | number
    addressId?: IntFilter | number
    costumerId?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    address?: XOR<AddressRelationFilter, addressWhereInput>
    costumer?: XOR<CostumerRelationFilter, costumerWhereInput>
    order?: OrderListRelationFilter
  }

  export type costumer_addressesOrderByWithRelationInput = {
    id?: SortOrder
    addressId?: SortOrder
    costumerId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    address?: addressOrderByWithRelationInput
    costumer?: costumerOrderByWithRelationInput
    order?: orderOrderByRelationAggregateInput
  }

  export type costumer_addressesWhereUniqueInput = {
    id?: number
  }

  export type costumer_addressesOrderByWithAggregationInput = {
    id?: SortOrder
    addressId?: SortOrder
    costumerId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: costumer_addressesCountOrderByAggregateInput
    _avg?: costumer_addressesAvgOrderByAggregateInput
    _max?: costumer_addressesMaxOrderByAggregateInput
    _min?: costumer_addressesMinOrderByAggregateInput
    _sum?: costumer_addressesSumOrderByAggregateInput
  }

  export type costumer_addressesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<costumer_addressesScalarWhereWithAggregatesInput>
    OR?: Enumerable<costumer_addressesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<costumer_addressesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    addressId?: IntWithAggregatesFilter | number
    costumerId?: IntWithAggregatesFilter | number
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type locationWhereInput = {
    AND?: Enumerable<locationWhereInput>
    OR?: Enumerable<locationWhereInput>
    NOT?: Enumerable<locationWhereInput>
    id?: IntFilter | number
    longitude?: FloatFilter | number
    latitude?: FloatFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    address?: AddressListRelationFilter
    deliveryman?: XOR<DeliverymanRelationFilter, deliverymanWhereInput> | null
    fair?: FairListRelationFilter
    marketer?: XOR<MarketerRelationFilter, marketerWhereInput> | null
  }

  export type locationOrderByWithRelationInput = {
    id?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    address?: addressOrderByRelationAggregateInput
    deliveryman?: deliverymanOrderByWithRelationInput
    fair?: fairOrderByRelationAggregateInput
    marketer?: marketerOrderByWithRelationInput
  }

  export type locationWhereUniqueInput = {
    id?: number
  }

  export type locationOrderByWithAggregationInput = {
    id?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: locationCountOrderByAggregateInput
    _avg?: locationAvgOrderByAggregateInput
    _max?: locationMaxOrderByAggregateInput
    _min?: locationMinOrderByAggregateInput
    _sum?: locationSumOrderByAggregateInput
  }

  export type locationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<locationScalarWhereWithAggregatesInput>
    OR?: Enumerable<locationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<locationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    longitude?: FloatWithAggregatesFilter | number
    latitude?: FloatWithAggregatesFilter | number
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type addressWhereInput = {
    AND?: Enumerable<addressWhereInput>
    OR?: Enumerable<addressWhereInput>
    NOT?: Enumerable<addressWhereInput>
    id?: IntFilter | number
    cep?: StringFilter | string
    logradouro?: StringFilter | string
    number?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    address_typeId?: IntFilter | number
    complemento?: StringFilter | string
    cityId?: IntFilter | number
    uFId?: IntFilter | number
    neighborhoodId?: IntFilter | number
    locationId?: IntFilter | number
    type?: XOR<Address_typeRelationFilter, address_typeWhereInput>
    city?: XOR<CityRelationFilter, cityWhereInput>
    location?: XOR<LocationRelationFilter, locationWhereInput>
    neighborhood?: XOR<NeighborhoodRelationFilter, neighborhoodWhereInput>
    uf?: XOR<UfRelationFilter, ufWhereInput>
    costumer_addresses?: Costumer_addressesListRelationFilter
    fair?: XOR<FairRelationFilter, fairWhereInput> | null
  }

  export type addressOrderByWithRelationInput = {
    id?: SortOrder
    cep?: SortOrder
    logradouro?: SortOrder
    number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    address_typeId?: SortOrder
    complemento?: SortOrder
    cityId?: SortOrder
    uFId?: SortOrder
    neighborhoodId?: SortOrder
    locationId?: SortOrder
    type?: address_typeOrderByWithRelationInput
    city?: cityOrderByWithRelationInput
    location?: locationOrderByWithRelationInput
    neighborhood?: neighborhoodOrderByWithRelationInput
    uf?: ufOrderByWithRelationInput
    costumer_addresses?: costumer_addressesOrderByRelationAggregateInput
    fair?: fairOrderByWithRelationInput
  }

  export type addressWhereUniqueInput = {
    id?: number
  }

  export type addressOrderByWithAggregationInput = {
    id?: SortOrder
    cep?: SortOrder
    logradouro?: SortOrder
    number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    address_typeId?: SortOrder
    complemento?: SortOrder
    cityId?: SortOrder
    uFId?: SortOrder
    neighborhoodId?: SortOrder
    locationId?: SortOrder
    _count?: addressCountOrderByAggregateInput
    _avg?: addressAvgOrderByAggregateInput
    _max?: addressMaxOrderByAggregateInput
    _min?: addressMinOrderByAggregateInput
    _sum?: addressSumOrderByAggregateInput
  }

  export type addressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<addressScalarWhereWithAggregatesInput>
    OR?: Enumerable<addressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<addressScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    cep?: StringWithAggregatesFilter | string
    logradouro?: StringWithAggregatesFilter | string
    number?: IntWithAggregatesFilter | number
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    address_typeId?: IntWithAggregatesFilter | number
    complemento?: StringWithAggregatesFilter | string
    cityId?: IntWithAggregatesFilter | number
    uFId?: IntWithAggregatesFilter | number
    neighborhoodId?: IntWithAggregatesFilter | number
    locationId?: IntWithAggregatesFilter | number
  }

  export type address_typeWhereInput = {
    AND?: Enumerable<address_typeWhereInput>
    OR?: Enumerable<address_typeWhereInput>
    NOT?: Enumerable<address_typeWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    address?: AddressListRelationFilter
  }

  export type address_typeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    address?: addressOrderByRelationAggregateInput
  }

  export type address_typeWhereUniqueInput = {
    id?: number
  }

  export type address_typeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: address_typeCountOrderByAggregateInput
    _avg?: address_typeAvgOrderByAggregateInput
    _max?: address_typeMaxOrderByAggregateInput
    _min?: address_typeMinOrderByAggregateInput
    _sum?: address_typeSumOrderByAggregateInput
  }

  export type address_typeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<address_typeScalarWhereWithAggregatesInput>
    OR?: Enumerable<address_typeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<address_typeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type veiculeWhereInput = {
    AND?: Enumerable<veiculeWhereInput>
    OR?: Enumerable<veiculeWhereInput>
    NOT?: Enumerable<veiculeWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    veicule_deliveryman?: Veicule_deliverymanListRelationFilter
  }

  export type veiculeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    veicule_deliveryman?: veicule_deliverymanOrderByRelationAggregateInput
  }

  export type veiculeWhereUniqueInput = {
    id?: number
  }

  export type veiculeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: veiculeCountOrderByAggregateInput
    _avg?: veiculeAvgOrderByAggregateInput
    _max?: veiculeMaxOrderByAggregateInput
    _min?: veiculeMinOrderByAggregateInput
    _sum?: veiculeSumOrderByAggregateInput
  }

  export type veiculeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<veiculeScalarWhereWithAggregatesInput>
    OR?: Enumerable<veiculeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<veiculeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type image_of_productWhereInput = {
    AND?: Enumerable<image_of_productWhereInput>
    OR?: Enumerable<image_of_productWhereInput>
    NOT?: Enumerable<image_of_productWhereInput>
    id?: IntFilter | number
    imageId?: IntFilter | number
    productId?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    image?: XOR<ImageRelationFilter, imageWhereInput>
    product?: XOR<ProductRelationFilter, productWhereInput>
  }

  export type image_of_productOrderByWithRelationInput = {
    id?: SortOrder
    imageId?: SortOrder
    productId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    image?: imageOrderByWithRelationInput
    product?: productOrderByWithRelationInput
  }

  export type image_of_productWhereUniqueInput = {
    id?: number
  }

  export type image_of_productOrderByWithAggregationInput = {
    id?: SortOrder
    imageId?: SortOrder
    productId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: image_of_productCountOrderByAggregateInput
    _avg?: image_of_productAvgOrderByAggregateInput
    _max?: image_of_productMaxOrderByAggregateInput
    _min?: image_of_productMinOrderByAggregateInput
    _sum?: image_of_productSumOrderByAggregateInput
  }

  export type image_of_productScalarWhereWithAggregatesInput = {
    AND?: Enumerable<image_of_productScalarWhereWithAggregatesInput>
    OR?: Enumerable<image_of_productScalarWhereWithAggregatesInput>
    NOT?: Enumerable<image_of_productScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    imageId?: IntWithAggregatesFilter | number
    productId?: IntWithAggregatesFilter | number
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type imageWhereInput = {
    AND?: Enumerable<imageWhereInput>
    OR?: Enumerable<imageWhereInput>
    NOT?: Enumerable<imageWhereInput>
    id?: IntFilter | number
    uri?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    fairId?: IntNullableFilter | number | null
    category_of_product?: Category_of_productListRelationFilter
    fair?: XOR<FairRelationFilter, fairWhereInput> | null
    image_of_product?: Image_of_productListRelationFilter
  }

  export type imageOrderByWithRelationInput = {
    id?: SortOrder
    uri?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    fairId?: SortOrder
    category_of_product?: category_of_productOrderByRelationAggregateInput
    fair?: fairOrderByWithRelationInput
    image_of_product?: image_of_productOrderByRelationAggregateInput
  }

  export type imageWhereUniqueInput = {
    id?: number
  }

  export type imageOrderByWithAggregationInput = {
    id?: SortOrder
    uri?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    fairId?: SortOrder
    _count?: imageCountOrderByAggregateInput
    _avg?: imageAvgOrderByAggregateInput
    _max?: imageMaxOrderByAggregateInput
    _min?: imageMinOrderByAggregateInput
    _sum?: imageSumOrderByAggregateInput
  }

  export type imageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<imageScalarWhereWithAggregatesInput>
    OR?: Enumerable<imageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<imageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    uri?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    fairId?: IntNullableWithAggregatesFilter | number | null
  }

  export type payment_methodWhereInput = {
    AND?: Enumerable<payment_methodWhereInput>
    OR?: Enumerable<payment_methodWhereInput>
    NOT?: Enumerable<payment_methodWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    payment?: PaymentListRelationFilter
  }

  export type payment_methodOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    payment?: paymentOrderByRelationAggregateInput
  }

  export type payment_methodWhereUniqueInput = {
    id?: number
  }

  export type payment_methodOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: payment_methodCountOrderByAggregateInput
    _avg?: payment_methodAvgOrderByAggregateInput
    _max?: payment_methodMaxOrderByAggregateInput
    _min?: payment_methodMinOrderByAggregateInput
    _sum?: payment_methodSumOrderByAggregateInput
  }

  export type payment_methodScalarWhereWithAggregatesInput = {
    AND?: Enumerable<payment_methodScalarWhereWithAggregatesInput>
    OR?: Enumerable<payment_methodScalarWhereWithAggregatesInput>
    NOT?: Enumerable<payment_methodScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type fair_date_hour_of_workWhereInput = {
    AND?: Enumerable<fair_date_hour_of_workWhereInput>
    OR?: Enumerable<fair_date_hour_of_workWhereInput>
    NOT?: Enumerable<fair_date_hour_of_workWhereInput>
    id?: IntFilter | number
    fairId?: IntFilter | number
    date_and_hour_of_workId?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    dates?: XOR<Date_and_hour_of_workRelationFilter, date_and_hour_of_workWhereInput>
    fair?: XOR<FairRelationFilter, fairWhereInput>
  }

  export type fair_date_hour_of_workOrderByWithRelationInput = {
    id?: SortOrder
    fairId?: SortOrder
    date_and_hour_of_workId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    dates?: date_and_hour_of_workOrderByWithRelationInput
    fair?: fairOrderByWithRelationInput
  }

  export type fair_date_hour_of_workWhereUniqueInput = {
    id?: number
  }

  export type fair_date_hour_of_workOrderByWithAggregationInput = {
    id?: SortOrder
    fairId?: SortOrder
    date_and_hour_of_workId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: fair_date_hour_of_workCountOrderByAggregateInput
    _avg?: fair_date_hour_of_workAvgOrderByAggregateInput
    _max?: fair_date_hour_of_workMaxOrderByAggregateInput
    _min?: fair_date_hour_of_workMinOrderByAggregateInput
    _sum?: fair_date_hour_of_workSumOrderByAggregateInput
  }

  export type fair_date_hour_of_workScalarWhereWithAggregatesInput = {
    AND?: Enumerable<fair_date_hour_of_workScalarWhereWithAggregatesInput>
    OR?: Enumerable<fair_date_hour_of_workScalarWhereWithAggregatesInput>
    NOT?: Enumerable<fair_date_hour_of_workScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    fairId?: IntWithAggregatesFilter | number
    date_and_hour_of_workId?: IntWithAggregatesFilter | number
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type date_and_hour_of_workWhereInput = {
    AND?: Enumerable<date_and_hour_of_workWhereInput>
    OR?: Enumerable<date_and_hour_of_workWhereInput>
    NOT?: Enumerable<date_and_hour_of_workWhereInput>
    id?: IntFilter | number
    open_datetime?: DateTimeFilter | Date | string
    close_datetime?: DateTimeFilter | Date | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    day_of_weekId?: IntFilter | number
    day_of_week?: XOR<Day_of_weekRelationFilter, day_of_weekWhereInput>
    fair_date_hour_of_work?: Fair_date_hour_of_workListRelationFilter
  }

  export type date_and_hour_of_workOrderByWithRelationInput = {
    id?: SortOrder
    open_datetime?: SortOrder
    close_datetime?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    day_of_weekId?: SortOrder
    day_of_week?: day_of_weekOrderByWithRelationInput
    fair_date_hour_of_work?: fair_date_hour_of_workOrderByRelationAggregateInput
  }

  export type date_and_hour_of_workWhereUniqueInput = {
    id?: number
  }

  export type date_and_hour_of_workOrderByWithAggregationInput = {
    id?: SortOrder
    open_datetime?: SortOrder
    close_datetime?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    day_of_weekId?: SortOrder
    _count?: date_and_hour_of_workCountOrderByAggregateInput
    _avg?: date_and_hour_of_workAvgOrderByAggregateInput
    _max?: date_and_hour_of_workMaxOrderByAggregateInput
    _min?: date_and_hour_of_workMinOrderByAggregateInput
    _sum?: date_and_hour_of_workSumOrderByAggregateInput
  }

  export type date_and_hour_of_workScalarWhereWithAggregatesInput = {
    AND?: Enumerable<date_and_hour_of_workScalarWhereWithAggregatesInput>
    OR?: Enumerable<date_and_hour_of_workScalarWhereWithAggregatesInput>
    NOT?: Enumerable<date_and_hour_of_workScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    open_datetime?: DateTimeWithAggregatesFilter | Date | string
    close_datetime?: DateTimeWithAggregatesFilter | Date | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
    day_of_weekId?: IntWithAggregatesFilter | number
  }

  export type day_of_weekWhereInput = {
    AND?: Enumerable<day_of_weekWhereInput>
    OR?: Enumerable<day_of_weekWhereInput>
    NOT?: Enumerable<day_of_weekWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    date_and_hour_of_work?: Date_and_hour_of_workListRelationFilter
  }

  export type day_of_weekOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    date_and_hour_of_work?: date_and_hour_of_workOrderByRelationAggregateInput
  }

  export type day_of_weekWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type day_of_weekOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: day_of_weekCountOrderByAggregateInput
    _avg?: day_of_weekAvgOrderByAggregateInput
    _max?: day_of_weekMaxOrderByAggregateInput
    _min?: day_of_weekMinOrderByAggregateInput
    _sum?: day_of_weekSumOrderByAggregateInput
  }

  export type day_of_weekScalarWhereWithAggregatesInput = {
    AND?: Enumerable<day_of_weekScalarWhereWithAggregatesInput>
    OR?: Enumerable<day_of_weekScalarWhereWithAggregatesInput>
    NOT?: Enumerable<day_of_weekScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type genderWhereInput = {
    AND?: Enumerable<genderWhereInput>
    OR?: Enumerable<genderWhereInput>
    NOT?: Enumerable<genderWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    costumer?: CostumerListRelationFilter
    deliveryman?: DeliverymanListRelationFilter
    marketer?: MarketerListRelationFilter
  }

  export type genderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    costumer?: costumerOrderByRelationAggregateInput
    deliveryman?: deliverymanOrderByRelationAggregateInput
    marketer?: marketerOrderByRelationAggregateInput
  }

  export type genderWhereUniqueInput = {
    id?: number
  }

  export type genderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: genderCountOrderByAggregateInput
    _avg?: genderAvgOrderByAggregateInput
    _max?: genderMaxOrderByAggregateInput
    _min?: genderMinOrderByAggregateInput
    _sum?: genderSumOrderByAggregateInput
  }

  export type genderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<genderScalarWhereWithAggregatesInput>
    OR?: Enumerable<genderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<genderScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type cityWhereInput = {
    AND?: Enumerable<cityWhereInput>
    OR?: Enumerable<cityWhereInput>
    NOT?: Enumerable<cityWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    address?: AddressListRelationFilter
  }

  export type cityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: addressOrderByRelationAggregateInput
  }

  export type cityWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type cityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: cityCountOrderByAggregateInput
    _avg?: cityAvgOrderByAggregateInput
    _max?: cityMaxOrderByAggregateInput
    _min?: cityMinOrderByAggregateInput
    _sum?: citySumOrderByAggregateInput
  }

  export type cityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<cityScalarWhereWithAggregatesInput>
    OR?: Enumerable<cityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<cityScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type neighborhoodWhereInput = {
    AND?: Enumerable<neighborhoodWhereInput>
    OR?: Enumerable<neighborhoodWhereInput>
    NOT?: Enumerable<neighborhoodWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    address?: AddressListRelationFilter
  }

  export type neighborhoodOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: addressOrderByRelationAggregateInput
  }

  export type neighborhoodWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type neighborhoodOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: neighborhoodCountOrderByAggregateInput
    _avg?: neighborhoodAvgOrderByAggregateInput
    _max?: neighborhoodMaxOrderByAggregateInput
    _min?: neighborhoodMinOrderByAggregateInput
    _sum?: neighborhoodSumOrderByAggregateInput
  }

  export type neighborhoodScalarWhereWithAggregatesInput = {
    AND?: Enumerable<neighborhoodScalarWhereWithAggregatesInput>
    OR?: Enumerable<neighborhoodScalarWhereWithAggregatesInput>
    NOT?: Enumerable<neighborhoodScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type ufWhereInput = {
    AND?: Enumerable<ufWhereInput>
    OR?: Enumerable<ufWhereInput>
    NOT?: Enumerable<ufWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    address?: AddressListRelationFilter
  }

  export type ufOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: addressOrderByRelationAggregateInput
  }

  export type ufWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type ufOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: ufCountOrderByAggregateInput
    _avg?: ufAvgOrderByAggregateInput
    _max?: ufMaxOrderByAggregateInput
    _min?: ufMinOrderByAggregateInput
    _sum?: ufSumOrderByAggregateInput
  }

  export type ufScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ufScalarWhereWithAggregatesInput>
    OR?: Enumerable<ufScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ufScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type category_of_productWhereInput = {
    AND?: Enumerable<category_of_productWhereInput>
    OR?: Enumerable<category_of_productWhereInput>
    NOT?: Enumerable<category_of_productWhereInput>
    id?: IntFilter | number
    imageId?: IntFilter | number
    name?: StringFilter | string
    image?: XOR<ImageRelationFilter, imageWhereInput>
    product?: ProductListRelationFilter
  }

  export type category_of_productOrderByWithRelationInput = {
    id?: SortOrder
    imageId?: SortOrder
    name?: SortOrder
    image?: imageOrderByWithRelationInput
    product?: productOrderByRelationAggregateInput
  }

  export type category_of_productWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type category_of_productOrderByWithAggregationInput = {
    id?: SortOrder
    imageId?: SortOrder
    name?: SortOrder
    _count?: category_of_productCountOrderByAggregateInput
    _avg?: category_of_productAvgOrderByAggregateInput
    _max?: category_of_productMaxOrderByAggregateInput
    _min?: category_of_productMinOrderByAggregateInput
    _sum?: category_of_productSumOrderByAggregateInput
  }

  export type category_of_productScalarWhereWithAggregatesInput = {
    AND?: Enumerable<category_of_productScalarWhereWithAggregatesInput>
    OR?: Enumerable<category_of_productScalarWhereWithAggregatesInput>
    NOT?: Enumerable<category_of_productScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    imageId?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type sale_offWhereInput = {
    AND?: Enumerable<sale_offWhereInput>
    OR?: Enumerable<sale_offWhereInput>
    NOT?: Enumerable<sale_offWhereInput>
    id?: IntFilter | number
    value?: FloatFilter | number
    productId?: IntFilter | number
    product?: XOR<ProductRelationFilter, productWhereInput>
  }

  export type sale_offOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    productId?: SortOrder
    product?: productOrderByWithRelationInput
  }

  export type sale_offWhereUniqueInput = {
    id?: number
  }

  export type sale_offOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    productId?: SortOrder
    _count?: sale_offCountOrderByAggregateInput
    _avg?: sale_offAvgOrderByAggregateInput
    _max?: sale_offMaxOrderByAggregateInput
    _min?: sale_offMinOrderByAggregateInput
    _sum?: sale_offSumOrderByAggregateInput
  }

  export type sale_offScalarWhereWithAggregatesInput = {
    AND?: Enumerable<sale_offScalarWhereWithAggregatesInput>
    OR?: Enumerable<sale_offScalarWhereWithAggregatesInput>
    NOT?: Enumerable<sale_offScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    value?: FloatWithAggregatesFilter | number
    productId?: IntWithAggregatesFilter | number
  }

  export type type_of_priceWhereInput = {
    AND?: Enumerable<type_of_priceWhereInput>
    OR?: Enumerable<type_of_priceWhereInput>
    NOT?: Enumerable<type_of_priceWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    product?: ProductListRelationFilter
  }

  export type type_of_priceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    product?: productOrderByRelationAggregateInput
  }

  export type type_of_priceWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type type_of_priceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: type_of_priceCountOrderByAggregateInput
    _avg?: type_of_priceAvgOrderByAggregateInput
    _max?: type_of_priceMaxOrderByAggregateInput
    _min?: type_of_priceMinOrderByAggregateInput
    _sum?: type_of_priceSumOrderByAggregateInput
  }

  export type type_of_priceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<type_of_priceScalarWhereWithAggregatesInput>
    OR?: Enumerable<type_of_priceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<type_of_priceScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type costumerCreateInput = {
    name: string
    email: string
    password_hash: string
    picture_uri?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    birthday: string
    cpf?: string | null
    gender: genderCreateNestedOneWithoutCostumerInput
    costumer_addresses?: costumer_addressesCreateNestedManyWithoutCostumerInput
    shopping_lists?: shopping_listCreateNestedManyWithoutCostumerInput
  }

  export type costumerUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    picture_uri?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    genderId: number
    birthday: string
    cpf?: string | null
    costumer_addresses?: costumer_addressesUncheckedCreateNestedManyWithoutCostumerInput
    shopping_lists?: shopping_listUncheckedCreateNestedManyWithoutCostumerInput
  }

  export type costumerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    birthday?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: genderUpdateOneRequiredWithoutCostumerNestedInput
    costumer_addresses?: costumer_addressesUpdateManyWithoutCostumerNestedInput
    shopping_lists?: shopping_listUpdateManyWithoutCostumerNestedInput
  }

  export type costumerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    genderId?: IntFieldUpdateOperationsInput | number
    birthday?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    costumer_addresses?: costumer_addressesUncheckedUpdateManyWithoutCostumerNestedInput
    shopping_lists?: shopping_listUncheckedUpdateManyWithoutCostumerNestedInput
  }

  export type costumerCreateManyInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    picture_uri?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    genderId: number
    birthday: string
    cpf?: string | null
  }

  export type costumerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    birthday?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type costumerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    genderId?: IntFieldUpdateOperationsInput | number
    birthday?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type deliverymanCreateInput = {
    name: string
    email: string
    password_hash: string
    picture_uri: string
    online?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    birthday: string
    gender: genderCreateNestedOneWithoutDeliverymanInput
    location: locationCreateNestedOneWithoutDeliverymanInput
    order?: orderCreateNestedManyWithoutDeliverymanInput
    veicule_deliveryman?: veicule_deliverymanCreateNestedManyWithoutOwnerInput
  }

  export type deliverymanUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    picture_uri: string
    locationId: number
    online?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    genderId: number
    birthday: string
    order?: orderUncheckedCreateNestedManyWithoutDeliverymanInput
    veicule_deliveryman?: veicule_deliverymanUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type deliverymanUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: StringFieldUpdateOperationsInput | string
    online?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    birthday?: StringFieldUpdateOperationsInput | string
    gender?: genderUpdateOneRequiredWithoutDeliverymanNestedInput
    location?: locationUpdateOneRequiredWithoutDeliverymanNestedInput
    order?: orderUpdateManyWithoutDeliverymanNestedInput
    veicule_deliveryman?: veicule_deliverymanUpdateManyWithoutOwnerNestedInput
  }

  export type deliverymanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: StringFieldUpdateOperationsInput | string
    locationId?: IntFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    genderId?: IntFieldUpdateOperationsInput | number
    birthday?: StringFieldUpdateOperationsInput | string
    order?: orderUncheckedUpdateManyWithoutDeliverymanNestedInput
    veicule_deliveryman?: veicule_deliverymanUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type deliverymanCreateManyInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    picture_uri: string
    locationId: number
    online?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    genderId: number
    birthday: string
  }

  export type deliverymanUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: StringFieldUpdateOperationsInput | string
    online?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    birthday?: StringFieldUpdateOperationsInput | string
  }

  export type deliverymanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: StringFieldUpdateOperationsInput | string
    locationId?: IntFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    genderId?: IntFieldUpdateOperationsInput | number
    birthday?: StringFieldUpdateOperationsInput | string
  }

  export type veicule_deliverymanCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    owner: deliverymanCreateNestedOneWithoutVeicule_deliverymanInput
    veicule: veiculeCreateNestedOneWithoutVeicule_deliverymanInput
  }

  export type veicule_deliverymanUncheckedCreateInput = {
    id?: number
    veiculeId: number
    deliverymanId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type veicule_deliverymanUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: deliverymanUpdateOneRequiredWithoutVeicule_deliverymanNestedInput
    veicule?: veiculeUpdateOneRequiredWithoutVeicule_deliverymanNestedInput
  }

  export type veicule_deliverymanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    veiculeId?: IntFieldUpdateOperationsInput | number
    deliverymanId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type veicule_deliverymanCreateManyInput = {
    id?: number
    veiculeId: number
    deliverymanId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type veicule_deliverymanUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type veicule_deliverymanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    veiculeId?: IntFieldUpdateOperationsInput | number
    deliverymanId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentCreateInput = {
    status?: boolean
    details: string
    created_at?: Date | string
    updated_at?: Date | string
    order: orderCreateNestedOneWithoutPaymentInput
    payment_method: payment_methodCreateNestedOneWithoutPaymentInput
  }

  export type paymentUncheckedCreateInput = {
    id?: number
    status?: boolean
    details: string
    payment_methodId: number
    orderId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type paymentUpdateInput = {
    status?: BoolFieldUpdateOperationsInput | boolean
    details?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: orderUpdateOneRequiredWithoutPaymentNestedInput
    payment_method?: payment_methodUpdateOneRequiredWithoutPaymentNestedInput
  }

  export type paymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    details?: StringFieldUpdateOperationsInput | string
    payment_methodId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentCreateManyInput = {
    id?: number
    status?: boolean
    details: string
    payment_methodId: number
    orderId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type paymentUpdateManyMutationInput = {
    status?: BoolFieldUpdateOperationsInput | boolean
    details?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    details?: StringFieldUpdateOperationsInput | string
    payment_methodId?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type orderCreateInput = {
    accepted_status?: boolean
    delivered_status_for_client?: boolean
    retreat_products_status?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    intent_payment_id: string
    costumer_addresses: costumer_addressesCreateNestedOneWithoutOrderInput
    deliveryman?: deliverymanCreateNestedOneWithoutOrderInput
    shopping_list: shopping_listCreateNestedOneWithoutOrderInput
    payment?: paymentCreateNestedOneWithoutOrderInput
  }

  export type orderUncheckedCreateInput = {
    id?: number
    accepted_status?: boolean
    delivered_status_for_client?: boolean
    retreat_products_status?: boolean
    deliverymanId?: number | null
    shopping_listId: number
    created_at?: Date | string
    updated_at?: Date | string
    costumer_addressesId: number
    intent_payment_id: string
    payment?: paymentUncheckedCreateNestedOneWithoutOrderInput
  }

  export type orderUpdateInput = {
    accepted_status?: BoolFieldUpdateOperationsInput | boolean
    delivered_status_for_client?: BoolFieldUpdateOperationsInput | boolean
    retreat_products_status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    intent_payment_id?: StringFieldUpdateOperationsInput | string
    costumer_addresses?: costumer_addressesUpdateOneRequiredWithoutOrderNestedInput
    deliveryman?: deliverymanUpdateOneWithoutOrderNestedInput
    shopping_list?: shopping_listUpdateOneRequiredWithoutOrderNestedInput
    payment?: paymentUpdateOneWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    accepted_status?: BoolFieldUpdateOperationsInput | boolean
    delivered_status_for_client?: BoolFieldUpdateOperationsInput | boolean
    retreat_products_status?: BoolFieldUpdateOperationsInput | boolean
    deliverymanId?: NullableIntFieldUpdateOperationsInput | number | null
    shopping_listId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    costumer_addressesId?: IntFieldUpdateOperationsInput | number
    intent_payment_id?: StringFieldUpdateOperationsInput | string
    payment?: paymentUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type orderCreateManyInput = {
    id?: number
    accepted_status?: boolean
    delivered_status_for_client?: boolean
    retreat_products_status?: boolean
    deliverymanId?: number | null
    shopping_listId: number
    created_at?: Date | string
    updated_at?: Date | string
    costumer_addressesId: number
    intent_payment_id: string
  }

  export type orderUpdateManyMutationInput = {
    accepted_status?: BoolFieldUpdateOperationsInput | boolean
    delivered_status_for_client?: BoolFieldUpdateOperationsInput | boolean
    retreat_products_status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    intent_payment_id?: StringFieldUpdateOperationsInput | string
  }

  export type orderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    accepted_status?: BoolFieldUpdateOperationsInput | boolean
    delivered_status_for_client?: BoolFieldUpdateOperationsInput | boolean
    retreat_products_status?: BoolFieldUpdateOperationsInput | boolean
    deliverymanId?: NullableIntFieldUpdateOperationsInput | number | null
    shopping_listId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    costumer_addressesId?: IntFieldUpdateOperationsInput | number
    intent_payment_id?: StringFieldUpdateOperationsInput | string
  }

  export type shopping_listCreateInput = {
    freight?: number | null
    total: number
    created_at?: Date | string
    updated_at?: Date | string
    order?: orderCreateNestedOneWithoutShopping_listInput
    products_in_shopping_list?: products_in_shopping_listCreateNestedManyWithoutShopping_listInput
    costumer: costumerCreateNestedOneWithoutShopping_listsInput
  }

  export type shopping_listUncheckedCreateInput = {
    id?: number
    freight?: number | null
    total: number
    costumerId: number
    created_at?: Date | string
    updated_at?: Date | string
    order?: orderUncheckedCreateNestedOneWithoutShopping_listInput
    products_in_shopping_list?: products_in_shopping_listUncheckedCreateNestedManyWithoutShopping_listInput
  }

  export type shopping_listUpdateInput = {
    freight?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: orderUpdateOneWithoutShopping_listNestedInput
    products_in_shopping_list?: products_in_shopping_listUpdateManyWithoutShopping_listNestedInput
    costumer?: costumerUpdateOneRequiredWithoutShopping_listsNestedInput
  }

  export type shopping_listUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    freight?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: FloatFieldUpdateOperationsInput | number
    costumerId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: orderUncheckedUpdateOneWithoutShopping_listNestedInput
    products_in_shopping_list?: products_in_shopping_listUncheckedUpdateManyWithoutShopping_listNestedInput
  }

  export type shopping_listCreateManyInput = {
    id?: number
    freight?: number | null
    total: number
    costumerId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type shopping_listUpdateManyMutationInput = {
    freight?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type shopping_listUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    freight?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: FloatFieldUpdateOperationsInput | number
    costumerId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type products_in_shopping_listCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    product: productCreateNestedOneWithoutProducts_in_shopping_listInput
    shopping_list: shopping_listCreateNestedOneWithoutProducts_in_shopping_listInput
  }

  export type products_in_shopping_listUncheckedCreateInput = {
    id?: number
    shopping_listId: number
    productId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type products_in_shopping_listUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productUpdateOneRequiredWithoutProducts_in_shopping_listNestedInput
    shopping_list?: shopping_listUpdateOneRequiredWithoutProducts_in_shopping_listNestedInput
  }

  export type products_in_shopping_listUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopping_listId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type products_in_shopping_listCreateManyInput = {
    id?: number
    shopping_listId: number
    productId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type products_in_shopping_listUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type products_in_shopping_listUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopping_listId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productCreateInput = {
    name: string
    price: number
    quantity?: number | null
    review?: number
    active_for_selling?: boolean
    available_quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    description: string
    image_of_product?: image_of_productCreateNestedManyWithoutProductInput
    category_of_product: category_of_productCreateNestedOneWithoutProductInput
    marketer: marketerCreateNestedOneWithoutProductsInput
    type_of_price: type_of_priceCreateNestedOneWithoutProductInput
    products_in_shopping_list?: products_in_shopping_listCreateNestedManyWithoutProductInput
    sale_off?: sale_offCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateInput = {
    id?: number
    name: string
    price: number
    quantity?: number | null
    review?: number
    active_for_selling?: boolean
    available_quantity: number
    marketerId: number
    created_at?: Date | string
    updated_at?: Date | string
    description: string
    category_of_productId: number
    type_of_productId: number
    image_of_product?: image_of_productUncheckedCreateNestedManyWithoutProductInput
    products_in_shopping_list?: products_in_shopping_listUncheckedCreateNestedManyWithoutProductInput
    sale_off?: sale_offUncheckedCreateNestedManyWithoutProductInput
  }

  export type productUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    review?: FloatFieldUpdateOperationsInput | number
    active_for_selling?: BoolFieldUpdateOperationsInput | boolean
    available_quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    image_of_product?: image_of_productUpdateManyWithoutProductNestedInput
    category_of_product?: category_of_productUpdateOneRequiredWithoutProductNestedInput
    marketer?: marketerUpdateOneRequiredWithoutProductsNestedInput
    type_of_price?: type_of_priceUpdateOneRequiredWithoutProductNestedInput
    products_in_shopping_list?: products_in_shopping_listUpdateManyWithoutProductNestedInput
    sale_off?: sale_offUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    review?: FloatFieldUpdateOperationsInput | number
    active_for_selling?: BoolFieldUpdateOperationsInput | boolean
    available_quantity?: IntFieldUpdateOperationsInput | number
    marketerId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    category_of_productId?: IntFieldUpdateOperationsInput | number
    type_of_productId?: IntFieldUpdateOperationsInput | number
    image_of_product?: image_of_productUncheckedUpdateManyWithoutProductNestedInput
    products_in_shopping_list?: products_in_shopping_listUncheckedUpdateManyWithoutProductNestedInput
    sale_off?: sale_offUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productCreateManyInput = {
    id?: number
    name: string
    price: number
    quantity?: number | null
    review?: number
    active_for_selling?: boolean
    available_quantity: number
    marketerId: number
    created_at?: Date | string
    updated_at?: Date | string
    description: string
    category_of_productId: number
    type_of_productId: number
  }

  export type productUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    review?: FloatFieldUpdateOperationsInput | number
    active_for_selling?: BoolFieldUpdateOperationsInput | boolean
    available_quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type productUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    review?: FloatFieldUpdateOperationsInput | number
    active_for_selling?: BoolFieldUpdateOperationsInput | boolean
    available_quantity?: IntFieldUpdateOperationsInput | number
    marketerId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    category_of_productId?: IntFieldUpdateOperationsInput | number
    type_of_productId?: IntFieldUpdateOperationsInput | number
  }

  export type marketerCreateInput = {
    name: string
    email: string
    password_hash: string
    picture_uri?: string | null
    review?: number
    online?: boolean
    created_at?: Date | string
    birthday: string
    updated_at?: Date | string
    cnpj?: string | null
    cpf?: string | null
    phone: string
    tent_name: string
    fair_marketers?: fair_marketersCreateNestedManyWithoutMarketerInput
    gender: genderCreateNestedOneWithoutMarketerInput
    location: locationCreateNestedOneWithoutMarketerInput
    products?: productCreateNestedManyWithoutMarketerInput
  }

  export type marketerUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    picture_uri?: string | null
    review?: number
    online?: boolean
    locationId: number
    created_at?: Date | string
    birthday: string
    updated_at?: Date | string
    genderId: number
    cnpj?: string | null
    cpf?: string | null
    phone: string
    tent_name: string
    fair_marketers?: fair_marketersUncheckedCreateNestedManyWithoutMarketerInput
    products?: productUncheckedCreateNestedManyWithoutMarketerInput
  }

  export type marketerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: NullableStringFieldUpdateOperationsInput | string | null
    review?: FloatFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    birthday?: StringFieldUpdateOperationsInput | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    tent_name?: StringFieldUpdateOperationsInput | string
    fair_marketers?: fair_marketersUpdateManyWithoutMarketerNestedInput
    gender?: genderUpdateOneRequiredWithoutMarketerNestedInput
    location?: locationUpdateOneRequiredWithoutMarketerNestedInput
    products?: productUpdateManyWithoutMarketerNestedInput
  }

  export type marketerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: NullableStringFieldUpdateOperationsInput | string | null
    review?: FloatFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    locationId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    birthday?: StringFieldUpdateOperationsInput | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    genderId?: IntFieldUpdateOperationsInput | number
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    tent_name?: StringFieldUpdateOperationsInput | string
    fair_marketers?: fair_marketersUncheckedUpdateManyWithoutMarketerNestedInput
    products?: productUncheckedUpdateManyWithoutMarketerNestedInput
  }

  export type marketerCreateManyInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    picture_uri?: string | null
    review?: number
    online?: boolean
    locationId: number
    created_at?: Date | string
    birthday: string
    updated_at?: Date | string
    genderId: number
    cnpj?: string | null
    cpf?: string | null
    phone: string
    tent_name: string
  }

  export type marketerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: NullableStringFieldUpdateOperationsInput | string | null
    review?: FloatFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    birthday?: StringFieldUpdateOperationsInput | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    tent_name?: StringFieldUpdateOperationsInput | string
  }

  export type marketerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: NullableStringFieldUpdateOperationsInput | string | null
    review?: FloatFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    locationId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    birthday?: StringFieldUpdateOperationsInput | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    genderId?: IntFieldUpdateOperationsInput | number
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    tent_name?: StringFieldUpdateOperationsInput | string
  }

  export type fairCreateInput = {
    name: string
    review?: number
    created_at?: Date | string
    updated_at?: Date | string
    address: addressCreateNestedOneWithoutFairInput
    location: locationCreateNestedOneWithoutFairInput
    fair_date_hour_of_work?: fair_date_hour_of_workCreateNestedManyWithoutFairInput
    fair_marketers?: fair_marketersCreateNestedManyWithoutFairInput
    image?: imageCreateNestedManyWithoutFairInput
  }

  export type fairUncheckedCreateInput = {
    name: string
    id?: number
    review?: number
    addressId: number
    created_at?: Date | string
    updated_at?: Date | string
    locationId: number
    fair_date_hour_of_work?: fair_date_hour_of_workUncheckedCreateNestedManyWithoutFairInput
    fair_marketers?: fair_marketersUncheckedCreateNestedManyWithoutFairInput
    image?: imageUncheckedCreateNestedManyWithoutFairInput
  }

  export type fairUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    review?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUpdateOneRequiredWithoutFairNestedInput
    location?: locationUpdateOneRequiredWithoutFairNestedInput
    fair_date_hour_of_work?: fair_date_hour_of_workUpdateManyWithoutFairNestedInput
    fair_marketers?: fair_marketersUpdateManyWithoutFairNestedInput
    image?: imageUpdateManyWithoutFairNestedInput
  }

  export type fairUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    review?: FloatFieldUpdateOperationsInput | number
    addressId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: IntFieldUpdateOperationsInput | number
    fair_date_hour_of_work?: fair_date_hour_of_workUncheckedUpdateManyWithoutFairNestedInput
    fair_marketers?: fair_marketersUncheckedUpdateManyWithoutFairNestedInput
    image?: imageUncheckedUpdateManyWithoutFairNestedInput
  }

  export type fairCreateManyInput = {
    name: string
    id?: number
    review?: number
    addressId: number
    created_at?: Date | string
    updated_at?: Date | string
    locationId: number
  }

  export type fairUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    review?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fairUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    review?: FloatFieldUpdateOperationsInput | number
    addressId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: IntFieldUpdateOperationsInput | number
  }

  export type fair_marketersCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    fair: fairCreateNestedOneWithoutFair_marketersInput
    marketer: marketerCreateNestedOneWithoutFair_marketersInput
  }

  export type fair_marketersUncheckedCreateInput = {
    id?: number
    fairId: number
    marketerId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type fair_marketersUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fair?: fairUpdateOneRequiredWithoutFair_marketersNestedInput
    marketer?: marketerUpdateOneRequiredWithoutFair_marketersNestedInput
  }

  export type fair_marketersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fairId?: IntFieldUpdateOperationsInput | number
    marketerId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fair_marketersCreateManyInput = {
    id?: number
    fairId: number
    marketerId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type fair_marketersUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fair_marketersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fairId?: IntFieldUpdateOperationsInput | number
    marketerId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type costumer_addressesCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    address: addressCreateNestedOneWithoutCostumer_addressesInput
    costumer: costumerCreateNestedOneWithoutCostumer_addressesInput
    order?: orderCreateNestedManyWithoutCostumer_addressesInput
  }

  export type costumer_addressesUncheckedCreateInput = {
    id?: number
    addressId: number
    costumerId: number
    created_at?: Date | string
    updated_at?: Date | string
    order?: orderUncheckedCreateNestedManyWithoutCostumer_addressesInput
  }

  export type costumer_addressesUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUpdateOneRequiredWithoutCostumer_addressesNestedInput
    costumer?: costumerUpdateOneRequiredWithoutCostumer_addressesNestedInput
    order?: orderUpdateManyWithoutCostumer_addressesNestedInput
  }

  export type costumer_addressesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    addressId?: IntFieldUpdateOperationsInput | number
    costumerId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: orderUncheckedUpdateManyWithoutCostumer_addressesNestedInput
  }

  export type costumer_addressesCreateManyInput = {
    id?: number
    addressId: number
    costumerId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type costumer_addressesUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type costumer_addressesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    addressId?: IntFieldUpdateOperationsInput | number
    costumerId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type locationCreateInput = {
    longitude: number
    latitude: number
    created_at?: Date | string
    updated_at?: Date | string
    address?: addressCreateNestedManyWithoutLocationInput
    deliveryman?: deliverymanCreateNestedOneWithoutLocationInput
    fair?: fairCreateNestedManyWithoutLocationInput
    marketer?: marketerCreateNestedOneWithoutLocationInput
  }

  export type locationUncheckedCreateInput = {
    id?: number
    longitude: number
    latitude: number
    created_at?: Date | string
    updated_at?: Date | string
    address?: addressUncheckedCreateNestedManyWithoutLocationInput
    deliveryman?: deliverymanUncheckedCreateNestedOneWithoutLocationInput
    fair?: fairUncheckedCreateNestedManyWithoutLocationInput
    marketer?: marketerUncheckedCreateNestedOneWithoutLocationInput
  }

  export type locationUpdateInput = {
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUpdateManyWithoutLocationNestedInput
    deliveryman?: deliverymanUpdateOneWithoutLocationNestedInput
    fair?: fairUpdateManyWithoutLocationNestedInput
    marketer?: marketerUpdateOneWithoutLocationNestedInput
  }

  export type locationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUncheckedUpdateManyWithoutLocationNestedInput
    deliveryman?: deliverymanUncheckedUpdateOneWithoutLocationNestedInput
    fair?: fairUncheckedUpdateManyWithoutLocationNestedInput
    marketer?: marketerUncheckedUpdateOneWithoutLocationNestedInput
  }

  export type locationCreateManyInput = {
    id?: number
    longitude: number
    latitude: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type locationUpdateManyMutationInput = {
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type locationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type addressCreateInput = {
    cep: string
    logradouro: string
    number: number
    created_at?: Date | string
    updated_at?: Date | string
    complemento: string
    type: address_typeCreateNestedOneWithoutAddressInput
    city: cityCreateNestedOneWithoutAddressInput
    location: locationCreateNestedOneWithoutAddressInput
    neighborhood: neighborhoodCreateNestedOneWithoutAddressInput
    uf: ufCreateNestedOneWithoutAddressInput
    costumer_addresses?: costumer_addressesCreateNestedManyWithoutAddressInput
    fair?: fairCreateNestedOneWithoutAddressInput
  }

  export type addressUncheckedCreateInput = {
    id?: number
    cep: string
    logradouro: string
    number: number
    created_at?: Date | string
    updated_at?: Date | string
    address_typeId: number
    complemento: string
    cityId: number
    uFId: number
    neighborhoodId: number
    locationId: number
    costumer_addresses?: costumer_addressesUncheckedCreateNestedManyWithoutAddressInput
    fair?: fairUncheckedCreateNestedOneWithoutAddressInput
  }

  export type addressUpdateInput = {
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    complemento?: StringFieldUpdateOperationsInput | string
    type?: address_typeUpdateOneRequiredWithoutAddressNestedInput
    city?: cityUpdateOneRequiredWithoutAddressNestedInput
    location?: locationUpdateOneRequiredWithoutAddressNestedInput
    neighborhood?: neighborhoodUpdateOneRequiredWithoutAddressNestedInput
    uf?: ufUpdateOneRequiredWithoutAddressNestedInput
    costumer_addresses?: costumer_addressesUpdateManyWithoutAddressNestedInput
    fair?: fairUpdateOneWithoutAddressNestedInput
  }

  export type addressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address_typeId?: IntFieldUpdateOperationsInput | number
    complemento?: StringFieldUpdateOperationsInput | string
    cityId?: IntFieldUpdateOperationsInput | number
    uFId?: IntFieldUpdateOperationsInput | number
    neighborhoodId?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    costumer_addresses?: costumer_addressesUncheckedUpdateManyWithoutAddressNestedInput
    fair?: fairUncheckedUpdateOneWithoutAddressNestedInput
  }

  export type addressCreateManyInput = {
    id?: number
    cep: string
    logradouro: string
    number: number
    created_at?: Date | string
    updated_at?: Date | string
    address_typeId: number
    complemento: string
    cityId: number
    uFId: number
    neighborhoodId: number
    locationId: number
  }

  export type addressUpdateManyMutationInput = {
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    complemento?: StringFieldUpdateOperationsInput | string
  }

  export type addressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address_typeId?: IntFieldUpdateOperationsInput | number
    complemento?: StringFieldUpdateOperationsInput | string
    cityId?: IntFieldUpdateOperationsInput | number
    uFId?: IntFieldUpdateOperationsInput | number
    neighborhoodId?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
  }

  export type address_typeCreateInput = {
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    address?: addressCreateNestedManyWithoutTypeInput
  }

  export type address_typeUncheckedCreateInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    address?: addressUncheckedCreateNestedManyWithoutTypeInput
  }

  export type address_typeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUpdateManyWithoutTypeNestedInput
  }

  export type address_typeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUncheckedUpdateManyWithoutTypeNestedInput
  }

  export type address_typeCreateManyInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type address_typeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type address_typeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type veiculeCreateInput = {
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    veicule_deliveryman?: veicule_deliverymanCreateNestedManyWithoutVeiculeInput
  }

  export type veiculeUncheckedCreateInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    veicule_deliveryman?: veicule_deliverymanUncheckedCreateNestedManyWithoutVeiculeInput
  }

  export type veiculeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    veicule_deliveryman?: veicule_deliverymanUpdateManyWithoutVeiculeNestedInput
  }

  export type veiculeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    veicule_deliveryman?: veicule_deliverymanUncheckedUpdateManyWithoutVeiculeNestedInput
  }

  export type veiculeCreateManyInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type veiculeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type veiculeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type image_of_productCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    image: imageCreateNestedOneWithoutImage_of_productInput
    product: productCreateNestedOneWithoutImage_of_productInput
  }

  export type image_of_productUncheckedCreateInput = {
    id?: number
    imageId: number
    productId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type image_of_productUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: imageUpdateOneRequiredWithoutImage_of_productNestedInput
    product?: productUpdateOneRequiredWithoutImage_of_productNestedInput
  }

  export type image_of_productUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    imageId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type image_of_productCreateManyInput = {
    id?: number
    imageId: number
    productId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type image_of_productUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type image_of_productUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    imageId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type imageCreateInput = {
    uri: string
    created_at?: Date | string
    updated_at?: Date | string
    category_of_product?: category_of_productCreateNestedManyWithoutImageInput
    fair?: fairCreateNestedOneWithoutImageInput
    image_of_product?: image_of_productCreateNestedManyWithoutImageInput
  }

  export type imageUncheckedCreateInput = {
    id?: number
    uri: string
    created_at?: Date | string
    updated_at?: Date | string
    fairId?: number | null
    category_of_product?: category_of_productUncheckedCreateNestedManyWithoutImageInput
    image_of_product?: image_of_productUncheckedCreateNestedManyWithoutImageInput
  }

  export type imageUpdateInput = {
    uri?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_of_product?: category_of_productUpdateManyWithoutImageNestedInput
    fair?: fairUpdateOneWithoutImageNestedInput
    image_of_product?: image_of_productUpdateManyWithoutImageNestedInput
  }

  export type imageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uri?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fairId?: NullableIntFieldUpdateOperationsInput | number | null
    category_of_product?: category_of_productUncheckedUpdateManyWithoutImageNestedInput
    image_of_product?: image_of_productUncheckedUpdateManyWithoutImageNestedInput
  }

  export type imageCreateManyInput = {
    id?: number
    uri: string
    created_at?: Date | string
    updated_at?: Date | string
    fairId?: number | null
  }

  export type imageUpdateManyMutationInput = {
    uri?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type imageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uri?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fairId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type payment_methodCreateInput = {
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    payment?: paymentCreateNestedManyWithoutPayment_methodInput
  }

  export type payment_methodUncheckedCreateInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    payment?: paymentUncheckedCreateNestedManyWithoutPayment_methodInput
  }

  export type payment_methodUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: paymentUpdateManyWithoutPayment_methodNestedInput
  }

  export type payment_methodUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: paymentUncheckedUpdateManyWithoutPayment_methodNestedInput
  }

  export type payment_methodCreateManyInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type payment_methodUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_methodUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fair_date_hour_of_workCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    dates: date_and_hour_of_workCreateNestedOneWithoutFair_date_hour_of_workInput
    fair: fairCreateNestedOneWithoutFair_date_hour_of_workInput
  }

  export type fair_date_hour_of_workUncheckedCreateInput = {
    id?: number
    fairId: number
    date_and_hour_of_workId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type fair_date_hour_of_workUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    dates?: date_and_hour_of_workUpdateOneRequiredWithoutFair_date_hour_of_workNestedInput
    fair?: fairUpdateOneRequiredWithoutFair_date_hour_of_workNestedInput
  }

  export type fair_date_hour_of_workUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fairId?: IntFieldUpdateOperationsInput | number
    date_and_hour_of_workId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fair_date_hour_of_workCreateManyInput = {
    id?: number
    fairId: number
    date_and_hour_of_workId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type fair_date_hour_of_workUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fair_date_hour_of_workUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fairId?: IntFieldUpdateOperationsInput | number
    date_and_hour_of_workId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type date_and_hour_of_workCreateInput = {
    open_datetime: Date | string
    close_datetime: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    day_of_week: day_of_weekCreateNestedOneWithoutDate_and_hour_of_workInput
    fair_date_hour_of_work?: fair_date_hour_of_workCreateNestedManyWithoutDatesInput
  }

  export type date_and_hour_of_workUncheckedCreateInput = {
    id?: number
    open_datetime: Date | string
    close_datetime: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    day_of_weekId: number
    fair_date_hour_of_work?: fair_date_hour_of_workUncheckedCreateNestedManyWithoutDatesInput
  }

  export type date_and_hour_of_workUpdateInput = {
    open_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    close_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    day_of_week?: day_of_weekUpdateOneRequiredWithoutDate_and_hour_of_workNestedInput
    fair_date_hour_of_work?: fair_date_hour_of_workUpdateManyWithoutDatesNestedInput
  }

  export type date_and_hour_of_workUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    open_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    close_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    day_of_weekId?: IntFieldUpdateOperationsInput | number
    fair_date_hour_of_work?: fair_date_hour_of_workUncheckedUpdateManyWithoutDatesNestedInput
  }

  export type date_and_hour_of_workCreateManyInput = {
    id?: number
    open_datetime: Date | string
    close_datetime: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    day_of_weekId: number
  }

  export type date_and_hour_of_workUpdateManyMutationInput = {
    open_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    close_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type date_and_hour_of_workUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    open_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    close_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    day_of_weekId?: IntFieldUpdateOperationsInput | number
  }

  export type day_of_weekCreateInput = {
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    date_and_hour_of_work?: date_and_hour_of_workCreateNestedManyWithoutDay_of_weekInput
  }

  export type day_of_weekUncheckedCreateInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
    date_and_hour_of_work?: date_and_hour_of_workUncheckedCreateNestedManyWithoutDay_of_weekInput
  }

  export type day_of_weekUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    date_and_hour_of_work?: date_and_hour_of_workUpdateManyWithoutDay_of_weekNestedInput
  }

  export type day_of_weekUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    date_and_hour_of_work?: date_and_hour_of_workUncheckedUpdateManyWithoutDay_of_weekNestedInput
  }

  export type day_of_weekCreateManyInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type day_of_weekUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type day_of_weekUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type genderCreateInput = {
    name: string
    created_at?: Date | string
    updated_at: Date | string
    costumer?: costumerCreateNestedManyWithoutGenderInput
    deliveryman?: deliverymanCreateNestedManyWithoutGenderInput
    marketer?: marketerCreateNestedManyWithoutGenderInput
  }

  export type genderUncheckedCreateInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at: Date | string
    costumer?: costumerUncheckedCreateNestedManyWithoutGenderInput
    deliveryman?: deliverymanUncheckedCreateNestedManyWithoutGenderInput
    marketer?: marketerUncheckedCreateNestedManyWithoutGenderInput
  }

  export type genderUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    costumer?: costumerUpdateManyWithoutGenderNestedInput
    deliveryman?: deliverymanUpdateManyWithoutGenderNestedInput
    marketer?: marketerUpdateManyWithoutGenderNestedInput
  }

  export type genderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    costumer?: costumerUncheckedUpdateManyWithoutGenderNestedInput
    deliveryman?: deliverymanUncheckedUpdateManyWithoutGenderNestedInput
    marketer?: marketerUncheckedUpdateManyWithoutGenderNestedInput
  }

  export type genderCreateManyInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type genderUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type genderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cityCreateInput = {
    name: string
    address?: addressCreateNestedManyWithoutCityInput
  }

  export type cityUncheckedCreateInput = {
    id?: number
    name: string
    address?: addressUncheckedCreateNestedManyWithoutCityInput
  }

  export type cityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: addressUpdateManyWithoutCityNestedInput
  }

  export type cityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: addressUncheckedUpdateManyWithoutCityNestedInput
  }

  export type cityCreateManyInput = {
    id?: number
    name: string
  }

  export type cityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type cityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type neighborhoodCreateInput = {
    name: string
    address?: addressCreateNestedManyWithoutNeighborhoodInput
  }

  export type neighborhoodUncheckedCreateInput = {
    id?: number
    name: string
    address?: addressUncheckedCreateNestedManyWithoutNeighborhoodInput
  }

  export type neighborhoodUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: addressUpdateManyWithoutNeighborhoodNestedInput
  }

  export type neighborhoodUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: addressUncheckedUpdateManyWithoutNeighborhoodNestedInput
  }

  export type neighborhoodCreateManyInput = {
    id?: number
    name: string
  }

  export type neighborhoodUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type neighborhoodUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ufCreateInput = {
    name: string
    address?: addressCreateNestedManyWithoutUfInput
  }

  export type ufUncheckedCreateInput = {
    id?: number
    name: string
    address?: addressUncheckedCreateNestedManyWithoutUfInput
  }

  export type ufUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: addressUpdateManyWithoutUfNestedInput
  }

  export type ufUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: addressUncheckedUpdateManyWithoutUfNestedInput
  }

  export type ufCreateManyInput = {
    id?: number
    name: string
  }

  export type ufUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ufUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type category_of_productCreateInput = {
    name: string
    image: imageCreateNestedOneWithoutCategory_of_productInput
    product?: productCreateNestedManyWithoutCategory_of_productInput
  }

  export type category_of_productUncheckedCreateInput = {
    id?: number
    imageId: number
    name: string
    product?: productUncheckedCreateNestedManyWithoutCategory_of_productInput
  }

  export type category_of_productUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: imageUpdateOneRequiredWithoutCategory_of_productNestedInput
    product?: productUpdateManyWithoutCategory_of_productNestedInput
  }

  export type category_of_productUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    imageId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    product?: productUncheckedUpdateManyWithoutCategory_of_productNestedInput
  }

  export type category_of_productCreateManyInput = {
    id?: number
    imageId: number
    name: string
  }

  export type category_of_productUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type category_of_productUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    imageId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type sale_offCreateInput = {
    value: number
    product: productCreateNestedOneWithoutSale_offInput
  }

  export type sale_offUncheckedCreateInput = {
    id?: number
    value: number
    productId: number
  }

  export type sale_offUpdateInput = {
    value?: FloatFieldUpdateOperationsInput | number
    product?: productUpdateOneRequiredWithoutSale_offNestedInput
  }

  export type sale_offUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: FloatFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type sale_offCreateManyInput = {
    id?: number
    value: number
    productId: number
  }

  export type sale_offUpdateManyMutationInput = {
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type sale_offUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: FloatFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type type_of_priceCreateInput = {
    name: string
    product?: productCreateNestedManyWithoutType_of_priceInput
  }

  export type type_of_priceUncheckedCreateInput = {
    id?: number
    name: string
    product?: productUncheckedCreateNestedManyWithoutType_of_priceInput
  }

  export type type_of_priceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    product?: productUpdateManyWithoutType_of_priceNestedInput
  }

  export type type_of_priceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    product?: productUncheckedUpdateManyWithoutType_of_priceNestedInput
  }

  export type type_of_priceCreateManyInput = {
    id?: number
    name: string
  }

  export type type_of_priceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type type_of_priceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type GenderRelationFilter = {
    is?: genderWhereInput
    isNot?: genderWhereInput
  }

  export type Costumer_addressesListRelationFilter = {
    every?: costumer_addressesWhereInput
    some?: costumer_addressesWhereInput
    none?: costumer_addressesWhereInput
  }

  export type Shopping_listListRelationFilter = {
    every?: shopping_listWhereInput
    some?: shopping_listWhereInput
    none?: shopping_listWhereInput
  }

  export type costumer_addressesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type shopping_listOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type costumerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    picture_uri?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    genderId?: SortOrder
    birthday?: SortOrder
    cpf?: SortOrder
  }

  export type costumerAvgOrderByAggregateInput = {
    id?: SortOrder
    genderId?: SortOrder
  }

  export type costumerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    picture_uri?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    genderId?: SortOrder
    birthday?: SortOrder
    cpf?: SortOrder
  }

  export type costumerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    picture_uri?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    genderId?: SortOrder
    birthday?: SortOrder
    cpf?: SortOrder
  }

  export type costumerSumOrderByAggregateInput = {
    id?: SortOrder
    genderId?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type LocationRelationFilter = {
    is?: locationWhereInput
    isNot?: locationWhereInput
  }

  export type OrderListRelationFilter = {
    every?: orderWhereInput
    some?: orderWhereInput
    none?: orderWhereInput
  }

  export type Veicule_deliverymanListRelationFilter = {
    every?: veicule_deliverymanWhereInput
    some?: veicule_deliverymanWhereInput
    none?: veicule_deliverymanWhereInput
  }

  export type orderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type veicule_deliverymanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type deliverymanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    picture_uri?: SortOrder
    locationId?: SortOrder
    online?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    genderId?: SortOrder
    birthday?: SortOrder
  }

  export type deliverymanAvgOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    genderId?: SortOrder
  }

  export type deliverymanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    picture_uri?: SortOrder
    locationId?: SortOrder
    online?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    genderId?: SortOrder
    birthday?: SortOrder
  }

  export type deliverymanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    picture_uri?: SortOrder
    locationId?: SortOrder
    online?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    genderId?: SortOrder
    birthday?: SortOrder
  }

  export type deliverymanSumOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    genderId?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type DeliverymanRelationFilter = {
    is?: deliverymanWhereInput | null
    isNot?: deliverymanWhereInput | null
  }

  export type VeiculeRelationFilter = {
    is?: veiculeWhereInput
    isNot?: veiculeWhereInput
  }

  export type veicule_deliverymanCountOrderByAggregateInput = {
    id?: SortOrder
    veiculeId?: SortOrder
    deliverymanId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type veicule_deliverymanAvgOrderByAggregateInput = {
    id?: SortOrder
    veiculeId?: SortOrder
    deliverymanId?: SortOrder
  }

  export type veicule_deliverymanMaxOrderByAggregateInput = {
    id?: SortOrder
    veiculeId?: SortOrder
    deliverymanId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type veicule_deliverymanMinOrderByAggregateInput = {
    id?: SortOrder
    veiculeId?: SortOrder
    deliverymanId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type veicule_deliverymanSumOrderByAggregateInput = {
    id?: SortOrder
    veiculeId?: SortOrder
    deliverymanId?: SortOrder
  }

  export type OrderRelationFilter = {
    is?: orderWhereInput
    isNot?: orderWhereInput
  }

  export type Payment_methodRelationFilter = {
    is?: payment_methodWhereInput
    isNot?: payment_methodWhereInput
  }

  export type paymentCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    details?: SortOrder
    payment_methodId?: SortOrder
    orderId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type paymentAvgOrderByAggregateInput = {
    id?: SortOrder
    payment_methodId?: SortOrder
    orderId?: SortOrder
  }

  export type paymentMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    details?: SortOrder
    payment_methodId?: SortOrder
    orderId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type paymentMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    details?: SortOrder
    payment_methodId?: SortOrder
    orderId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type paymentSumOrderByAggregateInput = {
    id?: SortOrder
    payment_methodId?: SortOrder
    orderId?: SortOrder
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type Costumer_addressesRelationFilter = {
    is?: costumer_addressesWhereInput
    isNot?: costumer_addressesWhereInput
  }

  export type Shopping_listRelationFilter = {
    is?: shopping_listWhereInput
    isNot?: shopping_listWhereInput
  }

  export type PaymentRelationFilter = {
    is?: paymentWhereInput | null
    isNot?: paymentWhereInput | null
  }

  export type orderCountOrderByAggregateInput = {
    id?: SortOrder
    accepted_status?: SortOrder
    delivered_status_for_client?: SortOrder
    retreat_products_status?: SortOrder
    deliverymanId?: SortOrder
    shopping_listId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    costumer_addressesId?: SortOrder
    intent_payment_id?: SortOrder
  }

  export type orderAvgOrderByAggregateInput = {
    id?: SortOrder
    deliverymanId?: SortOrder
    shopping_listId?: SortOrder
    costumer_addressesId?: SortOrder
  }

  export type orderMaxOrderByAggregateInput = {
    id?: SortOrder
    accepted_status?: SortOrder
    delivered_status_for_client?: SortOrder
    retreat_products_status?: SortOrder
    deliverymanId?: SortOrder
    shopping_listId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    costumer_addressesId?: SortOrder
    intent_payment_id?: SortOrder
  }

  export type orderMinOrderByAggregateInput = {
    id?: SortOrder
    accepted_status?: SortOrder
    delivered_status_for_client?: SortOrder
    retreat_products_status?: SortOrder
    deliverymanId?: SortOrder
    shopping_listId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    costumer_addressesId?: SortOrder
    intent_payment_id?: SortOrder
  }

  export type orderSumOrderByAggregateInput = {
    id?: SortOrder
    deliverymanId?: SortOrder
    shopping_listId?: SortOrder
    costumer_addressesId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type Products_in_shopping_listListRelationFilter = {
    every?: products_in_shopping_listWhereInput
    some?: products_in_shopping_listWhereInput
    none?: products_in_shopping_listWhereInput
  }

  export type CostumerRelationFilter = {
    is?: costumerWhereInput
    isNot?: costumerWhereInput
  }

  export type products_in_shopping_listOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type shopping_listCountOrderByAggregateInput = {
    id?: SortOrder
    freight?: SortOrder
    total?: SortOrder
    costumerId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type shopping_listAvgOrderByAggregateInput = {
    id?: SortOrder
    freight?: SortOrder
    total?: SortOrder
    costumerId?: SortOrder
  }

  export type shopping_listMaxOrderByAggregateInput = {
    id?: SortOrder
    freight?: SortOrder
    total?: SortOrder
    costumerId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type shopping_listMinOrderByAggregateInput = {
    id?: SortOrder
    freight?: SortOrder
    total?: SortOrder
    costumerId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type shopping_listSumOrderByAggregateInput = {
    id?: SortOrder
    freight?: SortOrder
    total?: SortOrder
    costumerId?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type ProductRelationFilter = {
    is?: productWhereInput
    isNot?: productWhereInput
  }

  export type products_in_shopping_listCountOrderByAggregateInput = {
    id?: SortOrder
    shopping_listId?: SortOrder
    productId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type products_in_shopping_listAvgOrderByAggregateInput = {
    id?: SortOrder
    shopping_listId?: SortOrder
    productId?: SortOrder
  }

  export type products_in_shopping_listMaxOrderByAggregateInput = {
    id?: SortOrder
    shopping_listId?: SortOrder
    productId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type products_in_shopping_listMinOrderByAggregateInput = {
    id?: SortOrder
    shopping_listId?: SortOrder
    productId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type products_in_shopping_listSumOrderByAggregateInput = {
    id?: SortOrder
    shopping_listId?: SortOrder
    productId?: SortOrder
  }

  export type Image_of_productListRelationFilter = {
    every?: image_of_productWhereInput
    some?: image_of_productWhereInput
    none?: image_of_productWhereInput
  }

  export type Category_of_productRelationFilter = {
    is?: category_of_productWhereInput
    isNot?: category_of_productWhereInput
  }

  export type MarketerRelationFilter = {
    is?: marketerWhereInput
    isNot?: marketerWhereInput
  }

  export type Type_of_priceRelationFilter = {
    is?: type_of_priceWhereInput
    isNot?: type_of_priceWhereInput
  }

  export type Sale_offListRelationFilter = {
    every?: sale_offWhereInput
    some?: sale_offWhereInput
    none?: sale_offWhereInput
  }

  export type image_of_productOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sale_offOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    review?: SortOrder
    active_for_selling?: SortOrder
    available_quantity?: SortOrder
    marketerId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    description?: SortOrder
    category_of_productId?: SortOrder
    type_of_productId?: SortOrder
  }

  export type productAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    review?: SortOrder
    available_quantity?: SortOrder
    marketerId?: SortOrder
    category_of_productId?: SortOrder
    type_of_productId?: SortOrder
  }

  export type productMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    review?: SortOrder
    active_for_selling?: SortOrder
    available_quantity?: SortOrder
    marketerId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    description?: SortOrder
    category_of_productId?: SortOrder
    type_of_productId?: SortOrder
  }

  export type productMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    review?: SortOrder
    active_for_selling?: SortOrder
    available_quantity?: SortOrder
    marketerId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    description?: SortOrder
    category_of_productId?: SortOrder
    type_of_productId?: SortOrder
  }

  export type productSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    quantity?: SortOrder
    review?: SortOrder
    available_quantity?: SortOrder
    marketerId?: SortOrder
    category_of_productId?: SortOrder
    type_of_productId?: SortOrder
  }

  export type Fair_marketersListRelationFilter = {
    every?: fair_marketersWhereInput
    some?: fair_marketersWhereInput
    none?: fair_marketersWhereInput
  }

  export type ProductListRelationFilter = {
    every?: productWhereInput
    some?: productWhereInput
    none?: productWhereInput
  }

  export type fair_marketersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type marketerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    picture_uri?: SortOrder
    review?: SortOrder
    online?: SortOrder
    locationId?: SortOrder
    created_at?: SortOrder
    birthday?: SortOrder
    updated_at?: SortOrder
    genderId?: SortOrder
    cnpj?: SortOrder
    cpf?: SortOrder
    phone?: SortOrder
    tent_name?: SortOrder
  }

  export type marketerAvgOrderByAggregateInput = {
    id?: SortOrder
    review?: SortOrder
    locationId?: SortOrder
    genderId?: SortOrder
  }

  export type marketerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    picture_uri?: SortOrder
    review?: SortOrder
    online?: SortOrder
    locationId?: SortOrder
    created_at?: SortOrder
    birthday?: SortOrder
    updated_at?: SortOrder
    genderId?: SortOrder
    cnpj?: SortOrder
    cpf?: SortOrder
    phone?: SortOrder
    tent_name?: SortOrder
  }

  export type marketerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    picture_uri?: SortOrder
    review?: SortOrder
    online?: SortOrder
    locationId?: SortOrder
    created_at?: SortOrder
    birthday?: SortOrder
    updated_at?: SortOrder
    genderId?: SortOrder
    cnpj?: SortOrder
    cpf?: SortOrder
    phone?: SortOrder
    tent_name?: SortOrder
  }

  export type marketerSumOrderByAggregateInput = {
    id?: SortOrder
    review?: SortOrder
    locationId?: SortOrder
    genderId?: SortOrder
  }

  export type AddressRelationFilter = {
    is?: addressWhereInput
    isNot?: addressWhereInput
  }

  export type Fair_date_hour_of_workListRelationFilter = {
    every?: fair_date_hour_of_workWhereInput
    some?: fair_date_hour_of_workWhereInput
    none?: fair_date_hour_of_workWhereInput
  }

  export type ImageListRelationFilter = {
    every?: imageWhereInput
    some?: imageWhereInput
    none?: imageWhereInput
  }

  export type fair_date_hour_of_workOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type imageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type fairCountOrderByAggregateInput = {
    name?: SortOrder
    id?: SortOrder
    review?: SortOrder
    addressId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    locationId?: SortOrder
  }

  export type fairAvgOrderByAggregateInput = {
    id?: SortOrder
    review?: SortOrder
    addressId?: SortOrder
    locationId?: SortOrder
  }

  export type fairMaxOrderByAggregateInput = {
    name?: SortOrder
    id?: SortOrder
    review?: SortOrder
    addressId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    locationId?: SortOrder
  }

  export type fairMinOrderByAggregateInput = {
    name?: SortOrder
    id?: SortOrder
    review?: SortOrder
    addressId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    locationId?: SortOrder
  }

  export type fairSumOrderByAggregateInput = {
    id?: SortOrder
    review?: SortOrder
    addressId?: SortOrder
    locationId?: SortOrder
  }

  export type FairRelationFilter = {
    is?: fairWhereInput
    isNot?: fairWhereInput
  }

  export type fair_marketersFairIdMarketerIdCompoundUniqueInput = {
    fairId: number
    marketerId: number
  }

  export type fair_marketersCountOrderByAggregateInput = {
    id?: SortOrder
    fairId?: SortOrder
    marketerId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type fair_marketersAvgOrderByAggregateInput = {
    id?: SortOrder
    fairId?: SortOrder
    marketerId?: SortOrder
  }

  export type fair_marketersMaxOrderByAggregateInput = {
    id?: SortOrder
    fairId?: SortOrder
    marketerId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type fair_marketersMinOrderByAggregateInput = {
    id?: SortOrder
    fairId?: SortOrder
    marketerId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type fair_marketersSumOrderByAggregateInput = {
    id?: SortOrder
    fairId?: SortOrder
    marketerId?: SortOrder
  }

  export type costumer_addressesCountOrderByAggregateInput = {
    id?: SortOrder
    addressId?: SortOrder
    costumerId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type costumer_addressesAvgOrderByAggregateInput = {
    id?: SortOrder
    addressId?: SortOrder
    costumerId?: SortOrder
  }

  export type costumer_addressesMaxOrderByAggregateInput = {
    id?: SortOrder
    addressId?: SortOrder
    costumerId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type costumer_addressesMinOrderByAggregateInput = {
    id?: SortOrder
    addressId?: SortOrder
    costumerId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type costumer_addressesSumOrderByAggregateInput = {
    id?: SortOrder
    addressId?: SortOrder
    costumerId?: SortOrder
  }

  export type AddressListRelationFilter = {
    every?: addressWhereInput
    some?: addressWhereInput
    none?: addressWhereInput
  }

  export type FairListRelationFilter = {
    every?: fairWhereInput
    some?: fairWhereInput
    none?: fairWhereInput
  }

  export type addressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type fairOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type locationCountOrderByAggregateInput = {
    id?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type locationAvgOrderByAggregateInput = {
    id?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type locationMaxOrderByAggregateInput = {
    id?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type locationMinOrderByAggregateInput = {
    id?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type locationSumOrderByAggregateInput = {
    id?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type Address_typeRelationFilter = {
    is?: address_typeWhereInput
    isNot?: address_typeWhereInput
  }

  export type CityRelationFilter = {
    is?: cityWhereInput
    isNot?: cityWhereInput
  }

  export type NeighborhoodRelationFilter = {
    is?: neighborhoodWhereInput
    isNot?: neighborhoodWhereInput
  }

  export type UfRelationFilter = {
    is?: ufWhereInput
    isNot?: ufWhereInput
  }

  export type addressCountOrderByAggregateInput = {
    id?: SortOrder
    cep?: SortOrder
    logradouro?: SortOrder
    number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    address_typeId?: SortOrder
    complemento?: SortOrder
    cityId?: SortOrder
    uFId?: SortOrder
    neighborhoodId?: SortOrder
    locationId?: SortOrder
  }

  export type addressAvgOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    address_typeId?: SortOrder
    cityId?: SortOrder
    uFId?: SortOrder
    neighborhoodId?: SortOrder
    locationId?: SortOrder
  }

  export type addressMaxOrderByAggregateInput = {
    id?: SortOrder
    cep?: SortOrder
    logradouro?: SortOrder
    number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    address_typeId?: SortOrder
    complemento?: SortOrder
    cityId?: SortOrder
    uFId?: SortOrder
    neighborhoodId?: SortOrder
    locationId?: SortOrder
  }

  export type addressMinOrderByAggregateInput = {
    id?: SortOrder
    cep?: SortOrder
    logradouro?: SortOrder
    number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    address_typeId?: SortOrder
    complemento?: SortOrder
    cityId?: SortOrder
    uFId?: SortOrder
    neighborhoodId?: SortOrder
    locationId?: SortOrder
  }

  export type addressSumOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    address_typeId?: SortOrder
    cityId?: SortOrder
    uFId?: SortOrder
    neighborhoodId?: SortOrder
    locationId?: SortOrder
  }

  export type address_typeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type address_typeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type address_typeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type address_typeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type address_typeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type veiculeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type veiculeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type veiculeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type veiculeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type veiculeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ImageRelationFilter = {
    is?: imageWhereInput
    isNot?: imageWhereInput
  }

  export type image_of_productCountOrderByAggregateInput = {
    id?: SortOrder
    imageId?: SortOrder
    productId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type image_of_productAvgOrderByAggregateInput = {
    id?: SortOrder
    imageId?: SortOrder
    productId?: SortOrder
  }

  export type image_of_productMaxOrderByAggregateInput = {
    id?: SortOrder
    imageId?: SortOrder
    productId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type image_of_productMinOrderByAggregateInput = {
    id?: SortOrder
    imageId?: SortOrder
    productId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type image_of_productSumOrderByAggregateInput = {
    id?: SortOrder
    imageId?: SortOrder
    productId?: SortOrder
  }

  export type Category_of_productListRelationFilter = {
    every?: category_of_productWhereInput
    some?: category_of_productWhereInput
    none?: category_of_productWhereInput
  }

  export type category_of_productOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type imageCountOrderByAggregateInput = {
    id?: SortOrder
    uri?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    fairId?: SortOrder
  }

  export type imageAvgOrderByAggregateInput = {
    id?: SortOrder
    fairId?: SortOrder
  }

  export type imageMaxOrderByAggregateInput = {
    id?: SortOrder
    uri?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    fairId?: SortOrder
  }

  export type imageMinOrderByAggregateInput = {
    id?: SortOrder
    uri?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    fairId?: SortOrder
  }

  export type imageSumOrderByAggregateInput = {
    id?: SortOrder
    fairId?: SortOrder
  }

  export type PaymentListRelationFilter = {
    every?: paymentWhereInput
    some?: paymentWhereInput
    none?: paymentWhereInput
  }

  export type paymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type payment_methodCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type payment_methodAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type payment_methodMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type payment_methodMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type payment_methodSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Date_and_hour_of_workRelationFilter = {
    is?: date_and_hour_of_workWhereInput
    isNot?: date_and_hour_of_workWhereInput
  }

  export type fair_date_hour_of_workCountOrderByAggregateInput = {
    id?: SortOrder
    fairId?: SortOrder
    date_and_hour_of_workId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type fair_date_hour_of_workAvgOrderByAggregateInput = {
    id?: SortOrder
    fairId?: SortOrder
    date_and_hour_of_workId?: SortOrder
  }

  export type fair_date_hour_of_workMaxOrderByAggregateInput = {
    id?: SortOrder
    fairId?: SortOrder
    date_and_hour_of_workId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type fair_date_hour_of_workMinOrderByAggregateInput = {
    id?: SortOrder
    fairId?: SortOrder
    date_and_hour_of_workId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type fair_date_hour_of_workSumOrderByAggregateInput = {
    id?: SortOrder
    fairId?: SortOrder
    date_and_hour_of_workId?: SortOrder
  }

  export type Day_of_weekRelationFilter = {
    is?: day_of_weekWhereInput
    isNot?: day_of_weekWhereInput
  }

  export type date_and_hour_of_workCountOrderByAggregateInput = {
    id?: SortOrder
    open_datetime?: SortOrder
    close_datetime?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    day_of_weekId?: SortOrder
  }

  export type date_and_hour_of_workAvgOrderByAggregateInput = {
    id?: SortOrder
    day_of_weekId?: SortOrder
  }

  export type date_and_hour_of_workMaxOrderByAggregateInput = {
    id?: SortOrder
    open_datetime?: SortOrder
    close_datetime?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    day_of_weekId?: SortOrder
  }

  export type date_and_hour_of_workMinOrderByAggregateInput = {
    id?: SortOrder
    open_datetime?: SortOrder
    close_datetime?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    day_of_weekId?: SortOrder
  }

  export type date_and_hour_of_workSumOrderByAggregateInput = {
    id?: SortOrder
    day_of_weekId?: SortOrder
  }

  export type Date_and_hour_of_workListRelationFilter = {
    every?: date_and_hour_of_workWhereInput
    some?: date_and_hour_of_workWhereInput
    none?: date_and_hour_of_workWhereInput
  }

  export type date_and_hour_of_workOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type day_of_weekCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type day_of_weekAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type day_of_weekMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type day_of_weekMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type day_of_weekSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CostumerListRelationFilter = {
    every?: costumerWhereInput
    some?: costumerWhereInput
    none?: costumerWhereInput
  }

  export type DeliverymanListRelationFilter = {
    every?: deliverymanWhereInput
    some?: deliverymanWhereInput
    none?: deliverymanWhereInput
  }

  export type MarketerListRelationFilter = {
    every?: marketerWhereInput
    some?: marketerWhereInput
    none?: marketerWhereInput
  }

  export type costumerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type deliverymanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type marketerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type genderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type genderAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type genderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type genderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type genderSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type cityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type cityAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type cityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type cityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type citySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type neighborhoodCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type neighborhoodAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type neighborhoodMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type neighborhoodMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type neighborhoodSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ufCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ufAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ufMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ufMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ufSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type category_of_productCountOrderByAggregateInput = {
    id?: SortOrder
    imageId?: SortOrder
    name?: SortOrder
  }

  export type category_of_productAvgOrderByAggregateInput = {
    id?: SortOrder
    imageId?: SortOrder
  }

  export type category_of_productMaxOrderByAggregateInput = {
    id?: SortOrder
    imageId?: SortOrder
    name?: SortOrder
  }

  export type category_of_productMinOrderByAggregateInput = {
    id?: SortOrder
    imageId?: SortOrder
    name?: SortOrder
  }

  export type category_of_productSumOrderByAggregateInput = {
    id?: SortOrder
    imageId?: SortOrder
  }

  export type sale_offCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    productId?: SortOrder
  }

  export type sale_offAvgOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    productId?: SortOrder
  }

  export type sale_offMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    productId?: SortOrder
  }

  export type sale_offMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    productId?: SortOrder
  }

  export type sale_offSumOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    productId?: SortOrder
  }

  export type type_of_priceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type type_of_priceAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type type_of_priceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type type_of_priceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type type_of_priceSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type genderCreateNestedOneWithoutCostumerInput = {
    create?: XOR<genderCreateWithoutCostumerInput, genderUncheckedCreateWithoutCostumerInput>
    connectOrCreate?: genderCreateOrConnectWithoutCostumerInput
    connect?: genderWhereUniqueInput
  }

  export type costumer_addressesCreateNestedManyWithoutCostumerInput = {
    create?: XOR<Enumerable<costumer_addressesCreateWithoutCostumerInput>, Enumerable<costumer_addressesUncheckedCreateWithoutCostumerInput>>
    connectOrCreate?: Enumerable<costumer_addressesCreateOrConnectWithoutCostumerInput>
    createMany?: costumer_addressesCreateManyCostumerInputEnvelope
    connect?: Enumerable<costumer_addressesWhereUniqueInput>
  }

  export type shopping_listCreateNestedManyWithoutCostumerInput = {
    create?: XOR<Enumerable<shopping_listCreateWithoutCostumerInput>, Enumerable<shopping_listUncheckedCreateWithoutCostumerInput>>
    connectOrCreate?: Enumerable<shopping_listCreateOrConnectWithoutCostumerInput>
    createMany?: shopping_listCreateManyCostumerInputEnvelope
    connect?: Enumerable<shopping_listWhereUniqueInput>
  }

  export type costumer_addressesUncheckedCreateNestedManyWithoutCostumerInput = {
    create?: XOR<Enumerable<costumer_addressesCreateWithoutCostumerInput>, Enumerable<costumer_addressesUncheckedCreateWithoutCostumerInput>>
    connectOrCreate?: Enumerable<costumer_addressesCreateOrConnectWithoutCostumerInput>
    createMany?: costumer_addressesCreateManyCostumerInputEnvelope
    connect?: Enumerable<costumer_addressesWhereUniqueInput>
  }

  export type shopping_listUncheckedCreateNestedManyWithoutCostumerInput = {
    create?: XOR<Enumerable<shopping_listCreateWithoutCostumerInput>, Enumerable<shopping_listUncheckedCreateWithoutCostumerInput>>
    connectOrCreate?: Enumerable<shopping_listCreateOrConnectWithoutCostumerInput>
    createMany?: shopping_listCreateManyCostumerInputEnvelope
    connect?: Enumerable<shopping_listWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type genderUpdateOneRequiredWithoutCostumerNestedInput = {
    create?: XOR<genderCreateWithoutCostumerInput, genderUncheckedCreateWithoutCostumerInput>
    connectOrCreate?: genderCreateOrConnectWithoutCostumerInput
    upsert?: genderUpsertWithoutCostumerInput
    connect?: genderWhereUniqueInput
    update?: XOR<genderUpdateWithoutCostumerInput, genderUncheckedUpdateWithoutCostumerInput>
  }

  export type costumer_addressesUpdateManyWithoutCostumerNestedInput = {
    create?: XOR<Enumerable<costumer_addressesCreateWithoutCostumerInput>, Enumerable<costumer_addressesUncheckedCreateWithoutCostumerInput>>
    connectOrCreate?: Enumerable<costumer_addressesCreateOrConnectWithoutCostumerInput>
    upsert?: Enumerable<costumer_addressesUpsertWithWhereUniqueWithoutCostumerInput>
    createMany?: costumer_addressesCreateManyCostumerInputEnvelope
    set?: Enumerable<costumer_addressesWhereUniqueInput>
    disconnect?: Enumerable<costumer_addressesWhereUniqueInput>
    delete?: Enumerable<costumer_addressesWhereUniqueInput>
    connect?: Enumerable<costumer_addressesWhereUniqueInput>
    update?: Enumerable<costumer_addressesUpdateWithWhereUniqueWithoutCostumerInput>
    updateMany?: Enumerable<costumer_addressesUpdateManyWithWhereWithoutCostumerInput>
    deleteMany?: Enumerable<costumer_addressesScalarWhereInput>
  }

  export type shopping_listUpdateManyWithoutCostumerNestedInput = {
    create?: XOR<Enumerable<shopping_listCreateWithoutCostumerInput>, Enumerable<shopping_listUncheckedCreateWithoutCostumerInput>>
    connectOrCreate?: Enumerable<shopping_listCreateOrConnectWithoutCostumerInput>
    upsert?: Enumerable<shopping_listUpsertWithWhereUniqueWithoutCostumerInput>
    createMany?: shopping_listCreateManyCostumerInputEnvelope
    set?: Enumerable<shopping_listWhereUniqueInput>
    disconnect?: Enumerable<shopping_listWhereUniqueInput>
    delete?: Enumerable<shopping_listWhereUniqueInput>
    connect?: Enumerable<shopping_listWhereUniqueInput>
    update?: Enumerable<shopping_listUpdateWithWhereUniqueWithoutCostumerInput>
    updateMany?: Enumerable<shopping_listUpdateManyWithWhereWithoutCostumerInput>
    deleteMany?: Enumerable<shopping_listScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type costumer_addressesUncheckedUpdateManyWithoutCostumerNestedInput = {
    create?: XOR<Enumerable<costumer_addressesCreateWithoutCostumerInput>, Enumerable<costumer_addressesUncheckedCreateWithoutCostumerInput>>
    connectOrCreate?: Enumerable<costumer_addressesCreateOrConnectWithoutCostumerInput>
    upsert?: Enumerable<costumer_addressesUpsertWithWhereUniqueWithoutCostumerInput>
    createMany?: costumer_addressesCreateManyCostumerInputEnvelope
    set?: Enumerable<costumer_addressesWhereUniqueInput>
    disconnect?: Enumerable<costumer_addressesWhereUniqueInput>
    delete?: Enumerable<costumer_addressesWhereUniqueInput>
    connect?: Enumerable<costumer_addressesWhereUniqueInput>
    update?: Enumerable<costumer_addressesUpdateWithWhereUniqueWithoutCostumerInput>
    updateMany?: Enumerable<costumer_addressesUpdateManyWithWhereWithoutCostumerInput>
    deleteMany?: Enumerable<costumer_addressesScalarWhereInput>
  }

  export type shopping_listUncheckedUpdateManyWithoutCostumerNestedInput = {
    create?: XOR<Enumerable<shopping_listCreateWithoutCostumerInput>, Enumerable<shopping_listUncheckedCreateWithoutCostumerInput>>
    connectOrCreate?: Enumerable<shopping_listCreateOrConnectWithoutCostumerInput>
    upsert?: Enumerable<shopping_listUpsertWithWhereUniqueWithoutCostumerInput>
    createMany?: shopping_listCreateManyCostumerInputEnvelope
    set?: Enumerable<shopping_listWhereUniqueInput>
    disconnect?: Enumerable<shopping_listWhereUniqueInput>
    delete?: Enumerable<shopping_listWhereUniqueInput>
    connect?: Enumerable<shopping_listWhereUniqueInput>
    update?: Enumerable<shopping_listUpdateWithWhereUniqueWithoutCostumerInput>
    updateMany?: Enumerable<shopping_listUpdateManyWithWhereWithoutCostumerInput>
    deleteMany?: Enumerable<shopping_listScalarWhereInput>
  }

  export type genderCreateNestedOneWithoutDeliverymanInput = {
    create?: XOR<genderCreateWithoutDeliverymanInput, genderUncheckedCreateWithoutDeliverymanInput>
    connectOrCreate?: genderCreateOrConnectWithoutDeliverymanInput
    connect?: genderWhereUniqueInput
  }

  export type locationCreateNestedOneWithoutDeliverymanInput = {
    create?: XOR<locationCreateWithoutDeliverymanInput, locationUncheckedCreateWithoutDeliverymanInput>
    connectOrCreate?: locationCreateOrConnectWithoutDeliverymanInput
    connect?: locationWhereUniqueInput
  }

  export type orderCreateNestedManyWithoutDeliverymanInput = {
    create?: XOR<Enumerable<orderCreateWithoutDeliverymanInput>, Enumerable<orderUncheckedCreateWithoutDeliverymanInput>>
    connectOrCreate?: Enumerable<orderCreateOrConnectWithoutDeliverymanInput>
    createMany?: orderCreateManyDeliverymanInputEnvelope
    connect?: Enumerable<orderWhereUniqueInput>
  }

  export type veicule_deliverymanCreateNestedManyWithoutOwnerInput = {
    create?: XOR<Enumerable<veicule_deliverymanCreateWithoutOwnerInput>, Enumerable<veicule_deliverymanUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<veicule_deliverymanCreateOrConnectWithoutOwnerInput>
    createMany?: veicule_deliverymanCreateManyOwnerInputEnvelope
    connect?: Enumerable<veicule_deliverymanWhereUniqueInput>
  }

  export type orderUncheckedCreateNestedManyWithoutDeliverymanInput = {
    create?: XOR<Enumerable<orderCreateWithoutDeliverymanInput>, Enumerable<orderUncheckedCreateWithoutDeliverymanInput>>
    connectOrCreate?: Enumerable<orderCreateOrConnectWithoutDeliverymanInput>
    createMany?: orderCreateManyDeliverymanInputEnvelope
    connect?: Enumerable<orderWhereUniqueInput>
  }

  export type veicule_deliverymanUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<Enumerable<veicule_deliverymanCreateWithoutOwnerInput>, Enumerable<veicule_deliverymanUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<veicule_deliverymanCreateOrConnectWithoutOwnerInput>
    createMany?: veicule_deliverymanCreateManyOwnerInputEnvelope
    connect?: Enumerable<veicule_deliverymanWhereUniqueInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type genderUpdateOneRequiredWithoutDeliverymanNestedInput = {
    create?: XOR<genderCreateWithoutDeliverymanInput, genderUncheckedCreateWithoutDeliverymanInput>
    connectOrCreate?: genderCreateOrConnectWithoutDeliverymanInput
    upsert?: genderUpsertWithoutDeliverymanInput
    connect?: genderWhereUniqueInput
    update?: XOR<genderUpdateWithoutDeliverymanInput, genderUncheckedUpdateWithoutDeliverymanInput>
  }

  export type locationUpdateOneRequiredWithoutDeliverymanNestedInput = {
    create?: XOR<locationCreateWithoutDeliverymanInput, locationUncheckedCreateWithoutDeliverymanInput>
    connectOrCreate?: locationCreateOrConnectWithoutDeliverymanInput
    upsert?: locationUpsertWithoutDeliverymanInput
    connect?: locationWhereUniqueInput
    update?: XOR<locationUpdateWithoutDeliverymanInput, locationUncheckedUpdateWithoutDeliverymanInput>
  }

  export type orderUpdateManyWithoutDeliverymanNestedInput = {
    create?: XOR<Enumerable<orderCreateWithoutDeliverymanInput>, Enumerable<orderUncheckedCreateWithoutDeliverymanInput>>
    connectOrCreate?: Enumerable<orderCreateOrConnectWithoutDeliverymanInput>
    upsert?: Enumerable<orderUpsertWithWhereUniqueWithoutDeliverymanInput>
    createMany?: orderCreateManyDeliverymanInputEnvelope
    set?: Enumerable<orderWhereUniqueInput>
    disconnect?: Enumerable<orderWhereUniqueInput>
    delete?: Enumerable<orderWhereUniqueInput>
    connect?: Enumerable<orderWhereUniqueInput>
    update?: Enumerable<orderUpdateWithWhereUniqueWithoutDeliverymanInput>
    updateMany?: Enumerable<orderUpdateManyWithWhereWithoutDeliverymanInput>
    deleteMany?: Enumerable<orderScalarWhereInput>
  }

  export type veicule_deliverymanUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<Enumerable<veicule_deliverymanCreateWithoutOwnerInput>, Enumerable<veicule_deliverymanUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<veicule_deliverymanCreateOrConnectWithoutOwnerInput>
    upsert?: Enumerable<veicule_deliverymanUpsertWithWhereUniqueWithoutOwnerInput>
    createMany?: veicule_deliverymanCreateManyOwnerInputEnvelope
    set?: Enumerable<veicule_deliverymanWhereUniqueInput>
    disconnect?: Enumerable<veicule_deliverymanWhereUniqueInput>
    delete?: Enumerable<veicule_deliverymanWhereUniqueInput>
    connect?: Enumerable<veicule_deliverymanWhereUniqueInput>
    update?: Enumerable<veicule_deliverymanUpdateWithWhereUniqueWithoutOwnerInput>
    updateMany?: Enumerable<veicule_deliverymanUpdateManyWithWhereWithoutOwnerInput>
    deleteMany?: Enumerable<veicule_deliverymanScalarWhereInput>
  }

  export type orderUncheckedUpdateManyWithoutDeliverymanNestedInput = {
    create?: XOR<Enumerable<orderCreateWithoutDeliverymanInput>, Enumerable<orderUncheckedCreateWithoutDeliverymanInput>>
    connectOrCreate?: Enumerable<orderCreateOrConnectWithoutDeliverymanInput>
    upsert?: Enumerable<orderUpsertWithWhereUniqueWithoutDeliverymanInput>
    createMany?: orderCreateManyDeliverymanInputEnvelope
    set?: Enumerable<orderWhereUniqueInput>
    disconnect?: Enumerable<orderWhereUniqueInput>
    delete?: Enumerable<orderWhereUniqueInput>
    connect?: Enumerable<orderWhereUniqueInput>
    update?: Enumerable<orderUpdateWithWhereUniqueWithoutDeliverymanInput>
    updateMany?: Enumerable<orderUpdateManyWithWhereWithoutDeliverymanInput>
    deleteMany?: Enumerable<orderScalarWhereInput>
  }

  export type veicule_deliverymanUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<Enumerable<veicule_deliverymanCreateWithoutOwnerInput>, Enumerable<veicule_deliverymanUncheckedCreateWithoutOwnerInput>>
    connectOrCreate?: Enumerable<veicule_deliverymanCreateOrConnectWithoutOwnerInput>
    upsert?: Enumerable<veicule_deliverymanUpsertWithWhereUniqueWithoutOwnerInput>
    createMany?: veicule_deliverymanCreateManyOwnerInputEnvelope
    set?: Enumerable<veicule_deliverymanWhereUniqueInput>
    disconnect?: Enumerable<veicule_deliverymanWhereUniqueInput>
    delete?: Enumerable<veicule_deliverymanWhereUniqueInput>
    connect?: Enumerable<veicule_deliverymanWhereUniqueInput>
    update?: Enumerable<veicule_deliverymanUpdateWithWhereUniqueWithoutOwnerInput>
    updateMany?: Enumerable<veicule_deliverymanUpdateManyWithWhereWithoutOwnerInput>
    deleteMany?: Enumerable<veicule_deliverymanScalarWhereInput>
  }

  export type deliverymanCreateNestedOneWithoutVeicule_deliverymanInput = {
    create?: XOR<deliverymanCreateWithoutVeicule_deliverymanInput, deliverymanUncheckedCreateWithoutVeicule_deliverymanInput>
    connectOrCreate?: deliverymanCreateOrConnectWithoutVeicule_deliverymanInput
    connect?: deliverymanWhereUniqueInput
  }

  export type veiculeCreateNestedOneWithoutVeicule_deliverymanInput = {
    create?: XOR<veiculeCreateWithoutVeicule_deliverymanInput, veiculeUncheckedCreateWithoutVeicule_deliverymanInput>
    connectOrCreate?: veiculeCreateOrConnectWithoutVeicule_deliverymanInput
    connect?: veiculeWhereUniqueInput
  }

  export type deliverymanUpdateOneRequiredWithoutVeicule_deliverymanNestedInput = {
    create?: XOR<deliverymanCreateWithoutVeicule_deliverymanInput, deliverymanUncheckedCreateWithoutVeicule_deliverymanInput>
    connectOrCreate?: deliverymanCreateOrConnectWithoutVeicule_deliverymanInput
    upsert?: deliverymanUpsertWithoutVeicule_deliverymanInput
    connect?: deliverymanWhereUniqueInput
    update?: XOR<deliverymanUpdateWithoutVeicule_deliverymanInput, deliverymanUncheckedUpdateWithoutVeicule_deliverymanInput>
  }

  export type veiculeUpdateOneRequiredWithoutVeicule_deliverymanNestedInput = {
    create?: XOR<veiculeCreateWithoutVeicule_deliverymanInput, veiculeUncheckedCreateWithoutVeicule_deliverymanInput>
    connectOrCreate?: veiculeCreateOrConnectWithoutVeicule_deliverymanInput
    upsert?: veiculeUpsertWithoutVeicule_deliverymanInput
    connect?: veiculeWhereUniqueInput
    update?: XOR<veiculeUpdateWithoutVeicule_deliverymanInput, veiculeUncheckedUpdateWithoutVeicule_deliverymanInput>
  }

  export type orderCreateNestedOneWithoutPaymentInput = {
    create?: XOR<orderCreateWithoutPaymentInput, orderUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: orderCreateOrConnectWithoutPaymentInput
    connect?: orderWhereUniqueInput
  }

  export type payment_methodCreateNestedOneWithoutPaymentInput = {
    create?: XOR<payment_methodCreateWithoutPaymentInput, payment_methodUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: payment_methodCreateOrConnectWithoutPaymentInput
    connect?: payment_methodWhereUniqueInput
  }

  export type orderUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<orderCreateWithoutPaymentInput, orderUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: orderCreateOrConnectWithoutPaymentInput
    upsert?: orderUpsertWithoutPaymentInput
    connect?: orderWhereUniqueInput
    update?: XOR<orderUpdateWithoutPaymentInput, orderUncheckedUpdateWithoutPaymentInput>
  }

  export type payment_methodUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<payment_methodCreateWithoutPaymentInput, payment_methodUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: payment_methodCreateOrConnectWithoutPaymentInput
    upsert?: payment_methodUpsertWithoutPaymentInput
    connect?: payment_methodWhereUniqueInput
    update?: XOR<payment_methodUpdateWithoutPaymentInput, payment_methodUncheckedUpdateWithoutPaymentInput>
  }

  export type costumer_addressesCreateNestedOneWithoutOrderInput = {
    create?: XOR<costumer_addressesCreateWithoutOrderInput, costumer_addressesUncheckedCreateWithoutOrderInput>
    connectOrCreate?: costumer_addressesCreateOrConnectWithoutOrderInput
    connect?: costumer_addressesWhereUniqueInput
  }

  export type deliverymanCreateNestedOneWithoutOrderInput = {
    create?: XOR<deliverymanCreateWithoutOrderInput, deliverymanUncheckedCreateWithoutOrderInput>
    connectOrCreate?: deliverymanCreateOrConnectWithoutOrderInput
    connect?: deliverymanWhereUniqueInput
  }

  export type shopping_listCreateNestedOneWithoutOrderInput = {
    create?: XOR<shopping_listCreateWithoutOrderInput, shopping_listUncheckedCreateWithoutOrderInput>
    connectOrCreate?: shopping_listCreateOrConnectWithoutOrderInput
    connect?: shopping_listWhereUniqueInput
  }

  export type paymentCreateNestedOneWithoutOrderInput = {
    create?: XOR<paymentCreateWithoutOrderInput, paymentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: paymentCreateOrConnectWithoutOrderInput
    connect?: paymentWhereUniqueInput
  }

  export type paymentUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<paymentCreateWithoutOrderInput, paymentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: paymentCreateOrConnectWithoutOrderInput
    connect?: paymentWhereUniqueInput
  }

  export type costumer_addressesUpdateOneRequiredWithoutOrderNestedInput = {
    create?: XOR<costumer_addressesCreateWithoutOrderInput, costumer_addressesUncheckedCreateWithoutOrderInput>
    connectOrCreate?: costumer_addressesCreateOrConnectWithoutOrderInput
    upsert?: costumer_addressesUpsertWithoutOrderInput
    connect?: costumer_addressesWhereUniqueInput
    update?: XOR<costumer_addressesUpdateWithoutOrderInput, costumer_addressesUncheckedUpdateWithoutOrderInput>
  }

  export type deliverymanUpdateOneWithoutOrderNestedInput = {
    create?: XOR<deliverymanCreateWithoutOrderInput, deliverymanUncheckedCreateWithoutOrderInput>
    connectOrCreate?: deliverymanCreateOrConnectWithoutOrderInput
    upsert?: deliverymanUpsertWithoutOrderInput
    disconnect?: boolean
    delete?: boolean
    connect?: deliverymanWhereUniqueInput
    update?: XOR<deliverymanUpdateWithoutOrderInput, deliverymanUncheckedUpdateWithoutOrderInput>
  }

  export type shopping_listUpdateOneRequiredWithoutOrderNestedInput = {
    create?: XOR<shopping_listCreateWithoutOrderInput, shopping_listUncheckedCreateWithoutOrderInput>
    connectOrCreate?: shopping_listCreateOrConnectWithoutOrderInput
    upsert?: shopping_listUpsertWithoutOrderInput
    connect?: shopping_listWhereUniqueInput
    update?: XOR<shopping_listUpdateWithoutOrderInput, shopping_listUncheckedUpdateWithoutOrderInput>
  }

  export type paymentUpdateOneWithoutOrderNestedInput = {
    create?: XOR<paymentCreateWithoutOrderInput, paymentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: paymentCreateOrConnectWithoutOrderInput
    upsert?: paymentUpsertWithoutOrderInput
    disconnect?: boolean
    delete?: boolean
    connect?: paymentWhereUniqueInput
    update?: XOR<paymentUpdateWithoutOrderInput, paymentUncheckedUpdateWithoutOrderInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type paymentUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<paymentCreateWithoutOrderInput, paymentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: paymentCreateOrConnectWithoutOrderInput
    upsert?: paymentUpsertWithoutOrderInput
    disconnect?: boolean
    delete?: boolean
    connect?: paymentWhereUniqueInput
    update?: XOR<paymentUpdateWithoutOrderInput, paymentUncheckedUpdateWithoutOrderInput>
  }

  export type orderCreateNestedOneWithoutShopping_listInput = {
    create?: XOR<orderCreateWithoutShopping_listInput, orderUncheckedCreateWithoutShopping_listInput>
    connectOrCreate?: orderCreateOrConnectWithoutShopping_listInput
    connect?: orderWhereUniqueInput
  }

  export type products_in_shopping_listCreateNestedManyWithoutShopping_listInput = {
    create?: XOR<Enumerable<products_in_shopping_listCreateWithoutShopping_listInput>, Enumerable<products_in_shopping_listUncheckedCreateWithoutShopping_listInput>>
    connectOrCreate?: Enumerable<products_in_shopping_listCreateOrConnectWithoutShopping_listInput>
    createMany?: products_in_shopping_listCreateManyShopping_listInputEnvelope
    connect?: Enumerable<products_in_shopping_listWhereUniqueInput>
  }

  export type costumerCreateNestedOneWithoutShopping_listsInput = {
    create?: XOR<costumerCreateWithoutShopping_listsInput, costumerUncheckedCreateWithoutShopping_listsInput>
    connectOrCreate?: costumerCreateOrConnectWithoutShopping_listsInput
    connect?: costumerWhereUniqueInput
  }

  export type orderUncheckedCreateNestedOneWithoutShopping_listInput = {
    create?: XOR<orderCreateWithoutShopping_listInput, orderUncheckedCreateWithoutShopping_listInput>
    connectOrCreate?: orderCreateOrConnectWithoutShopping_listInput
    connect?: orderWhereUniqueInput
  }

  export type products_in_shopping_listUncheckedCreateNestedManyWithoutShopping_listInput = {
    create?: XOR<Enumerable<products_in_shopping_listCreateWithoutShopping_listInput>, Enumerable<products_in_shopping_listUncheckedCreateWithoutShopping_listInput>>
    connectOrCreate?: Enumerable<products_in_shopping_listCreateOrConnectWithoutShopping_listInput>
    createMany?: products_in_shopping_listCreateManyShopping_listInputEnvelope
    connect?: Enumerable<products_in_shopping_listWhereUniqueInput>
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type orderUpdateOneWithoutShopping_listNestedInput = {
    create?: XOR<orderCreateWithoutShopping_listInput, orderUncheckedCreateWithoutShopping_listInput>
    connectOrCreate?: orderCreateOrConnectWithoutShopping_listInput
    upsert?: orderUpsertWithoutShopping_listInput
    disconnect?: boolean
    delete?: boolean
    connect?: orderWhereUniqueInput
    update?: XOR<orderUpdateWithoutShopping_listInput, orderUncheckedUpdateWithoutShopping_listInput>
  }

  export type products_in_shopping_listUpdateManyWithoutShopping_listNestedInput = {
    create?: XOR<Enumerable<products_in_shopping_listCreateWithoutShopping_listInput>, Enumerable<products_in_shopping_listUncheckedCreateWithoutShopping_listInput>>
    connectOrCreate?: Enumerable<products_in_shopping_listCreateOrConnectWithoutShopping_listInput>
    upsert?: Enumerable<products_in_shopping_listUpsertWithWhereUniqueWithoutShopping_listInput>
    createMany?: products_in_shopping_listCreateManyShopping_listInputEnvelope
    set?: Enumerable<products_in_shopping_listWhereUniqueInput>
    disconnect?: Enumerable<products_in_shopping_listWhereUniqueInput>
    delete?: Enumerable<products_in_shopping_listWhereUniqueInput>
    connect?: Enumerable<products_in_shopping_listWhereUniqueInput>
    update?: Enumerable<products_in_shopping_listUpdateWithWhereUniqueWithoutShopping_listInput>
    updateMany?: Enumerable<products_in_shopping_listUpdateManyWithWhereWithoutShopping_listInput>
    deleteMany?: Enumerable<products_in_shopping_listScalarWhereInput>
  }

  export type costumerUpdateOneRequiredWithoutShopping_listsNestedInput = {
    create?: XOR<costumerCreateWithoutShopping_listsInput, costumerUncheckedCreateWithoutShopping_listsInput>
    connectOrCreate?: costumerCreateOrConnectWithoutShopping_listsInput
    upsert?: costumerUpsertWithoutShopping_listsInput
    connect?: costumerWhereUniqueInput
    update?: XOR<costumerUpdateWithoutShopping_listsInput, costumerUncheckedUpdateWithoutShopping_listsInput>
  }

  export type orderUncheckedUpdateOneWithoutShopping_listNestedInput = {
    create?: XOR<orderCreateWithoutShopping_listInput, orderUncheckedCreateWithoutShopping_listInput>
    connectOrCreate?: orderCreateOrConnectWithoutShopping_listInput
    upsert?: orderUpsertWithoutShopping_listInput
    disconnect?: boolean
    delete?: boolean
    connect?: orderWhereUniqueInput
    update?: XOR<orderUpdateWithoutShopping_listInput, orderUncheckedUpdateWithoutShopping_listInput>
  }

  export type products_in_shopping_listUncheckedUpdateManyWithoutShopping_listNestedInput = {
    create?: XOR<Enumerable<products_in_shopping_listCreateWithoutShopping_listInput>, Enumerable<products_in_shopping_listUncheckedCreateWithoutShopping_listInput>>
    connectOrCreate?: Enumerable<products_in_shopping_listCreateOrConnectWithoutShopping_listInput>
    upsert?: Enumerable<products_in_shopping_listUpsertWithWhereUniqueWithoutShopping_listInput>
    createMany?: products_in_shopping_listCreateManyShopping_listInputEnvelope
    set?: Enumerable<products_in_shopping_listWhereUniqueInput>
    disconnect?: Enumerable<products_in_shopping_listWhereUniqueInput>
    delete?: Enumerable<products_in_shopping_listWhereUniqueInput>
    connect?: Enumerable<products_in_shopping_listWhereUniqueInput>
    update?: Enumerable<products_in_shopping_listUpdateWithWhereUniqueWithoutShopping_listInput>
    updateMany?: Enumerable<products_in_shopping_listUpdateManyWithWhereWithoutShopping_listInput>
    deleteMany?: Enumerable<products_in_shopping_listScalarWhereInput>
  }

  export type productCreateNestedOneWithoutProducts_in_shopping_listInput = {
    create?: XOR<productCreateWithoutProducts_in_shopping_listInput, productUncheckedCreateWithoutProducts_in_shopping_listInput>
    connectOrCreate?: productCreateOrConnectWithoutProducts_in_shopping_listInput
    connect?: productWhereUniqueInput
  }

  export type shopping_listCreateNestedOneWithoutProducts_in_shopping_listInput = {
    create?: XOR<shopping_listCreateWithoutProducts_in_shopping_listInput, shopping_listUncheckedCreateWithoutProducts_in_shopping_listInput>
    connectOrCreate?: shopping_listCreateOrConnectWithoutProducts_in_shopping_listInput
    connect?: shopping_listWhereUniqueInput
  }

  export type productUpdateOneRequiredWithoutProducts_in_shopping_listNestedInput = {
    create?: XOR<productCreateWithoutProducts_in_shopping_listInput, productUncheckedCreateWithoutProducts_in_shopping_listInput>
    connectOrCreate?: productCreateOrConnectWithoutProducts_in_shopping_listInput
    upsert?: productUpsertWithoutProducts_in_shopping_listInput
    connect?: productWhereUniqueInput
    update?: XOR<productUpdateWithoutProducts_in_shopping_listInput, productUncheckedUpdateWithoutProducts_in_shopping_listInput>
  }

  export type shopping_listUpdateOneRequiredWithoutProducts_in_shopping_listNestedInput = {
    create?: XOR<shopping_listCreateWithoutProducts_in_shopping_listInput, shopping_listUncheckedCreateWithoutProducts_in_shopping_listInput>
    connectOrCreate?: shopping_listCreateOrConnectWithoutProducts_in_shopping_listInput
    upsert?: shopping_listUpsertWithoutProducts_in_shopping_listInput
    connect?: shopping_listWhereUniqueInput
    update?: XOR<shopping_listUpdateWithoutProducts_in_shopping_listInput, shopping_listUncheckedUpdateWithoutProducts_in_shopping_listInput>
  }

  export type image_of_productCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<image_of_productCreateWithoutProductInput>, Enumerable<image_of_productUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<image_of_productCreateOrConnectWithoutProductInput>
    createMany?: image_of_productCreateManyProductInputEnvelope
    connect?: Enumerable<image_of_productWhereUniqueInput>
  }

  export type category_of_productCreateNestedOneWithoutProductInput = {
    create?: XOR<category_of_productCreateWithoutProductInput, category_of_productUncheckedCreateWithoutProductInput>
    connectOrCreate?: category_of_productCreateOrConnectWithoutProductInput
    connect?: category_of_productWhereUniqueInput
  }

  export type marketerCreateNestedOneWithoutProductsInput = {
    create?: XOR<marketerCreateWithoutProductsInput, marketerUncheckedCreateWithoutProductsInput>
    connectOrCreate?: marketerCreateOrConnectWithoutProductsInput
    connect?: marketerWhereUniqueInput
  }

  export type type_of_priceCreateNestedOneWithoutProductInput = {
    create?: XOR<type_of_priceCreateWithoutProductInput, type_of_priceUncheckedCreateWithoutProductInput>
    connectOrCreate?: type_of_priceCreateOrConnectWithoutProductInput
    connect?: type_of_priceWhereUniqueInput
  }

  export type products_in_shopping_listCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<products_in_shopping_listCreateWithoutProductInput>, Enumerable<products_in_shopping_listUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<products_in_shopping_listCreateOrConnectWithoutProductInput>
    createMany?: products_in_shopping_listCreateManyProductInputEnvelope
    connect?: Enumerable<products_in_shopping_listWhereUniqueInput>
  }

  export type sale_offCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<sale_offCreateWithoutProductInput>, Enumerable<sale_offUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<sale_offCreateOrConnectWithoutProductInput>
    createMany?: sale_offCreateManyProductInputEnvelope
    connect?: Enumerable<sale_offWhereUniqueInput>
  }

  export type image_of_productUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<image_of_productCreateWithoutProductInput>, Enumerable<image_of_productUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<image_of_productCreateOrConnectWithoutProductInput>
    createMany?: image_of_productCreateManyProductInputEnvelope
    connect?: Enumerable<image_of_productWhereUniqueInput>
  }

  export type products_in_shopping_listUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<products_in_shopping_listCreateWithoutProductInput>, Enumerable<products_in_shopping_listUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<products_in_shopping_listCreateOrConnectWithoutProductInput>
    createMany?: products_in_shopping_listCreateManyProductInputEnvelope
    connect?: Enumerable<products_in_shopping_listWhereUniqueInput>
  }

  export type sale_offUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Enumerable<sale_offCreateWithoutProductInput>, Enumerable<sale_offUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<sale_offCreateOrConnectWithoutProductInput>
    createMany?: sale_offCreateManyProductInputEnvelope
    connect?: Enumerable<sale_offWhereUniqueInput>
  }

  export type image_of_productUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<image_of_productCreateWithoutProductInput>, Enumerable<image_of_productUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<image_of_productCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<image_of_productUpsertWithWhereUniqueWithoutProductInput>
    createMany?: image_of_productCreateManyProductInputEnvelope
    set?: Enumerable<image_of_productWhereUniqueInput>
    disconnect?: Enumerable<image_of_productWhereUniqueInput>
    delete?: Enumerable<image_of_productWhereUniqueInput>
    connect?: Enumerable<image_of_productWhereUniqueInput>
    update?: Enumerable<image_of_productUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<image_of_productUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<image_of_productScalarWhereInput>
  }

  export type category_of_productUpdateOneRequiredWithoutProductNestedInput = {
    create?: XOR<category_of_productCreateWithoutProductInput, category_of_productUncheckedCreateWithoutProductInput>
    connectOrCreate?: category_of_productCreateOrConnectWithoutProductInput
    upsert?: category_of_productUpsertWithoutProductInput
    connect?: category_of_productWhereUniqueInput
    update?: XOR<category_of_productUpdateWithoutProductInput, category_of_productUncheckedUpdateWithoutProductInput>
  }

  export type marketerUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<marketerCreateWithoutProductsInput, marketerUncheckedCreateWithoutProductsInput>
    connectOrCreate?: marketerCreateOrConnectWithoutProductsInput
    upsert?: marketerUpsertWithoutProductsInput
    connect?: marketerWhereUniqueInput
    update?: XOR<marketerUpdateWithoutProductsInput, marketerUncheckedUpdateWithoutProductsInput>
  }

  export type type_of_priceUpdateOneRequiredWithoutProductNestedInput = {
    create?: XOR<type_of_priceCreateWithoutProductInput, type_of_priceUncheckedCreateWithoutProductInput>
    connectOrCreate?: type_of_priceCreateOrConnectWithoutProductInput
    upsert?: type_of_priceUpsertWithoutProductInput
    connect?: type_of_priceWhereUniqueInput
    update?: XOR<type_of_priceUpdateWithoutProductInput, type_of_priceUncheckedUpdateWithoutProductInput>
  }

  export type products_in_shopping_listUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<products_in_shopping_listCreateWithoutProductInput>, Enumerable<products_in_shopping_listUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<products_in_shopping_listCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<products_in_shopping_listUpsertWithWhereUniqueWithoutProductInput>
    createMany?: products_in_shopping_listCreateManyProductInputEnvelope
    set?: Enumerable<products_in_shopping_listWhereUniqueInput>
    disconnect?: Enumerable<products_in_shopping_listWhereUniqueInput>
    delete?: Enumerable<products_in_shopping_listWhereUniqueInput>
    connect?: Enumerable<products_in_shopping_listWhereUniqueInput>
    update?: Enumerable<products_in_shopping_listUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<products_in_shopping_listUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<products_in_shopping_listScalarWhereInput>
  }

  export type sale_offUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<sale_offCreateWithoutProductInput>, Enumerable<sale_offUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<sale_offCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<sale_offUpsertWithWhereUniqueWithoutProductInput>
    createMany?: sale_offCreateManyProductInputEnvelope
    set?: Enumerable<sale_offWhereUniqueInput>
    disconnect?: Enumerable<sale_offWhereUniqueInput>
    delete?: Enumerable<sale_offWhereUniqueInput>
    connect?: Enumerable<sale_offWhereUniqueInput>
    update?: Enumerable<sale_offUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<sale_offUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<sale_offScalarWhereInput>
  }

  export type image_of_productUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<image_of_productCreateWithoutProductInput>, Enumerable<image_of_productUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<image_of_productCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<image_of_productUpsertWithWhereUniqueWithoutProductInput>
    createMany?: image_of_productCreateManyProductInputEnvelope
    set?: Enumerable<image_of_productWhereUniqueInput>
    disconnect?: Enumerable<image_of_productWhereUniqueInput>
    delete?: Enumerable<image_of_productWhereUniqueInput>
    connect?: Enumerable<image_of_productWhereUniqueInput>
    update?: Enumerable<image_of_productUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<image_of_productUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<image_of_productScalarWhereInput>
  }

  export type products_in_shopping_listUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<products_in_shopping_listCreateWithoutProductInput>, Enumerable<products_in_shopping_listUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<products_in_shopping_listCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<products_in_shopping_listUpsertWithWhereUniqueWithoutProductInput>
    createMany?: products_in_shopping_listCreateManyProductInputEnvelope
    set?: Enumerable<products_in_shopping_listWhereUniqueInput>
    disconnect?: Enumerable<products_in_shopping_listWhereUniqueInput>
    delete?: Enumerable<products_in_shopping_listWhereUniqueInput>
    connect?: Enumerable<products_in_shopping_listWhereUniqueInput>
    update?: Enumerable<products_in_shopping_listUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<products_in_shopping_listUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<products_in_shopping_listScalarWhereInput>
  }

  export type sale_offUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Enumerable<sale_offCreateWithoutProductInput>, Enumerable<sale_offUncheckedCreateWithoutProductInput>>
    connectOrCreate?: Enumerable<sale_offCreateOrConnectWithoutProductInput>
    upsert?: Enumerable<sale_offUpsertWithWhereUniqueWithoutProductInput>
    createMany?: sale_offCreateManyProductInputEnvelope
    set?: Enumerable<sale_offWhereUniqueInput>
    disconnect?: Enumerable<sale_offWhereUniqueInput>
    delete?: Enumerable<sale_offWhereUniqueInput>
    connect?: Enumerable<sale_offWhereUniqueInput>
    update?: Enumerable<sale_offUpdateWithWhereUniqueWithoutProductInput>
    updateMany?: Enumerable<sale_offUpdateManyWithWhereWithoutProductInput>
    deleteMany?: Enumerable<sale_offScalarWhereInput>
  }

  export type fair_marketersCreateNestedManyWithoutMarketerInput = {
    create?: XOR<Enumerable<fair_marketersCreateWithoutMarketerInput>, Enumerable<fair_marketersUncheckedCreateWithoutMarketerInput>>
    connectOrCreate?: Enumerable<fair_marketersCreateOrConnectWithoutMarketerInput>
    createMany?: fair_marketersCreateManyMarketerInputEnvelope
    connect?: Enumerable<fair_marketersWhereUniqueInput>
  }

  export type genderCreateNestedOneWithoutMarketerInput = {
    create?: XOR<genderCreateWithoutMarketerInput, genderUncheckedCreateWithoutMarketerInput>
    connectOrCreate?: genderCreateOrConnectWithoutMarketerInput
    connect?: genderWhereUniqueInput
  }

  export type locationCreateNestedOneWithoutMarketerInput = {
    create?: XOR<locationCreateWithoutMarketerInput, locationUncheckedCreateWithoutMarketerInput>
    connectOrCreate?: locationCreateOrConnectWithoutMarketerInput
    connect?: locationWhereUniqueInput
  }

  export type productCreateNestedManyWithoutMarketerInput = {
    create?: XOR<Enumerable<productCreateWithoutMarketerInput>, Enumerable<productUncheckedCreateWithoutMarketerInput>>
    connectOrCreate?: Enumerable<productCreateOrConnectWithoutMarketerInput>
    createMany?: productCreateManyMarketerInputEnvelope
    connect?: Enumerable<productWhereUniqueInput>
  }

  export type fair_marketersUncheckedCreateNestedManyWithoutMarketerInput = {
    create?: XOR<Enumerable<fair_marketersCreateWithoutMarketerInput>, Enumerable<fair_marketersUncheckedCreateWithoutMarketerInput>>
    connectOrCreate?: Enumerable<fair_marketersCreateOrConnectWithoutMarketerInput>
    createMany?: fair_marketersCreateManyMarketerInputEnvelope
    connect?: Enumerable<fair_marketersWhereUniqueInput>
  }

  export type productUncheckedCreateNestedManyWithoutMarketerInput = {
    create?: XOR<Enumerable<productCreateWithoutMarketerInput>, Enumerable<productUncheckedCreateWithoutMarketerInput>>
    connectOrCreate?: Enumerable<productCreateOrConnectWithoutMarketerInput>
    createMany?: productCreateManyMarketerInputEnvelope
    connect?: Enumerable<productWhereUniqueInput>
  }

  export type fair_marketersUpdateManyWithoutMarketerNestedInput = {
    create?: XOR<Enumerable<fair_marketersCreateWithoutMarketerInput>, Enumerable<fair_marketersUncheckedCreateWithoutMarketerInput>>
    connectOrCreate?: Enumerable<fair_marketersCreateOrConnectWithoutMarketerInput>
    upsert?: Enumerable<fair_marketersUpsertWithWhereUniqueWithoutMarketerInput>
    createMany?: fair_marketersCreateManyMarketerInputEnvelope
    set?: Enumerable<fair_marketersWhereUniqueInput>
    disconnect?: Enumerable<fair_marketersWhereUniqueInput>
    delete?: Enumerable<fair_marketersWhereUniqueInput>
    connect?: Enumerable<fair_marketersWhereUniqueInput>
    update?: Enumerable<fair_marketersUpdateWithWhereUniqueWithoutMarketerInput>
    updateMany?: Enumerable<fair_marketersUpdateManyWithWhereWithoutMarketerInput>
    deleteMany?: Enumerable<fair_marketersScalarWhereInput>
  }

  export type genderUpdateOneRequiredWithoutMarketerNestedInput = {
    create?: XOR<genderCreateWithoutMarketerInput, genderUncheckedCreateWithoutMarketerInput>
    connectOrCreate?: genderCreateOrConnectWithoutMarketerInput
    upsert?: genderUpsertWithoutMarketerInput
    connect?: genderWhereUniqueInput
    update?: XOR<genderUpdateWithoutMarketerInput, genderUncheckedUpdateWithoutMarketerInput>
  }

  export type locationUpdateOneRequiredWithoutMarketerNestedInput = {
    create?: XOR<locationCreateWithoutMarketerInput, locationUncheckedCreateWithoutMarketerInput>
    connectOrCreate?: locationCreateOrConnectWithoutMarketerInput
    upsert?: locationUpsertWithoutMarketerInput
    connect?: locationWhereUniqueInput
    update?: XOR<locationUpdateWithoutMarketerInput, locationUncheckedUpdateWithoutMarketerInput>
  }

  export type productUpdateManyWithoutMarketerNestedInput = {
    create?: XOR<Enumerable<productCreateWithoutMarketerInput>, Enumerable<productUncheckedCreateWithoutMarketerInput>>
    connectOrCreate?: Enumerable<productCreateOrConnectWithoutMarketerInput>
    upsert?: Enumerable<productUpsertWithWhereUniqueWithoutMarketerInput>
    createMany?: productCreateManyMarketerInputEnvelope
    set?: Enumerable<productWhereUniqueInput>
    disconnect?: Enumerable<productWhereUniqueInput>
    delete?: Enumerable<productWhereUniqueInput>
    connect?: Enumerable<productWhereUniqueInput>
    update?: Enumerable<productUpdateWithWhereUniqueWithoutMarketerInput>
    updateMany?: Enumerable<productUpdateManyWithWhereWithoutMarketerInput>
    deleteMany?: Enumerable<productScalarWhereInput>
  }

  export type fair_marketersUncheckedUpdateManyWithoutMarketerNestedInput = {
    create?: XOR<Enumerable<fair_marketersCreateWithoutMarketerInput>, Enumerable<fair_marketersUncheckedCreateWithoutMarketerInput>>
    connectOrCreate?: Enumerable<fair_marketersCreateOrConnectWithoutMarketerInput>
    upsert?: Enumerable<fair_marketersUpsertWithWhereUniqueWithoutMarketerInput>
    createMany?: fair_marketersCreateManyMarketerInputEnvelope
    set?: Enumerable<fair_marketersWhereUniqueInput>
    disconnect?: Enumerable<fair_marketersWhereUniqueInput>
    delete?: Enumerable<fair_marketersWhereUniqueInput>
    connect?: Enumerable<fair_marketersWhereUniqueInput>
    update?: Enumerable<fair_marketersUpdateWithWhereUniqueWithoutMarketerInput>
    updateMany?: Enumerable<fair_marketersUpdateManyWithWhereWithoutMarketerInput>
    deleteMany?: Enumerable<fair_marketersScalarWhereInput>
  }

  export type productUncheckedUpdateManyWithoutMarketerNestedInput = {
    create?: XOR<Enumerable<productCreateWithoutMarketerInput>, Enumerable<productUncheckedCreateWithoutMarketerInput>>
    connectOrCreate?: Enumerable<productCreateOrConnectWithoutMarketerInput>
    upsert?: Enumerable<productUpsertWithWhereUniqueWithoutMarketerInput>
    createMany?: productCreateManyMarketerInputEnvelope
    set?: Enumerable<productWhereUniqueInput>
    disconnect?: Enumerable<productWhereUniqueInput>
    delete?: Enumerable<productWhereUniqueInput>
    connect?: Enumerable<productWhereUniqueInput>
    update?: Enumerable<productUpdateWithWhereUniqueWithoutMarketerInput>
    updateMany?: Enumerable<productUpdateManyWithWhereWithoutMarketerInput>
    deleteMany?: Enumerable<productScalarWhereInput>
  }

  export type addressCreateNestedOneWithoutFairInput = {
    create?: XOR<addressCreateWithoutFairInput, addressUncheckedCreateWithoutFairInput>
    connectOrCreate?: addressCreateOrConnectWithoutFairInput
    connect?: addressWhereUniqueInput
  }

  export type locationCreateNestedOneWithoutFairInput = {
    create?: XOR<locationCreateWithoutFairInput, locationUncheckedCreateWithoutFairInput>
    connectOrCreate?: locationCreateOrConnectWithoutFairInput
    connect?: locationWhereUniqueInput
  }

  export type fair_date_hour_of_workCreateNestedManyWithoutFairInput = {
    create?: XOR<Enumerable<fair_date_hour_of_workCreateWithoutFairInput>, Enumerable<fair_date_hour_of_workUncheckedCreateWithoutFairInput>>
    connectOrCreate?: Enumerable<fair_date_hour_of_workCreateOrConnectWithoutFairInput>
    createMany?: fair_date_hour_of_workCreateManyFairInputEnvelope
    connect?: Enumerable<fair_date_hour_of_workWhereUniqueInput>
  }

  export type fair_marketersCreateNestedManyWithoutFairInput = {
    create?: XOR<Enumerable<fair_marketersCreateWithoutFairInput>, Enumerable<fair_marketersUncheckedCreateWithoutFairInput>>
    connectOrCreate?: Enumerable<fair_marketersCreateOrConnectWithoutFairInput>
    createMany?: fair_marketersCreateManyFairInputEnvelope
    connect?: Enumerable<fair_marketersWhereUniqueInput>
  }

  export type imageCreateNestedManyWithoutFairInput = {
    create?: XOR<Enumerable<imageCreateWithoutFairInput>, Enumerable<imageUncheckedCreateWithoutFairInput>>
    connectOrCreate?: Enumerable<imageCreateOrConnectWithoutFairInput>
    createMany?: imageCreateManyFairInputEnvelope
    connect?: Enumerable<imageWhereUniqueInput>
  }

  export type fair_date_hour_of_workUncheckedCreateNestedManyWithoutFairInput = {
    create?: XOR<Enumerable<fair_date_hour_of_workCreateWithoutFairInput>, Enumerable<fair_date_hour_of_workUncheckedCreateWithoutFairInput>>
    connectOrCreate?: Enumerable<fair_date_hour_of_workCreateOrConnectWithoutFairInput>
    createMany?: fair_date_hour_of_workCreateManyFairInputEnvelope
    connect?: Enumerable<fair_date_hour_of_workWhereUniqueInput>
  }

  export type fair_marketersUncheckedCreateNestedManyWithoutFairInput = {
    create?: XOR<Enumerable<fair_marketersCreateWithoutFairInput>, Enumerable<fair_marketersUncheckedCreateWithoutFairInput>>
    connectOrCreate?: Enumerable<fair_marketersCreateOrConnectWithoutFairInput>
    createMany?: fair_marketersCreateManyFairInputEnvelope
    connect?: Enumerable<fair_marketersWhereUniqueInput>
  }

  export type imageUncheckedCreateNestedManyWithoutFairInput = {
    create?: XOR<Enumerable<imageCreateWithoutFairInput>, Enumerable<imageUncheckedCreateWithoutFairInput>>
    connectOrCreate?: Enumerable<imageCreateOrConnectWithoutFairInput>
    createMany?: imageCreateManyFairInputEnvelope
    connect?: Enumerable<imageWhereUniqueInput>
  }

  export type addressUpdateOneRequiredWithoutFairNestedInput = {
    create?: XOR<addressCreateWithoutFairInput, addressUncheckedCreateWithoutFairInput>
    connectOrCreate?: addressCreateOrConnectWithoutFairInput
    upsert?: addressUpsertWithoutFairInput
    connect?: addressWhereUniqueInput
    update?: XOR<addressUpdateWithoutFairInput, addressUncheckedUpdateWithoutFairInput>
  }

  export type locationUpdateOneRequiredWithoutFairNestedInput = {
    create?: XOR<locationCreateWithoutFairInput, locationUncheckedCreateWithoutFairInput>
    connectOrCreate?: locationCreateOrConnectWithoutFairInput
    upsert?: locationUpsertWithoutFairInput
    connect?: locationWhereUniqueInput
    update?: XOR<locationUpdateWithoutFairInput, locationUncheckedUpdateWithoutFairInput>
  }

  export type fair_date_hour_of_workUpdateManyWithoutFairNestedInput = {
    create?: XOR<Enumerable<fair_date_hour_of_workCreateWithoutFairInput>, Enumerable<fair_date_hour_of_workUncheckedCreateWithoutFairInput>>
    connectOrCreate?: Enumerable<fair_date_hour_of_workCreateOrConnectWithoutFairInput>
    upsert?: Enumerable<fair_date_hour_of_workUpsertWithWhereUniqueWithoutFairInput>
    createMany?: fair_date_hour_of_workCreateManyFairInputEnvelope
    set?: Enumerable<fair_date_hour_of_workWhereUniqueInput>
    disconnect?: Enumerable<fair_date_hour_of_workWhereUniqueInput>
    delete?: Enumerable<fair_date_hour_of_workWhereUniqueInput>
    connect?: Enumerable<fair_date_hour_of_workWhereUniqueInput>
    update?: Enumerable<fair_date_hour_of_workUpdateWithWhereUniqueWithoutFairInput>
    updateMany?: Enumerable<fair_date_hour_of_workUpdateManyWithWhereWithoutFairInput>
    deleteMany?: Enumerable<fair_date_hour_of_workScalarWhereInput>
  }

  export type fair_marketersUpdateManyWithoutFairNestedInput = {
    create?: XOR<Enumerable<fair_marketersCreateWithoutFairInput>, Enumerable<fair_marketersUncheckedCreateWithoutFairInput>>
    connectOrCreate?: Enumerable<fair_marketersCreateOrConnectWithoutFairInput>
    upsert?: Enumerable<fair_marketersUpsertWithWhereUniqueWithoutFairInput>
    createMany?: fair_marketersCreateManyFairInputEnvelope
    set?: Enumerable<fair_marketersWhereUniqueInput>
    disconnect?: Enumerable<fair_marketersWhereUniqueInput>
    delete?: Enumerable<fair_marketersWhereUniqueInput>
    connect?: Enumerable<fair_marketersWhereUniqueInput>
    update?: Enumerable<fair_marketersUpdateWithWhereUniqueWithoutFairInput>
    updateMany?: Enumerable<fair_marketersUpdateManyWithWhereWithoutFairInput>
    deleteMany?: Enumerable<fair_marketersScalarWhereInput>
  }

  export type imageUpdateManyWithoutFairNestedInput = {
    create?: XOR<Enumerable<imageCreateWithoutFairInput>, Enumerable<imageUncheckedCreateWithoutFairInput>>
    connectOrCreate?: Enumerable<imageCreateOrConnectWithoutFairInput>
    upsert?: Enumerable<imageUpsertWithWhereUniqueWithoutFairInput>
    createMany?: imageCreateManyFairInputEnvelope
    set?: Enumerable<imageWhereUniqueInput>
    disconnect?: Enumerable<imageWhereUniqueInput>
    delete?: Enumerable<imageWhereUniqueInput>
    connect?: Enumerable<imageWhereUniqueInput>
    update?: Enumerable<imageUpdateWithWhereUniqueWithoutFairInput>
    updateMany?: Enumerable<imageUpdateManyWithWhereWithoutFairInput>
    deleteMany?: Enumerable<imageScalarWhereInput>
  }

  export type fair_date_hour_of_workUncheckedUpdateManyWithoutFairNestedInput = {
    create?: XOR<Enumerable<fair_date_hour_of_workCreateWithoutFairInput>, Enumerable<fair_date_hour_of_workUncheckedCreateWithoutFairInput>>
    connectOrCreate?: Enumerable<fair_date_hour_of_workCreateOrConnectWithoutFairInput>
    upsert?: Enumerable<fair_date_hour_of_workUpsertWithWhereUniqueWithoutFairInput>
    createMany?: fair_date_hour_of_workCreateManyFairInputEnvelope
    set?: Enumerable<fair_date_hour_of_workWhereUniqueInput>
    disconnect?: Enumerable<fair_date_hour_of_workWhereUniqueInput>
    delete?: Enumerable<fair_date_hour_of_workWhereUniqueInput>
    connect?: Enumerable<fair_date_hour_of_workWhereUniqueInput>
    update?: Enumerable<fair_date_hour_of_workUpdateWithWhereUniqueWithoutFairInput>
    updateMany?: Enumerable<fair_date_hour_of_workUpdateManyWithWhereWithoutFairInput>
    deleteMany?: Enumerable<fair_date_hour_of_workScalarWhereInput>
  }

  export type fair_marketersUncheckedUpdateManyWithoutFairNestedInput = {
    create?: XOR<Enumerable<fair_marketersCreateWithoutFairInput>, Enumerable<fair_marketersUncheckedCreateWithoutFairInput>>
    connectOrCreate?: Enumerable<fair_marketersCreateOrConnectWithoutFairInput>
    upsert?: Enumerable<fair_marketersUpsertWithWhereUniqueWithoutFairInput>
    createMany?: fair_marketersCreateManyFairInputEnvelope
    set?: Enumerable<fair_marketersWhereUniqueInput>
    disconnect?: Enumerable<fair_marketersWhereUniqueInput>
    delete?: Enumerable<fair_marketersWhereUniqueInput>
    connect?: Enumerable<fair_marketersWhereUniqueInput>
    update?: Enumerable<fair_marketersUpdateWithWhereUniqueWithoutFairInput>
    updateMany?: Enumerable<fair_marketersUpdateManyWithWhereWithoutFairInput>
    deleteMany?: Enumerable<fair_marketersScalarWhereInput>
  }

  export type imageUncheckedUpdateManyWithoutFairNestedInput = {
    create?: XOR<Enumerable<imageCreateWithoutFairInput>, Enumerable<imageUncheckedCreateWithoutFairInput>>
    connectOrCreate?: Enumerable<imageCreateOrConnectWithoutFairInput>
    upsert?: Enumerable<imageUpsertWithWhereUniqueWithoutFairInput>
    createMany?: imageCreateManyFairInputEnvelope
    set?: Enumerable<imageWhereUniqueInput>
    disconnect?: Enumerable<imageWhereUniqueInput>
    delete?: Enumerable<imageWhereUniqueInput>
    connect?: Enumerable<imageWhereUniqueInput>
    update?: Enumerable<imageUpdateWithWhereUniqueWithoutFairInput>
    updateMany?: Enumerable<imageUpdateManyWithWhereWithoutFairInput>
    deleteMany?: Enumerable<imageScalarWhereInput>
  }

  export type fairCreateNestedOneWithoutFair_marketersInput = {
    create?: XOR<fairCreateWithoutFair_marketersInput, fairUncheckedCreateWithoutFair_marketersInput>
    connectOrCreate?: fairCreateOrConnectWithoutFair_marketersInput
    connect?: fairWhereUniqueInput
  }

  export type marketerCreateNestedOneWithoutFair_marketersInput = {
    create?: XOR<marketerCreateWithoutFair_marketersInput, marketerUncheckedCreateWithoutFair_marketersInput>
    connectOrCreate?: marketerCreateOrConnectWithoutFair_marketersInput
    connect?: marketerWhereUniqueInput
  }

  export type fairUpdateOneRequiredWithoutFair_marketersNestedInput = {
    create?: XOR<fairCreateWithoutFair_marketersInput, fairUncheckedCreateWithoutFair_marketersInput>
    connectOrCreate?: fairCreateOrConnectWithoutFair_marketersInput
    upsert?: fairUpsertWithoutFair_marketersInput
    connect?: fairWhereUniqueInput
    update?: XOR<fairUpdateWithoutFair_marketersInput, fairUncheckedUpdateWithoutFair_marketersInput>
  }

  export type marketerUpdateOneRequiredWithoutFair_marketersNestedInput = {
    create?: XOR<marketerCreateWithoutFair_marketersInput, marketerUncheckedCreateWithoutFair_marketersInput>
    connectOrCreate?: marketerCreateOrConnectWithoutFair_marketersInput
    upsert?: marketerUpsertWithoutFair_marketersInput
    connect?: marketerWhereUniqueInput
    update?: XOR<marketerUpdateWithoutFair_marketersInput, marketerUncheckedUpdateWithoutFair_marketersInput>
  }

  export type addressCreateNestedOneWithoutCostumer_addressesInput = {
    create?: XOR<addressCreateWithoutCostumer_addressesInput, addressUncheckedCreateWithoutCostumer_addressesInput>
    connectOrCreate?: addressCreateOrConnectWithoutCostumer_addressesInput
    connect?: addressWhereUniqueInput
  }

  export type costumerCreateNestedOneWithoutCostumer_addressesInput = {
    create?: XOR<costumerCreateWithoutCostumer_addressesInput, costumerUncheckedCreateWithoutCostumer_addressesInput>
    connectOrCreate?: costumerCreateOrConnectWithoutCostumer_addressesInput
    connect?: costumerWhereUniqueInput
  }

  export type orderCreateNestedManyWithoutCostumer_addressesInput = {
    create?: XOR<Enumerable<orderCreateWithoutCostumer_addressesInput>, Enumerable<orderUncheckedCreateWithoutCostumer_addressesInput>>
    connectOrCreate?: Enumerable<orderCreateOrConnectWithoutCostumer_addressesInput>
    createMany?: orderCreateManyCostumer_addressesInputEnvelope
    connect?: Enumerable<orderWhereUniqueInput>
  }

  export type orderUncheckedCreateNestedManyWithoutCostumer_addressesInput = {
    create?: XOR<Enumerable<orderCreateWithoutCostumer_addressesInput>, Enumerable<orderUncheckedCreateWithoutCostumer_addressesInput>>
    connectOrCreate?: Enumerable<orderCreateOrConnectWithoutCostumer_addressesInput>
    createMany?: orderCreateManyCostumer_addressesInputEnvelope
    connect?: Enumerable<orderWhereUniqueInput>
  }

  export type addressUpdateOneRequiredWithoutCostumer_addressesNestedInput = {
    create?: XOR<addressCreateWithoutCostumer_addressesInput, addressUncheckedCreateWithoutCostumer_addressesInput>
    connectOrCreate?: addressCreateOrConnectWithoutCostumer_addressesInput
    upsert?: addressUpsertWithoutCostumer_addressesInput
    connect?: addressWhereUniqueInput
    update?: XOR<addressUpdateWithoutCostumer_addressesInput, addressUncheckedUpdateWithoutCostumer_addressesInput>
  }

  export type costumerUpdateOneRequiredWithoutCostumer_addressesNestedInput = {
    create?: XOR<costumerCreateWithoutCostumer_addressesInput, costumerUncheckedCreateWithoutCostumer_addressesInput>
    connectOrCreate?: costumerCreateOrConnectWithoutCostumer_addressesInput
    upsert?: costumerUpsertWithoutCostumer_addressesInput
    connect?: costumerWhereUniqueInput
    update?: XOR<costumerUpdateWithoutCostumer_addressesInput, costumerUncheckedUpdateWithoutCostumer_addressesInput>
  }

  export type orderUpdateManyWithoutCostumer_addressesNestedInput = {
    create?: XOR<Enumerable<orderCreateWithoutCostumer_addressesInput>, Enumerable<orderUncheckedCreateWithoutCostumer_addressesInput>>
    connectOrCreate?: Enumerable<orderCreateOrConnectWithoutCostumer_addressesInput>
    upsert?: Enumerable<orderUpsertWithWhereUniqueWithoutCostumer_addressesInput>
    createMany?: orderCreateManyCostumer_addressesInputEnvelope
    set?: Enumerable<orderWhereUniqueInput>
    disconnect?: Enumerable<orderWhereUniqueInput>
    delete?: Enumerable<orderWhereUniqueInput>
    connect?: Enumerable<orderWhereUniqueInput>
    update?: Enumerable<orderUpdateWithWhereUniqueWithoutCostumer_addressesInput>
    updateMany?: Enumerable<orderUpdateManyWithWhereWithoutCostumer_addressesInput>
    deleteMany?: Enumerable<orderScalarWhereInput>
  }

  export type orderUncheckedUpdateManyWithoutCostumer_addressesNestedInput = {
    create?: XOR<Enumerable<orderCreateWithoutCostumer_addressesInput>, Enumerable<orderUncheckedCreateWithoutCostumer_addressesInput>>
    connectOrCreate?: Enumerable<orderCreateOrConnectWithoutCostumer_addressesInput>
    upsert?: Enumerable<orderUpsertWithWhereUniqueWithoutCostumer_addressesInput>
    createMany?: orderCreateManyCostumer_addressesInputEnvelope
    set?: Enumerable<orderWhereUniqueInput>
    disconnect?: Enumerable<orderWhereUniqueInput>
    delete?: Enumerable<orderWhereUniqueInput>
    connect?: Enumerable<orderWhereUniqueInput>
    update?: Enumerable<orderUpdateWithWhereUniqueWithoutCostumer_addressesInput>
    updateMany?: Enumerable<orderUpdateManyWithWhereWithoutCostumer_addressesInput>
    deleteMany?: Enumerable<orderScalarWhereInput>
  }

  export type addressCreateNestedManyWithoutLocationInput = {
    create?: XOR<Enumerable<addressCreateWithoutLocationInput>, Enumerable<addressUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<addressCreateOrConnectWithoutLocationInput>
    createMany?: addressCreateManyLocationInputEnvelope
    connect?: Enumerable<addressWhereUniqueInput>
  }

  export type deliverymanCreateNestedOneWithoutLocationInput = {
    create?: XOR<deliverymanCreateWithoutLocationInput, deliverymanUncheckedCreateWithoutLocationInput>
    connectOrCreate?: deliverymanCreateOrConnectWithoutLocationInput
    connect?: deliverymanWhereUniqueInput
  }

  export type fairCreateNestedManyWithoutLocationInput = {
    create?: XOR<Enumerable<fairCreateWithoutLocationInput>, Enumerable<fairUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<fairCreateOrConnectWithoutLocationInput>
    createMany?: fairCreateManyLocationInputEnvelope
    connect?: Enumerable<fairWhereUniqueInput>
  }

  export type marketerCreateNestedOneWithoutLocationInput = {
    create?: XOR<marketerCreateWithoutLocationInput, marketerUncheckedCreateWithoutLocationInput>
    connectOrCreate?: marketerCreateOrConnectWithoutLocationInput
    connect?: marketerWhereUniqueInput
  }

  export type addressUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<Enumerable<addressCreateWithoutLocationInput>, Enumerable<addressUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<addressCreateOrConnectWithoutLocationInput>
    createMany?: addressCreateManyLocationInputEnvelope
    connect?: Enumerable<addressWhereUniqueInput>
  }

  export type deliverymanUncheckedCreateNestedOneWithoutLocationInput = {
    create?: XOR<deliverymanCreateWithoutLocationInput, deliverymanUncheckedCreateWithoutLocationInput>
    connectOrCreate?: deliverymanCreateOrConnectWithoutLocationInput
    connect?: deliverymanWhereUniqueInput
  }

  export type fairUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<Enumerable<fairCreateWithoutLocationInput>, Enumerable<fairUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<fairCreateOrConnectWithoutLocationInput>
    createMany?: fairCreateManyLocationInputEnvelope
    connect?: Enumerable<fairWhereUniqueInput>
  }

  export type marketerUncheckedCreateNestedOneWithoutLocationInput = {
    create?: XOR<marketerCreateWithoutLocationInput, marketerUncheckedCreateWithoutLocationInput>
    connectOrCreate?: marketerCreateOrConnectWithoutLocationInput
    connect?: marketerWhereUniqueInput
  }

  export type addressUpdateManyWithoutLocationNestedInput = {
    create?: XOR<Enumerable<addressCreateWithoutLocationInput>, Enumerable<addressUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<addressCreateOrConnectWithoutLocationInput>
    upsert?: Enumerable<addressUpsertWithWhereUniqueWithoutLocationInput>
    createMany?: addressCreateManyLocationInputEnvelope
    set?: Enumerable<addressWhereUniqueInput>
    disconnect?: Enumerable<addressWhereUniqueInput>
    delete?: Enumerable<addressWhereUniqueInput>
    connect?: Enumerable<addressWhereUniqueInput>
    update?: Enumerable<addressUpdateWithWhereUniqueWithoutLocationInput>
    updateMany?: Enumerable<addressUpdateManyWithWhereWithoutLocationInput>
    deleteMany?: Enumerable<addressScalarWhereInput>
  }

  export type deliverymanUpdateOneWithoutLocationNestedInput = {
    create?: XOR<deliverymanCreateWithoutLocationInput, deliverymanUncheckedCreateWithoutLocationInput>
    connectOrCreate?: deliverymanCreateOrConnectWithoutLocationInput
    upsert?: deliverymanUpsertWithoutLocationInput
    disconnect?: boolean
    delete?: boolean
    connect?: deliverymanWhereUniqueInput
    update?: XOR<deliverymanUpdateWithoutLocationInput, deliverymanUncheckedUpdateWithoutLocationInput>
  }

  export type fairUpdateManyWithoutLocationNestedInput = {
    create?: XOR<Enumerable<fairCreateWithoutLocationInput>, Enumerable<fairUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<fairCreateOrConnectWithoutLocationInput>
    upsert?: Enumerable<fairUpsertWithWhereUniqueWithoutLocationInput>
    createMany?: fairCreateManyLocationInputEnvelope
    set?: Enumerable<fairWhereUniqueInput>
    disconnect?: Enumerable<fairWhereUniqueInput>
    delete?: Enumerable<fairWhereUniqueInput>
    connect?: Enumerable<fairWhereUniqueInput>
    update?: Enumerable<fairUpdateWithWhereUniqueWithoutLocationInput>
    updateMany?: Enumerable<fairUpdateManyWithWhereWithoutLocationInput>
    deleteMany?: Enumerable<fairScalarWhereInput>
  }

  export type marketerUpdateOneWithoutLocationNestedInput = {
    create?: XOR<marketerCreateWithoutLocationInput, marketerUncheckedCreateWithoutLocationInput>
    connectOrCreate?: marketerCreateOrConnectWithoutLocationInput
    upsert?: marketerUpsertWithoutLocationInput
    disconnect?: boolean
    delete?: boolean
    connect?: marketerWhereUniqueInput
    update?: XOR<marketerUpdateWithoutLocationInput, marketerUncheckedUpdateWithoutLocationInput>
  }

  export type addressUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<Enumerable<addressCreateWithoutLocationInput>, Enumerable<addressUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<addressCreateOrConnectWithoutLocationInput>
    upsert?: Enumerable<addressUpsertWithWhereUniqueWithoutLocationInput>
    createMany?: addressCreateManyLocationInputEnvelope
    set?: Enumerable<addressWhereUniqueInput>
    disconnect?: Enumerable<addressWhereUniqueInput>
    delete?: Enumerable<addressWhereUniqueInput>
    connect?: Enumerable<addressWhereUniqueInput>
    update?: Enumerable<addressUpdateWithWhereUniqueWithoutLocationInput>
    updateMany?: Enumerable<addressUpdateManyWithWhereWithoutLocationInput>
    deleteMany?: Enumerable<addressScalarWhereInput>
  }

  export type deliverymanUncheckedUpdateOneWithoutLocationNestedInput = {
    create?: XOR<deliverymanCreateWithoutLocationInput, deliverymanUncheckedCreateWithoutLocationInput>
    connectOrCreate?: deliverymanCreateOrConnectWithoutLocationInput
    upsert?: deliverymanUpsertWithoutLocationInput
    disconnect?: boolean
    delete?: boolean
    connect?: deliverymanWhereUniqueInput
    update?: XOR<deliverymanUpdateWithoutLocationInput, deliverymanUncheckedUpdateWithoutLocationInput>
  }

  export type fairUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<Enumerable<fairCreateWithoutLocationInput>, Enumerable<fairUncheckedCreateWithoutLocationInput>>
    connectOrCreate?: Enumerable<fairCreateOrConnectWithoutLocationInput>
    upsert?: Enumerable<fairUpsertWithWhereUniqueWithoutLocationInput>
    createMany?: fairCreateManyLocationInputEnvelope
    set?: Enumerable<fairWhereUniqueInput>
    disconnect?: Enumerable<fairWhereUniqueInput>
    delete?: Enumerable<fairWhereUniqueInput>
    connect?: Enumerable<fairWhereUniqueInput>
    update?: Enumerable<fairUpdateWithWhereUniqueWithoutLocationInput>
    updateMany?: Enumerable<fairUpdateManyWithWhereWithoutLocationInput>
    deleteMany?: Enumerable<fairScalarWhereInput>
  }

  export type marketerUncheckedUpdateOneWithoutLocationNestedInput = {
    create?: XOR<marketerCreateWithoutLocationInput, marketerUncheckedCreateWithoutLocationInput>
    connectOrCreate?: marketerCreateOrConnectWithoutLocationInput
    upsert?: marketerUpsertWithoutLocationInput
    disconnect?: boolean
    delete?: boolean
    connect?: marketerWhereUniqueInput
    update?: XOR<marketerUpdateWithoutLocationInput, marketerUncheckedUpdateWithoutLocationInput>
  }

  export type address_typeCreateNestedOneWithoutAddressInput = {
    create?: XOR<address_typeCreateWithoutAddressInput, address_typeUncheckedCreateWithoutAddressInput>
    connectOrCreate?: address_typeCreateOrConnectWithoutAddressInput
    connect?: address_typeWhereUniqueInput
  }

  export type cityCreateNestedOneWithoutAddressInput = {
    create?: XOR<cityCreateWithoutAddressInput, cityUncheckedCreateWithoutAddressInput>
    connectOrCreate?: cityCreateOrConnectWithoutAddressInput
    connect?: cityWhereUniqueInput
  }

  export type locationCreateNestedOneWithoutAddressInput = {
    create?: XOR<locationCreateWithoutAddressInput, locationUncheckedCreateWithoutAddressInput>
    connectOrCreate?: locationCreateOrConnectWithoutAddressInput
    connect?: locationWhereUniqueInput
  }

  export type neighborhoodCreateNestedOneWithoutAddressInput = {
    create?: XOR<neighborhoodCreateWithoutAddressInput, neighborhoodUncheckedCreateWithoutAddressInput>
    connectOrCreate?: neighborhoodCreateOrConnectWithoutAddressInput
    connect?: neighborhoodWhereUniqueInput
  }

  export type ufCreateNestedOneWithoutAddressInput = {
    create?: XOR<ufCreateWithoutAddressInput, ufUncheckedCreateWithoutAddressInput>
    connectOrCreate?: ufCreateOrConnectWithoutAddressInput
    connect?: ufWhereUniqueInput
  }

  export type costumer_addressesCreateNestedManyWithoutAddressInput = {
    create?: XOR<Enumerable<costumer_addressesCreateWithoutAddressInput>, Enumerable<costumer_addressesUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<costumer_addressesCreateOrConnectWithoutAddressInput>
    createMany?: costumer_addressesCreateManyAddressInputEnvelope
    connect?: Enumerable<costumer_addressesWhereUniqueInput>
  }

  export type fairCreateNestedOneWithoutAddressInput = {
    create?: XOR<fairCreateWithoutAddressInput, fairUncheckedCreateWithoutAddressInput>
    connectOrCreate?: fairCreateOrConnectWithoutAddressInput
    connect?: fairWhereUniqueInput
  }

  export type costumer_addressesUncheckedCreateNestedManyWithoutAddressInput = {
    create?: XOR<Enumerable<costumer_addressesCreateWithoutAddressInput>, Enumerable<costumer_addressesUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<costumer_addressesCreateOrConnectWithoutAddressInput>
    createMany?: costumer_addressesCreateManyAddressInputEnvelope
    connect?: Enumerable<costumer_addressesWhereUniqueInput>
  }

  export type fairUncheckedCreateNestedOneWithoutAddressInput = {
    create?: XOR<fairCreateWithoutAddressInput, fairUncheckedCreateWithoutAddressInput>
    connectOrCreate?: fairCreateOrConnectWithoutAddressInput
    connect?: fairWhereUniqueInput
  }

  export type address_typeUpdateOneRequiredWithoutAddressNestedInput = {
    create?: XOR<address_typeCreateWithoutAddressInput, address_typeUncheckedCreateWithoutAddressInput>
    connectOrCreate?: address_typeCreateOrConnectWithoutAddressInput
    upsert?: address_typeUpsertWithoutAddressInput
    connect?: address_typeWhereUniqueInput
    update?: XOR<address_typeUpdateWithoutAddressInput, address_typeUncheckedUpdateWithoutAddressInput>
  }

  export type cityUpdateOneRequiredWithoutAddressNestedInput = {
    create?: XOR<cityCreateWithoutAddressInput, cityUncheckedCreateWithoutAddressInput>
    connectOrCreate?: cityCreateOrConnectWithoutAddressInput
    upsert?: cityUpsertWithoutAddressInput
    connect?: cityWhereUniqueInput
    update?: XOR<cityUpdateWithoutAddressInput, cityUncheckedUpdateWithoutAddressInput>
  }

  export type locationUpdateOneRequiredWithoutAddressNestedInput = {
    create?: XOR<locationCreateWithoutAddressInput, locationUncheckedCreateWithoutAddressInput>
    connectOrCreate?: locationCreateOrConnectWithoutAddressInput
    upsert?: locationUpsertWithoutAddressInput
    connect?: locationWhereUniqueInput
    update?: XOR<locationUpdateWithoutAddressInput, locationUncheckedUpdateWithoutAddressInput>
  }

  export type neighborhoodUpdateOneRequiredWithoutAddressNestedInput = {
    create?: XOR<neighborhoodCreateWithoutAddressInput, neighborhoodUncheckedCreateWithoutAddressInput>
    connectOrCreate?: neighborhoodCreateOrConnectWithoutAddressInput
    upsert?: neighborhoodUpsertWithoutAddressInput
    connect?: neighborhoodWhereUniqueInput
    update?: XOR<neighborhoodUpdateWithoutAddressInput, neighborhoodUncheckedUpdateWithoutAddressInput>
  }

  export type ufUpdateOneRequiredWithoutAddressNestedInput = {
    create?: XOR<ufCreateWithoutAddressInput, ufUncheckedCreateWithoutAddressInput>
    connectOrCreate?: ufCreateOrConnectWithoutAddressInput
    upsert?: ufUpsertWithoutAddressInput
    connect?: ufWhereUniqueInput
    update?: XOR<ufUpdateWithoutAddressInput, ufUncheckedUpdateWithoutAddressInput>
  }

  export type costumer_addressesUpdateManyWithoutAddressNestedInput = {
    create?: XOR<Enumerable<costumer_addressesCreateWithoutAddressInput>, Enumerable<costumer_addressesUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<costumer_addressesCreateOrConnectWithoutAddressInput>
    upsert?: Enumerable<costumer_addressesUpsertWithWhereUniqueWithoutAddressInput>
    createMany?: costumer_addressesCreateManyAddressInputEnvelope
    set?: Enumerable<costumer_addressesWhereUniqueInput>
    disconnect?: Enumerable<costumer_addressesWhereUniqueInput>
    delete?: Enumerable<costumer_addressesWhereUniqueInput>
    connect?: Enumerable<costumer_addressesWhereUniqueInput>
    update?: Enumerable<costumer_addressesUpdateWithWhereUniqueWithoutAddressInput>
    updateMany?: Enumerable<costumer_addressesUpdateManyWithWhereWithoutAddressInput>
    deleteMany?: Enumerable<costumer_addressesScalarWhereInput>
  }

  export type fairUpdateOneWithoutAddressNestedInput = {
    create?: XOR<fairCreateWithoutAddressInput, fairUncheckedCreateWithoutAddressInput>
    connectOrCreate?: fairCreateOrConnectWithoutAddressInput
    upsert?: fairUpsertWithoutAddressInput
    disconnect?: boolean
    delete?: boolean
    connect?: fairWhereUniqueInput
    update?: XOR<fairUpdateWithoutAddressInput, fairUncheckedUpdateWithoutAddressInput>
  }

  export type costumer_addressesUncheckedUpdateManyWithoutAddressNestedInput = {
    create?: XOR<Enumerable<costumer_addressesCreateWithoutAddressInput>, Enumerable<costumer_addressesUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<costumer_addressesCreateOrConnectWithoutAddressInput>
    upsert?: Enumerable<costumer_addressesUpsertWithWhereUniqueWithoutAddressInput>
    createMany?: costumer_addressesCreateManyAddressInputEnvelope
    set?: Enumerable<costumer_addressesWhereUniqueInput>
    disconnect?: Enumerable<costumer_addressesWhereUniqueInput>
    delete?: Enumerable<costumer_addressesWhereUniqueInput>
    connect?: Enumerable<costumer_addressesWhereUniqueInput>
    update?: Enumerable<costumer_addressesUpdateWithWhereUniqueWithoutAddressInput>
    updateMany?: Enumerable<costumer_addressesUpdateManyWithWhereWithoutAddressInput>
    deleteMany?: Enumerable<costumer_addressesScalarWhereInput>
  }

  export type fairUncheckedUpdateOneWithoutAddressNestedInput = {
    create?: XOR<fairCreateWithoutAddressInput, fairUncheckedCreateWithoutAddressInput>
    connectOrCreate?: fairCreateOrConnectWithoutAddressInput
    upsert?: fairUpsertWithoutAddressInput
    disconnect?: boolean
    delete?: boolean
    connect?: fairWhereUniqueInput
    update?: XOR<fairUpdateWithoutAddressInput, fairUncheckedUpdateWithoutAddressInput>
  }

  export type addressCreateNestedManyWithoutTypeInput = {
    create?: XOR<Enumerable<addressCreateWithoutTypeInput>, Enumerable<addressUncheckedCreateWithoutTypeInput>>
    connectOrCreate?: Enumerable<addressCreateOrConnectWithoutTypeInput>
    createMany?: addressCreateManyTypeInputEnvelope
    connect?: Enumerable<addressWhereUniqueInput>
  }

  export type addressUncheckedCreateNestedManyWithoutTypeInput = {
    create?: XOR<Enumerable<addressCreateWithoutTypeInput>, Enumerable<addressUncheckedCreateWithoutTypeInput>>
    connectOrCreate?: Enumerable<addressCreateOrConnectWithoutTypeInput>
    createMany?: addressCreateManyTypeInputEnvelope
    connect?: Enumerable<addressWhereUniqueInput>
  }

  export type addressUpdateManyWithoutTypeNestedInput = {
    create?: XOR<Enumerable<addressCreateWithoutTypeInput>, Enumerable<addressUncheckedCreateWithoutTypeInput>>
    connectOrCreate?: Enumerable<addressCreateOrConnectWithoutTypeInput>
    upsert?: Enumerable<addressUpsertWithWhereUniqueWithoutTypeInput>
    createMany?: addressCreateManyTypeInputEnvelope
    set?: Enumerable<addressWhereUniqueInput>
    disconnect?: Enumerable<addressWhereUniqueInput>
    delete?: Enumerable<addressWhereUniqueInput>
    connect?: Enumerable<addressWhereUniqueInput>
    update?: Enumerable<addressUpdateWithWhereUniqueWithoutTypeInput>
    updateMany?: Enumerable<addressUpdateManyWithWhereWithoutTypeInput>
    deleteMany?: Enumerable<addressScalarWhereInput>
  }

  export type addressUncheckedUpdateManyWithoutTypeNestedInput = {
    create?: XOR<Enumerable<addressCreateWithoutTypeInput>, Enumerable<addressUncheckedCreateWithoutTypeInput>>
    connectOrCreate?: Enumerable<addressCreateOrConnectWithoutTypeInput>
    upsert?: Enumerable<addressUpsertWithWhereUniqueWithoutTypeInput>
    createMany?: addressCreateManyTypeInputEnvelope
    set?: Enumerable<addressWhereUniqueInput>
    disconnect?: Enumerable<addressWhereUniqueInput>
    delete?: Enumerable<addressWhereUniqueInput>
    connect?: Enumerable<addressWhereUniqueInput>
    update?: Enumerable<addressUpdateWithWhereUniqueWithoutTypeInput>
    updateMany?: Enumerable<addressUpdateManyWithWhereWithoutTypeInput>
    deleteMany?: Enumerable<addressScalarWhereInput>
  }

  export type veicule_deliverymanCreateNestedManyWithoutVeiculeInput = {
    create?: XOR<Enumerable<veicule_deliverymanCreateWithoutVeiculeInput>, Enumerable<veicule_deliverymanUncheckedCreateWithoutVeiculeInput>>
    connectOrCreate?: Enumerable<veicule_deliverymanCreateOrConnectWithoutVeiculeInput>
    createMany?: veicule_deliverymanCreateManyVeiculeInputEnvelope
    connect?: Enumerable<veicule_deliverymanWhereUniqueInput>
  }

  export type veicule_deliverymanUncheckedCreateNestedManyWithoutVeiculeInput = {
    create?: XOR<Enumerable<veicule_deliverymanCreateWithoutVeiculeInput>, Enumerable<veicule_deliverymanUncheckedCreateWithoutVeiculeInput>>
    connectOrCreate?: Enumerable<veicule_deliverymanCreateOrConnectWithoutVeiculeInput>
    createMany?: veicule_deliverymanCreateManyVeiculeInputEnvelope
    connect?: Enumerable<veicule_deliverymanWhereUniqueInput>
  }

  export type veicule_deliverymanUpdateManyWithoutVeiculeNestedInput = {
    create?: XOR<Enumerable<veicule_deliverymanCreateWithoutVeiculeInput>, Enumerable<veicule_deliverymanUncheckedCreateWithoutVeiculeInput>>
    connectOrCreate?: Enumerable<veicule_deliverymanCreateOrConnectWithoutVeiculeInput>
    upsert?: Enumerable<veicule_deliverymanUpsertWithWhereUniqueWithoutVeiculeInput>
    createMany?: veicule_deliverymanCreateManyVeiculeInputEnvelope
    set?: Enumerable<veicule_deliverymanWhereUniqueInput>
    disconnect?: Enumerable<veicule_deliverymanWhereUniqueInput>
    delete?: Enumerable<veicule_deliverymanWhereUniqueInput>
    connect?: Enumerable<veicule_deliverymanWhereUniqueInput>
    update?: Enumerable<veicule_deliverymanUpdateWithWhereUniqueWithoutVeiculeInput>
    updateMany?: Enumerable<veicule_deliverymanUpdateManyWithWhereWithoutVeiculeInput>
    deleteMany?: Enumerable<veicule_deliverymanScalarWhereInput>
  }

  export type veicule_deliverymanUncheckedUpdateManyWithoutVeiculeNestedInput = {
    create?: XOR<Enumerable<veicule_deliverymanCreateWithoutVeiculeInput>, Enumerable<veicule_deliverymanUncheckedCreateWithoutVeiculeInput>>
    connectOrCreate?: Enumerable<veicule_deliverymanCreateOrConnectWithoutVeiculeInput>
    upsert?: Enumerable<veicule_deliverymanUpsertWithWhereUniqueWithoutVeiculeInput>
    createMany?: veicule_deliverymanCreateManyVeiculeInputEnvelope
    set?: Enumerable<veicule_deliverymanWhereUniqueInput>
    disconnect?: Enumerable<veicule_deliverymanWhereUniqueInput>
    delete?: Enumerable<veicule_deliverymanWhereUniqueInput>
    connect?: Enumerable<veicule_deliverymanWhereUniqueInput>
    update?: Enumerable<veicule_deliverymanUpdateWithWhereUniqueWithoutVeiculeInput>
    updateMany?: Enumerable<veicule_deliverymanUpdateManyWithWhereWithoutVeiculeInput>
    deleteMany?: Enumerable<veicule_deliverymanScalarWhereInput>
  }

  export type imageCreateNestedOneWithoutImage_of_productInput = {
    create?: XOR<imageCreateWithoutImage_of_productInput, imageUncheckedCreateWithoutImage_of_productInput>
    connectOrCreate?: imageCreateOrConnectWithoutImage_of_productInput
    connect?: imageWhereUniqueInput
  }

  export type productCreateNestedOneWithoutImage_of_productInput = {
    create?: XOR<productCreateWithoutImage_of_productInput, productUncheckedCreateWithoutImage_of_productInput>
    connectOrCreate?: productCreateOrConnectWithoutImage_of_productInput
    connect?: productWhereUniqueInput
  }

  export type imageUpdateOneRequiredWithoutImage_of_productNestedInput = {
    create?: XOR<imageCreateWithoutImage_of_productInput, imageUncheckedCreateWithoutImage_of_productInput>
    connectOrCreate?: imageCreateOrConnectWithoutImage_of_productInput
    upsert?: imageUpsertWithoutImage_of_productInput
    connect?: imageWhereUniqueInput
    update?: XOR<imageUpdateWithoutImage_of_productInput, imageUncheckedUpdateWithoutImage_of_productInput>
  }

  export type productUpdateOneRequiredWithoutImage_of_productNestedInput = {
    create?: XOR<productCreateWithoutImage_of_productInput, productUncheckedCreateWithoutImage_of_productInput>
    connectOrCreate?: productCreateOrConnectWithoutImage_of_productInput
    upsert?: productUpsertWithoutImage_of_productInput
    connect?: productWhereUniqueInput
    update?: XOR<productUpdateWithoutImage_of_productInput, productUncheckedUpdateWithoutImage_of_productInput>
  }

  export type category_of_productCreateNestedManyWithoutImageInput = {
    create?: XOR<Enumerable<category_of_productCreateWithoutImageInput>, Enumerable<category_of_productUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<category_of_productCreateOrConnectWithoutImageInput>
    createMany?: category_of_productCreateManyImageInputEnvelope
    connect?: Enumerable<category_of_productWhereUniqueInput>
  }

  export type fairCreateNestedOneWithoutImageInput = {
    create?: XOR<fairCreateWithoutImageInput, fairUncheckedCreateWithoutImageInput>
    connectOrCreate?: fairCreateOrConnectWithoutImageInput
    connect?: fairWhereUniqueInput
  }

  export type image_of_productCreateNestedManyWithoutImageInput = {
    create?: XOR<Enumerable<image_of_productCreateWithoutImageInput>, Enumerable<image_of_productUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<image_of_productCreateOrConnectWithoutImageInput>
    createMany?: image_of_productCreateManyImageInputEnvelope
    connect?: Enumerable<image_of_productWhereUniqueInput>
  }

  export type category_of_productUncheckedCreateNestedManyWithoutImageInput = {
    create?: XOR<Enumerable<category_of_productCreateWithoutImageInput>, Enumerable<category_of_productUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<category_of_productCreateOrConnectWithoutImageInput>
    createMany?: category_of_productCreateManyImageInputEnvelope
    connect?: Enumerable<category_of_productWhereUniqueInput>
  }

  export type image_of_productUncheckedCreateNestedManyWithoutImageInput = {
    create?: XOR<Enumerable<image_of_productCreateWithoutImageInput>, Enumerable<image_of_productUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<image_of_productCreateOrConnectWithoutImageInput>
    createMany?: image_of_productCreateManyImageInputEnvelope
    connect?: Enumerable<image_of_productWhereUniqueInput>
  }

  export type category_of_productUpdateManyWithoutImageNestedInput = {
    create?: XOR<Enumerable<category_of_productCreateWithoutImageInput>, Enumerable<category_of_productUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<category_of_productCreateOrConnectWithoutImageInput>
    upsert?: Enumerable<category_of_productUpsertWithWhereUniqueWithoutImageInput>
    createMany?: category_of_productCreateManyImageInputEnvelope
    set?: Enumerable<category_of_productWhereUniqueInput>
    disconnect?: Enumerable<category_of_productWhereUniqueInput>
    delete?: Enumerable<category_of_productWhereUniqueInput>
    connect?: Enumerable<category_of_productWhereUniqueInput>
    update?: Enumerable<category_of_productUpdateWithWhereUniqueWithoutImageInput>
    updateMany?: Enumerable<category_of_productUpdateManyWithWhereWithoutImageInput>
    deleteMany?: Enumerable<category_of_productScalarWhereInput>
  }

  export type fairUpdateOneWithoutImageNestedInput = {
    create?: XOR<fairCreateWithoutImageInput, fairUncheckedCreateWithoutImageInput>
    connectOrCreate?: fairCreateOrConnectWithoutImageInput
    upsert?: fairUpsertWithoutImageInput
    disconnect?: boolean
    delete?: boolean
    connect?: fairWhereUniqueInput
    update?: XOR<fairUpdateWithoutImageInput, fairUncheckedUpdateWithoutImageInput>
  }

  export type image_of_productUpdateManyWithoutImageNestedInput = {
    create?: XOR<Enumerable<image_of_productCreateWithoutImageInput>, Enumerable<image_of_productUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<image_of_productCreateOrConnectWithoutImageInput>
    upsert?: Enumerable<image_of_productUpsertWithWhereUniqueWithoutImageInput>
    createMany?: image_of_productCreateManyImageInputEnvelope
    set?: Enumerable<image_of_productWhereUniqueInput>
    disconnect?: Enumerable<image_of_productWhereUniqueInput>
    delete?: Enumerable<image_of_productWhereUniqueInput>
    connect?: Enumerable<image_of_productWhereUniqueInput>
    update?: Enumerable<image_of_productUpdateWithWhereUniqueWithoutImageInput>
    updateMany?: Enumerable<image_of_productUpdateManyWithWhereWithoutImageInput>
    deleteMany?: Enumerable<image_of_productScalarWhereInput>
  }

  export type category_of_productUncheckedUpdateManyWithoutImageNestedInput = {
    create?: XOR<Enumerable<category_of_productCreateWithoutImageInput>, Enumerable<category_of_productUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<category_of_productCreateOrConnectWithoutImageInput>
    upsert?: Enumerable<category_of_productUpsertWithWhereUniqueWithoutImageInput>
    createMany?: category_of_productCreateManyImageInputEnvelope
    set?: Enumerable<category_of_productWhereUniqueInput>
    disconnect?: Enumerable<category_of_productWhereUniqueInput>
    delete?: Enumerable<category_of_productWhereUniqueInput>
    connect?: Enumerable<category_of_productWhereUniqueInput>
    update?: Enumerable<category_of_productUpdateWithWhereUniqueWithoutImageInput>
    updateMany?: Enumerable<category_of_productUpdateManyWithWhereWithoutImageInput>
    deleteMany?: Enumerable<category_of_productScalarWhereInput>
  }

  export type image_of_productUncheckedUpdateManyWithoutImageNestedInput = {
    create?: XOR<Enumerable<image_of_productCreateWithoutImageInput>, Enumerable<image_of_productUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<image_of_productCreateOrConnectWithoutImageInput>
    upsert?: Enumerable<image_of_productUpsertWithWhereUniqueWithoutImageInput>
    createMany?: image_of_productCreateManyImageInputEnvelope
    set?: Enumerable<image_of_productWhereUniqueInput>
    disconnect?: Enumerable<image_of_productWhereUniqueInput>
    delete?: Enumerable<image_of_productWhereUniqueInput>
    connect?: Enumerable<image_of_productWhereUniqueInput>
    update?: Enumerable<image_of_productUpdateWithWhereUniqueWithoutImageInput>
    updateMany?: Enumerable<image_of_productUpdateManyWithWhereWithoutImageInput>
    deleteMany?: Enumerable<image_of_productScalarWhereInput>
  }

  export type paymentCreateNestedManyWithoutPayment_methodInput = {
    create?: XOR<Enumerable<paymentCreateWithoutPayment_methodInput>, Enumerable<paymentUncheckedCreateWithoutPayment_methodInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutPayment_methodInput>
    createMany?: paymentCreateManyPayment_methodInputEnvelope
    connect?: Enumerable<paymentWhereUniqueInput>
  }

  export type paymentUncheckedCreateNestedManyWithoutPayment_methodInput = {
    create?: XOR<Enumerable<paymentCreateWithoutPayment_methodInput>, Enumerable<paymentUncheckedCreateWithoutPayment_methodInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutPayment_methodInput>
    createMany?: paymentCreateManyPayment_methodInputEnvelope
    connect?: Enumerable<paymentWhereUniqueInput>
  }

  export type paymentUpdateManyWithoutPayment_methodNestedInput = {
    create?: XOR<Enumerable<paymentCreateWithoutPayment_methodInput>, Enumerable<paymentUncheckedCreateWithoutPayment_methodInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutPayment_methodInput>
    upsert?: Enumerable<paymentUpsertWithWhereUniqueWithoutPayment_methodInput>
    createMany?: paymentCreateManyPayment_methodInputEnvelope
    set?: Enumerable<paymentWhereUniqueInput>
    disconnect?: Enumerable<paymentWhereUniqueInput>
    delete?: Enumerable<paymentWhereUniqueInput>
    connect?: Enumerable<paymentWhereUniqueInput>
    update?: Enumerable<paymentUpdateWithWhereUniqueWithoutPayment_methodInput>
    updateMany?: Enumerable<paymentUpdateManyWithWhereWithoutPayment_methodInput>
    deleteMany?: Enumerable<paymentScalarWhereInput>
  }

  export type paymentUncheckedUpdateManyWithoutPayment_methodNestedInput = {
    create?: XOR<Enumerable<paymentCreateWithoutPayment_methodInput>, Enumerable<paymentUncheckedCreateWithoutPayment_methodInput>>
    connectOrCreate?: Enumerable<paymentCreateOrConnectWithoutPayment_methodInput>
    upsert?: Enumerable<paymentUpsertWithWhereUniqueWithoutPayment_methodInput>
    createMany?: paymentCreateManyPayment_methodInputEnvelope
    set?: Enumerable<paymentWhereUniqueInput>
    disconnect?: Enumerable<paymentWhereUniqueInput>
    delete?: Enumerable<paymentWhereUniqueInput>
    connect?: Enumerable<paymentWhereUniqueInput>
    update?: Enumerable<paymentUpdateWithWhereUniqueWithoutPayment_methodInput>
    updateMany?: Enumerable<paymentUpdateManyWithWhereWithoutPayment_methodInput>
    deleteMany?: Enumerable<paymentScalarWhereInput>
  }

  export type date_and_hour_of_workCreateNestedOneWithoutFair_date_hour_of_workInput = {
    create?: XOR<date_and_hour_of_workCreateWithoutFair_date_hour_of_workInput, date_and_hour_of_workUncheckedCreateWithoutFair_date_hour_of_workInput>
    connectOrCreate?: date_and_hour_of_workCreateOrConnectWithoutFair_date_hour_of_workInput
    connect?: date_and_hour_of_workWhereUniqueInput
  }

  export type fairCreateNestedOneWithoutFair_date_hour_of_workInput = {
    create?: XOR<fairCreateWithoutFair_date_hour_of_workInput, fairUncheckedCreateWithoutFair_date_hour_of_workInput>
    connectOrCreate?: fairCreateOrConnectWithoutFair_date_hour_of_workInput
    connect?: fairWhereUniqueInput
  }

  export type date_and_hour_of_workUpdateOneRequiredWithoutFair_date_hour_of_workNestedInput = {
    create?: XOR<date_and_hour_of_workCreateWithoutFair_date_hour_of_workInput, date_and_hour_of_workUncheckedCreateWithoutFair_date_hour_of_workInput>
    connectOrCreate?: date_and_hour_of_workCreateOrConnectWithoutFair_date_hour_of_workInput
    upsert?: date_and_hour_of_workUpsertWithoutFair_date_hour_of_workInput
    connect?: date_and_hour_of_workWhereUniqueInput
    update?: XOR<date_and_hour_of_workUpdateWithoutFair_date_hour_of_workInput, date_and_hour_of_workUncheckedUpdateWithoutFair_date_hour_of_workInput>
  }

  export type fairUpdateOneRequiredWithoutFair_date_hour_of_workNestedInput = {
    create?: XOR<fairCreateWithoutFair_date_hour_of_workInput, fairUncheckedCreateWithoutFair_date_hour_of_workInput>
    connectOrCreate?: fairCreateOrConnectWithoutFair_date_hour_of_workInput
    upsert?: fairUpsertWithoutFair_date_hour_of_workInput
    connect?: fairWhereUniqueInput
    update?: XOR<fairUpdateWithoutFair_date_hour_of_workInput, fairUncheckedUpdateWithoutFair_date_hour_of_workInput>
  }

  export type day_of_weekCreateNestedOneWithoutDate_and_hour_of_workInput = {
    create?: XOR<day_of_weekCreateWithoutDate_and_hour_of_workInput, day_of_weekUncheckedCreateWithoutDate_and_hour_of_workInput>
    connectOrCreate?: day_of_weekCreateOrConnectWithoutDate_and_hour_of_workInput
    connect?: day_of_weekWhereUniqueInput
  }

  export type fair_date_hour_of_workCreateNestedManyWithoutDatesInput = {
    create?: XOR<Enumerable<fair_date_hour_of_workCreateWithoutDatesInput>, Enumerable<fair_date_hour_of_workUncheckedCreateWithoutDatesInput>>
    connectOrCreate?: Enumerable<fair_date_hour_of_workCreateOrConnectWithoutDatesInput>
    createMany?: fair_date_hour_of_workCreateManyDatesInputEnvelope
    connect?: Enumerable<fair_date_hour_of_workWhereUniqueInput>
  }

  export type fair_date_hour_of_workUncheckedCreateNestedManyWithoutDatesInput = {
    create?: XOR<Enumerable<fair_date_hour_of_workCreateWithoutDatesInput>, Enumerable<fair_date_hour_of_workUncheckedCreateWithoutDatesInput>>
    connectOrCreate?: Enumerable<fair_date_hour_of_workCreateOrConnectWithoutDatesInput>
    createMany?: fair_date_hour_of_workCreateManyDatesInputEnvelope
    connect?: Enumerable<fair_date_hour_of_workWhereUniqueInput>
  }

  export type day_of_weekUpdateOneRequiredWithoutDate_and_hour_of_workNestedInput = {
    create?: XOR<day_of_weekCreateWithoutDate_and_hour_of_workInput, day_of_weekUncheckedCreateWithoutDate_and_hour_of_workInput>
    connectOrCreate?: day_of_weekCreateOrConnectWithoutDate_and_hour_of_workInput
    upsert?: day_of_weekUpsertWithoutDate_and_hour_of_workInput
    connect?: day_of_weekWhereUniqueInput
    update?: XOR<day_of_weekUpdateWithoutDate_and_hour_of_workInput, day_of_weekUncheckedUpdateWithoutDate_and_hour_of_workInput>
  }

  export type fair_date_hour_of_workUpdateManyWithoutDatesNestedInput = {
    create?: XOR<Enumerable<fair_date_hour_of_workCreateWithoutDatesInput>, Enumerable<fair_date_hour_of_workUncheckedCreateWithoutDatesInput>>
    connectOrCreate?: Enumerable<fair_date_hour_of_workCreateOrConnectWithoutDatesInput>
    upsert?: Enumerable<fair_date_hour_of_workUpsertWithWhereUniqueWithoutDatesInput>
    createMany?: fair_date_hour_of_workCreateManyDatesInputEnvelope
    set?: Enumerable<fair_date_hour_of_workWhereUniqueInput>
    disconnect?: Enumerable<fair_date_hour_of_workWhereUniqueInput>
    delete?: Enumerable<fair_date_hour_of_workWhereUniqueInput>
    connect?: Enumerable<fair_date_hour_of_workWhereUniqueInput>
    update?: Enumerable<fair_date_hour_of_workUpdateWithWhereUniqueWithoutDatesInput>
    updateMany?: Enumerable<fair_date_hour_of_workUpdateManyWithWhereWithoutDatesInput>
    deleteMany?: Enumerable<fair_date_hour_of_workScalarWhereInput>
  }

  export type fair_date_hour_of_workUncheckedUpdateManyWithoutDatesNestedInput = {
    create?: XOR<Enumerable<fair_date_hour_of_workCreateWithoutDatesInput>, Enumerable<fair_date_hour_of_workUncheckedCreateWithoutDatesInput>>
    connectOrCreate?: Enumerable<fair_date_hour_of_workCreateOrConnectWithoutDatesInput>
    upsert?: Enumerable<fair_date_hour_of_workUpsertWithWhereUniqueWithoutDatesInput>
    createMany?: fair_date_hour_of_workCreateManyDatesInputEnvelope
    set?: Enumerable<fair_date_hour_of_workWhereUniqueInput>
    disconnect?: Enumerable<fair_date_hour_of_workWhereUniqueInput>
    delete?: Enumerable<fair_date_hour_of_workWhereUniqueInput>
    connect?: Enumerable<fair_date_hour_of_workWhereUniqueInput>
    update?: Enumerable<fair_date_hour_of_workUpdateWithWhereUniqueWithoutDatesInput>
    updateMany?: Enumerable<fair_date_hour_of_workUpdateManyWithWhereWithoutDatesInput>
    deleteMany?: Enumerable<fair_date_hour_of_workScalarWhereInput>
  }

  export type date_and_hour_of_workCreateNestedManyWithoutDay_of_weekInput = {
    create?: XOR<Enumerable<date_and_hour_of_workCreateWithoutDay_of_weekInput>, Enumerable<date_and_hour_of_workUncheckedCreateWithoutDay_of_weekInput>>
    connectOrCreate?: Enumerable<date_and_hour_of_workCreateOrConnectWithoutDay_of_weekInput>
    createMany?: date_and_hour_of_workCreateManyDay_of_weekInputEnvelope
    connect?: Enumerable<date_and_hour_of_workWhereUniqueInput>
  }

  export type date_and_hour_of_workUncheckedCreateNestedManyWithoutDay_of_weekInput = {
    create?: XOR<Enumerable<date_and_hour_of_workCreateWithoutDay_of_weekInput>, Enumerable<date_and_hour_of_workUncheckedCreateWithoutDay_of_weekInput>>
    connectOrCreate?: Enumerable<date_and_hour_of_workCreateOrConnectWithoutDay_of_weekInput>
    createMany?: date_and_hour_of_workCreateManyDay_of_weekInputEnvelope
    connect?: Enumerable<date_and_hour_of_workWhereUniqueInput>
  }

  export type date_and_hour_of_workUpdateManyWithoutDay_of_weekNestedInput = {
    create?: XOR<Enumerable<date_and_hour_of_workCreateWithoutDay_of_weekInput>, Enumerable<date_and_hour_of_workUncheckedCreateWithoutDay_of_weekInput>>
    connectOrCreate?: Enumerable<date_and_hour_of_workCreateOrConnectWithoutDay_of_weekInput>
    upsert?: Enumerable<date_and_hour_of_workUpsertWithWhereUniqueWithoutDay_of_weekInput>
    createMany?: date_and_hour_of_workCreateManyDay_of_weekInputEnvelope
    set?: Enumerable<date_and_hour_of_workWhereUniqueInput>
    disconnect?: Enumerable<date_and_hour_of_workWhereUniqueInput>
    delete?: Enumerable<date_and_hour_of_workWhereUniqueInput>
    connect?: Enumerable<date_and_hour_of_workWhereUniqueInput>
    update?: Enumerable<date_and_hour_of_workUpdateWithWhereUniqueWithoutDay_of_weekInput>
    updateMany?: Enumerable<date_and_hour_of_workUpdateManyWithWhereWithoutDay_of_weekInput>
    deleteMany?: Enumerable<date_and_hour_of_workScalarWhereInput>
  }

  export type date_and_hour_of_workUncheckedUpdateManyWithoutDay_of_weekNestedInput = {
    create?: XOR<Enumerable<date_and_hour_of_workCreateWithoutDay_of_weekInput>, Enumerable<date_and_hour_of_workUncheckedCreateWithoutDay_of_weekInput>>
    connectOrCreate?: Enumerable<date_and_hour_of_workCreateOrConnectWithoutDay_of_weekInput>
    upsert?: Enumerable<date_and_hour_of_workUpsertWithWhereUniqueWithoutDay_of_weekInput>
    createMany?: date_and_hour_of_workCreateManyDay_of_weekInputEnvelope
    set?: Enumerable<date_and_hour_of_workWhereUniqueInput>
    disconnect?: Enumerable<date_and_hour_of_workWhereUniqueInput>
    delete?: Enumerable<date_and_hour_of_workWhereUniqueInput>
    connect?: Enumerable<date_and_hour_of_workWhereUniqueInput>
    update?: Enumerable<date_and_hour_of_workUpdateWithWhereUniqueWithoutDay_of_weekInput>
    updateMany?: Enumerable<date_and_hour_of_workUpdateManyWithWhereWithoutDay_of_weekInput>
    deleteMany?: Enumerable<date_and_hour_of_workScalarWhereInput>
  }

  export type costumerCreateNestedManyWithoutGenderInput = {
    create?: XOR<Enumerable<costumerCreateWithoutGenderInput>, Enumerable<costumerUncheckedCreateWithoutGenderInput>>
    connectOrCreate?: Enumerable<costumerCreateOrConnectWithoutGenderInput>
    createMany?: costumerCreateManyGenderInputEnvelope
    connect?: Enumerable<costumerWhereUniqueInput>
  }

  export type deliverymanCreateNestedManyWithoutGenderInput = {
    create?: XOR<Enumerable<deliverymanCreateWithoutGenderInput>, Enumerable<deliverymanUncheckedCreateWithoutGenderInput>>
    connectOrCreate?: Enumerable<deliverymanCreateOrConnectWithoutGenderInput>
    createMany?: deliverymanCreateManyGenderInputEnvelope
    connect?: Enumerable<deliverymanWhereUniqueInput>
  }

  export type marketerCreateNestedManyWithoutGenderInput = {
    create?: XOR<Enumerable<marketerCreateWithoutGenderInput>, Enumerable<marketerUncheckedCreateWithoutGenderInput>>
    connectOrCreate?: Enumerable<marketerCreateOrConnectWithoutGenderInput>
    createMany?: marketerCreateManyGenderInputEnvelope
    connect?: Enumerable<marketerWhereUniqueInput>
  }

  export type costumerUncheckedCreateNestedManyWithoutGenderInput = {
    create?: XOR<Enumerable<costumerCreateWithoutGenderInput>, Enumerable<costumerUncheckedCreateWithoutGenderInput>>
    connectOrCreate?: Enumerable<costumerCreateOrConnectWithoutGenderInput>
    createMany?: costumerCreateManyGenderInputEnvelope
    connect?: Enumerable<costumerWhereUniqueInput>
  }

  export type deliverymanUncheckedCreateNestedManyWithoutGenderInput = {
    create?: XOR<Enumerable<deliverymanCreateWithoutGenderInput>, Enumerable<deliverymanUncheckedCreateWithoutGenderInput>>
    connectOrCreate?: Enumerable<deliverymanCreateOrConnectWithoutGenderInput>
    createMany?: deliverymanCreateManyGenderInputEnvelope
    connect?: Enumerable<deliverymanWhereUniqueInput>
  }

  export type marketerUncheckedCreateNestedManyWithoutGenderInput = {
    create?: XOR<Enumerable<marketerCreateWithoutGenderInput>, Enumerable<marketerUncheckedCreateWithoutGenderInput>>
    connectOrCreate?: Enumerable<marketerCreateOrConnectWithoutGenderInput>
    createMany?: marketerCreateManyGenderInputEnvelope
    connect?: Enumerable<marketerWhereUniqueInput>
  }

  export type costumerUpdateManyWithoutGenderNestedInput = {
    create?: XOR<Enumerable<costumerCreateWithoutGenderInput>, Enumerable<costumerUncheckedCreateWithoutGenderInput>>
    connectOrCreate?: Enumerable<costumerCreateOrConnectWithoutGenderInput>
    upsert?: Enumerable<costumerUpsertWithWhereUniqueWithoutGenderInput>
    createMany?: costumerCreateManyGenderInputEnvelope
    set?: Enumerable<costumerWhereUniqueInput>
    disconnect?: Enumerable<costumerWhereUniqueInput>
    delete?: Enumerable<costumerWhereUniqueInput>
    connect?: Enumerable<costumerWhereUniqueInput>
    update?: Enumerable<costumerUpdateWithWhereUniqueWithoutGenderInput>
    updateMany?: Enumerable<costumerUpdateManyWithWhereWithoutGenderInput>
    deleteMany?: Enumerable<costumerScalarWhereInput>
  }

  export type deliverymanUpdateManyWithoutGenderNestedInput = {
    create?: XOR<Enumerable<deliverymanCreateWithoutGenderInput>, Enumerable<deliverymanUncheckedCreateWithoutGenderInput>>
    connectOrCreate?: Enumerable<deliverymanCreateOrConnectWithoutGenderInput>
    upsert?: Enumerable<deliverymanUpsertWithWhereUniqueWithoutGenderInput>
    createMany?: deliverymanCreateManyGenderInputEnvelope
    set?: Enumerable<deliverymanWhereUniqueInput>
    disconnect?: Enumerable<deliverymanWhereUniqueInput>
    delete?: Enumerable<deliverymanWhereUniqueInput>
    connect?: Enumerable<deliverymanWhereUniqueInput>
    update?: Enumerable<deliverymanUpdateWithWhereUniqueWithoutGenderInput>
    updateMany?: Enumerable<deliverymanUpdateManyWithWhereWithoutGenderInput>
    deleteMany?: Enumerable<deliverymanScalarWhereInput>
  }

  export type marketerUpdateManyWithoutGenderNestedInput = {
    create?: XOR<Enumerable<marketerCreateWithoutGenderInput>, Enumerable<marketerUncheckedCreateWithoutGenderInput>>
    connectOrCreate?: Enumerable<marketerCreateOrConnectWithoutGenderInput>
    upsert?: Enumerable<marketerUpsertWithWhereUniqueWithoutGenderInput>
    createMany?: marketerCreateManyGenderInputEnvelope
    set?: Enumerable<marketerWhereUniqueInput>
    disconnect?: Enumerable<marketerWhereUniqueInput>
    delete?: Enumerable<marketerWhereUniqueInput>
    connect?: Enumerable<marketerWhereUniqueInput>
    update?: Enumerable<marketerUpdateWithWhereUniqueWithoutGenderInput>
    updateMany?: Enumerable<marketerUpdateManyWithWhereWithoutGenderInput>
    deleteMany?: Enumerable<marketerScalarWhereInput>
  }

  export type costumerUncheckedUpdateManyWithoutGenderNestedInput = {
    create?: XOR<Enumerable<costumerCreateWithoutGenderInput>, Enumerable<costumerUncheckedCreateWithoutGenderInput>>
    connectOrCreate?: Enumerable<costumerCreateOrConnectWithoutGenderInput>
    upsert?: Enumerable<costumerUpsertWithWhereUniqueWithoutGenderInput>
    createMany?: costumerCreateManyGenderInputEnvelope
    set?: Enumerable<costumerWhereUniqueInput>
    disconnect?: Enumerable<costumerWhereUniqueInput>
    delete?: Enumerable<costumerWhereUniqueInput>
    connect?: Enumerable<costumerWhereUniqueInput>
    update?: Enumerable<costumerUpdateWithWhereUniqueWithoutGenderInput>
    updateMany?: Enumerable<costumerUpdateManyWithWhereWithoutGenderInput>
    deleteMany?: Enumerable<costumerScalarWhereInput>
  }

  export type deliverymanUncheckedUpdateManyWithoutGenderNestedInput = {
    create?: XOR<Enumerable<deliverymanCreateWithoutGenderInput>, Enumerable<deliverymanUncheckedCreateWithoutGenderInput>>
    connectOrCreate?: Enumerable<deliverymanCreateOrConnectWithoutGenderInput>
    upsert?: Enumerable<deliverymanUpsertWithWhereUniqueWithoutGenderInput>
    createMany?: deliverymanCreateManyGenderInputEnvelope
    set?: Enumerable<deliverymanWhereUniqueInput>
    disconnect?: Enumerable<deliverymanWhereUniqueInput>
    delete?: Enumerable<deliverymanWhereUniqueInput>
    connect?: Enumerable<deliverymanWhereUniqueInput>
    update?: Enumerable<deliverymanUpdateWithWhereUniqueWithoutGenderInput>
    updateMany?: Enumerable<deliverymanUpdateManyWithWhereWithoutGenderInput>
    deleteMany?: Enumerable<deliverymanScalarWhereInput>
  }

  export type marketerUncheckedUpdateManyWithoutGenderNestedInput = {
    create?: XOR<Enumerable<marketerCreateWithoutGenderInput>, Enumerable<marketerUncheckedCreateWithoutGenderInput>>
    connectOrCreate?: Enumerable<marketerCreateOrConnectWithoutGenderInput>
    upsert?: Enumerable<marketerUpsertWithWhereUniqueWithoutGenderInput>
    createMany?: marketerCreateManyGenderInputEnvelope
    set?: Enumerable<marketerWhereUniqueInput>
    disconnect?: Enumerable<marketerWhereUniqueInput>
    delete?: Enumerable<marketerWhereUniqueInput>
    connect?: Enumerable<marketerWhereUniqueInput>
    update?: Enumerable<marketerUpdateWithWhereUniqueWithoutGenderInput>
    updateMany?: Enumerable<marketerUpdateManyWithWhereWithoutGenderInput>
    deleteMany?: Enumerable<marketerScalarWhereInput>
  }

  export type addressCreateNestedManyWithoutCityInput = {
    create?: XOR<Enumerable<addressCreateWithoutCityInput>, Enumerable<addressUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<addressCreateOrConnectWithoutCityInput>
    createMany?: addressCreateManyCityInputEnvelope
    connect?: Enumerable<addressWhereUniqueInput>
  }

  export type addressUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<Enumerable<addressCreateWithoutCityInput>, Enumerable<addressUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<addressCreateOrConnectWithoutCityInput>
    createMany?: addressCreateManyCityInputEnvelope
    connect?: Enumerable<addressWhereUniqueInput>
  }

  export type addressUpdateManyWithoutCityNestedInput = {
    create?: XOR<Enumerable<addressCreateWithoutCityInput>, Enumerable<addressUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<addressCreateOrConnectWithoutCityInput>
    upsert?: Enumerable<addressUpsertWithWhereUniqueWithoutCityInput>
    createMany?: addressCreateManyCityInputEnvelope
    set?: Enumerable<addressWhereUniqueInput>
    disconnect?: Enumerable<addressWhereUniqueInput>
    delete?: Enumerable<addressWhereUniqueInput>
    connect?: Enumerable<addressWhereUniqueInput>
    update?: Enumerable<addressUpdateWithWhereUniqueWithoutCityInput>
    updateMany?: Enumerable<addressUpdateManyWithWhereWithoutCityInput>
    deleteMany?: Enumerable<addressScalarWhereInput>
  }

  export type addressUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<Enumerable<addressCreateWithoutCityInput>, Enumerable<addressUncheckedCreateWithoutCityInput>>
    connectOrCreate?: Enumerable<addressCreateOrConnectWithoutCityInput>
    upsert?: Enumerable<addressUpsertWithWhereUniqueWithoutCityInput>
    createMany?: addressCreateManyCityInputEnvelope
    set?: Enumerable<addressWhereUniqueInput>
    disconnect?: Enumerable<addressWhereUniqueInput>
    delete?: Enumerable<addressWhereUniqueInput>
    connect?: Enumerable<addressWhereUniqueInput>
    update?: Enumerable<addressUpdateWithWhereUniqueWithoutCityInput>
    updateMany?: Enumerable<addressUpdateManyWithWhereWithoutCityInput>
    deleteMany?: Enumerable<addressScalarWhereInput>
  }

  export type addressCreateNestedManyWithoutNeighborhoodInput = {
    create?: XOR<Enumerable<addressCreateWithoutNeighborhoodInput>, Enumerable<addressUncheckedCreateWithoutNeighborhoodInput>>
    connectOrCreate?: Enumerable<addressCreateOrConnectWithoutNeighborhoodInput>
    createMany?: addressCreateManyNeighborhoodInputEnvelope
    connect?: Enumerable<addressWhereUniqueInput>
  }

  export type addressUncheckedCreateNestedManyWithoutNeighborhoodInput = {
    create?: XOR<Enumerable<addressCreateWithoutNeighborhoodInput>, Enumerable<addressUncheckedCreateWithoutNeighborhoodInput>>
    connectOrCreate?: Enumerable<addressCreateOrConnectWithoutNeighborhoodInput>
    createMany?: addressCreateManyNeighborhoodInputEnvelope
    connect?: Enumerable<addressWhereUniqueInput>
  }

  export type addressUpdateManyWithoutNeighborhoodNestedInput = {
    create?: XOR<Enumerable<addressCreateWithoutNeighborhoodInput>, Enumerable<addressUncheckedCreateWithoutNeighborhoodInput>>
    connectOrCreate?: Enumerable<addressCreateOrConnectWithoutNeighborhoodInput>
    upsert?: Enumerable<addressUpsertWithWhereUniqueWithoutNeighborhoodInput>
    createMany?: addressCreateManyNeighborhoodInputEnvelope
    set?: Enumerable<addressWhereUniqueInput>
    disconnect?: Enumerable<addressWhereUniqueInput>
    delete?: Enumerable<addressWhereUniqueInput>
    connect?: Enumerable<addressWhereUniqueInput>
    update?: Enumerable<addressUpdateWithWhereUniqueWithoutNeighborhoodInput>
    updateMany?: Enumerable<addressUpdateManyWithWhereWithoutNeighborhoodInput>
    deleteMany?: Enumerable<addressScalarWhereInput>
  }

  export type addressUncheckedUpdateManyWithoutNeighborhoodNestedInput = {
    create?: XOR<Enumerable<addressCreateWithoutNeighborhoodInput>, Enumerable<addressUncheckedCreateWithoutNeighborhoodInput>>
    connectOrCreate?: Enumerable<addressCreateOrConnectWithoutNeighborhoodInput>
    upsert?: Enumerable<addressUpsertWithWhereUniqueWithoutNeighborhoodInput>
    createMany?: addressCreateManyNeighborhoodInputEnvelope
    set?: Enumerable<addressWhereUniqueInput>
    disconnect?: Enumerable<addressWhereUniqueInput>
    delete?: Enumerable<addressWhereUniqueInput>
    connect?: Enumerable<addressWhereUniqueInput>
    update?: Enumerable<addressUpdateWithWhereUniqueWithoutNeighborhoodInput>
    updateMany?: Enumerable<addressUpdateManyWithWhereWithoutNeighborhoodInput>
    deleteMany?: Enumerable<addressScalarWhereInput>
  }

  export type addressCreateNestedManyWithoutUfInput = {
    create?: XOR<Enumerable<addressCreateWithoutUfInput>, Enumerable<addressUncheckedCreateWithoutUfInput>>
    connectOrCreate?: Enumerable<addressCreateOrConnectWithoutUfInput>
    createMany?: addressCreateManyUfInputEnvelope
    connect?: Enumerable<addressWhereUniqueInput>
  }

  export type addressUncheckedCreateNestedManyWithoutUfInput = {
    create?: XOR<Enumerable<addressCreateWithoutUfInput>, Enumerable<addressUncheckedCreateWithoutUfInput>>
    connectOrCreate?: Enumerable<addressCreateOrConnectWithoutUfInput>
    createMany?: addressCreateManyUfInputEnvelope
    connect?: Enumerable<addressWhereUniqueInput>
  }

  export type addressUpdateManyWithoutUfNestedInput = {
    create?: XOR<Enumerable<addressCreateWithoutUfInput>, Enumerable<addressUncheckedCreateWithoutUfInput>>
    connectOrCreate?: Enumerable<addressCreateOrConnectWithoutUfInput>
    upsert?: Enumerable<addressUpsertWithWhereUniqueWithoutUfInput>
    createMany?: addressCreateManyUfInputEnvelope
    set?: Enumerable<addressWhereUniqueInput>
    disconnect?: Enumerable<addressWhereUniqueInput>
    delete?: Enumerable<addressWhereUniqueInput>
    connect?: Enumerable<addressWhereUniqueInput>
    update?: Enumerable<addressUpdateWithWhereUniqueWithoutUfInput>
    updateMany?: Enumerable<addressUpdateManyWithWhereWithoutUfInput>
    deleteMany?: Enumerable<addressScalarWhereInput>
  }

  export type addressUncheckedUpdateManyWithoutUfNestedInput = {
    create?: XOR<Enumerable<addressCreateWithoutUfInput>, Enumerable<addressUncheckedCreateWithoutUfInput>>
    connectOrCreate?: Enumerable<addressCreateOrConnectWithoutUfInput>
    upsert?: Enumerable<addressUpsertWithWhereUniqueWithoutUfInput>
    createMany?: addressCreateManyUfInputEnvelope
    set?: Enumerable<addressWhereUniqueInput>
    disconnect?: Enumerable<addressWhereUniqueInput>
    delete?: Enumerable<addressWhereUniqueInput>
    connect?: Enumerable<addressWhereUniqueInput>
    update?: Enumerable<addressUpdateWithWhereUniqueWithoutUfInput>
    updateMany?: Enumerable<addressUpdateManyWithWhereWithoutUfInput>
    deleteMany?: Enumerable<addressScalarWhereInput>
  }

  export type imageCreateNestedOneWithoutCategory_of_productInput = {
    create?: XOR<imageCreateWithoutCategory_of_productInput, imageUncheckedCreateWithoutCategory_of_productInput>
    connectOrCreate?: imageCreateOrConnectWithoutCategory_of_productInput
    connect?: imageWhereUniqueInput
  }

  export type productCreateNestedManyWithoutCategory_of_productInput = {
    create?: XOR<Enumerable<productCreateWithoutCategory_of_productInput>, Enumerable<productUncheckedCreateWithoutCategory_of_productInput>>
    connectOrCreate?: Enumerable<productCreateOrConnectWithoutCategory_of_productInput>
    createMany?: productCreateManyCategory_of_productInputEnvelope
    connect?: Enumerable<productWhereUniqueInput>
  }

  export type productUncheckedCreateNestedManyWithoutCategory_of_productInput = {
    create?: XOR<Enumerable<productCreateWithoutCategory_of_productInput>, Enumerable<productUncheckedCreateWithoutCategory_of_productInput>>
    connectOrCreate?: Enumerable<productCreateOrConnectWithoutCategory_of_productInput>
    createMany?: productCreateManyCategory_of_productInputEnvelope
    connect?: Enumerable<productWhereUniqueInput>
  }

  export type imageUpdateOneRequiredWithoutCategory_of_productNestedInput = {
    create?: XOR<imageCreateWithoutCategory_of_productInput, imageUncheckedCreateWithoutCategory_of_productInput>
    connectOrCreate?: imageCreateOrConnectWithoutCategory_of_productInput
    upsert?: imageUpsertWithoutCategory_of_productInput
    connect?: imageWhereUniqueInput
    update?: XOR<imageUpdateWithoutCategory_of_productInput, imageUncheckedUpdateWithoutCategory_of_productInput>
  }

  export type productUpdateManyWithoutCategory_of_productNestedInput = {
    create?: XOR<Enumerable<productCreateWithoutCategory_of_productInput>, Enumerable<productUncheckedCreateWithoutCategory_of_productInput>>
    connectOrCreate?: Enumerable<productCreateOrConnectWithoutCategory_of_productInput>
    upsert?: Enumerable<productUpsertWithWhereUniqueWithoutCategory_of_productInput>
    createMany?: productCreateManyCategory_of_productInputEnvelope
    set?: Enumerable<productWhereUniqueInput>
    disconnect?: Enumerable<productWhereUniqueInput>
    delete?: Enumerable<productWhereUniqueInput>
    connect?: Enumerable<productWhereUniqueInput>
    update?: Enumerable<productUpdateWithWhereUniqueWithoutCategory_of_productInput>
    updateMany?: Enumerable<productUpdateManyWithWhereWithoutCategory_of_productInput>
    deleteMany?: Enumerable<productScalarWhereInput>
  }

  export type productUncheckedUpdateManyWithoutCategory_of_productNestedInput = {
    create?: XOR<Enumerable<productCreateWithoutCategory_of_productInput>, Enumerable<productUncheckedCreateWithoutCategory_of_productInput>>
    connectOrCreate?: Enumerable<productCreateOrConnectWithoutCategory_of_productInput>
    upsert?: Enumerable<productUpsertWithWhereUniqueWithoutCategory_of_productInput>
    createMany?: productCreateManyCategory_of_productInputEnvelope
    set?: Enumerable<productWhereUniqueInput>
    disconnect?: Enumerable<productWhereUniqueInput>
    delete?: Enumerable<productWhereUniqueInput>
    connect?: Enumerable<productWhereUniqueInput>
    update?: Enumerable<productUpdateWithWhereUniqueWithoutCategory_of_productInput>
    updateMany?: Enumerable<productUpdateManyWithWhereWithoutCategory_of_productInput>
    deleteMany?: Enumerable<productScalarWhereInput>
  }

  export type productCreateNestedOneWithoutSale_offInput = {
    create?: XOR<productCreateWithoutSale_offInput, productUncheckedCreateWithoutSale_offInput>
    connectOrCreate?: productCreateOrConnectWithoutSale_offInput
    connect?: productWhereUniqueInput
  }

  export type productUpdateOneRequiredWithoutSale_offNestedInput = {
    create?: XOR<productCreateWithoutSale_offInput, productUncheckedCreateWithoutSale_offInput>
    connectOrCreate?: productCreateOrConnectWithoutSale_offInput
    upsert?: productUpsertWithoutSale_offInput
    connect?: productWhereUniqueInput
    update?: XOR<productUpdateWithoutSale_offInput, productUncheckedUpdateWithoutSale_offInput>
  }

  export type productCreateNestedManyWithoutType_of_priceInput = {
    create?: XOR<Enumerable<productCreateWithoutType_of_priceInput>, Enumerable<productUncheckedCreateWithoutType_of_priceInput>>
    connectOrCreate?: Enumerable<productCreateOrConnectWithoutType_of_priceInput>
    createMany?: productCreateManyType_of_priceInputEnvelope
    connect?: Enumerable<productWhereUniqueInput>
  }

  export type productUncheckedCreateNestedManyWithoutType_of_priceInput = {
    create?: XOR<Enumerable<productCreateWithoutType_of_priceInput>, Enumerable<productUncheckedCreateWithoutType_of_priceInput>>
    connectOrCreate?: Enumerable<productCreateOrConnectWithoutType_of_priceInput>
    createMany?: productCreateManyType_of_priceInputEnvelope
    connect?: Enumerable<productWhereUniqueInput>
  }

  export type productUpdateManyWithoutType_of_priceNestedInput = {
    create?: XOR<Enumerable<productCreateWithoutType_of_priceInput>, Enumerable<productUncheckedCreateWithoutType_of_priceInput>>
    connectOrCreate?: Enumerable<productCreateOrConnectWithoutType_of_priceInput>
    upsert?: Enumerable<productUpsertWithWhereUniqueWithoutType_of_priceInput>
    createMany?: productCreateManyType_of_priceInputEnvelope
    set?: Enumerable<productWhereUniqueInput>
    disconnect?: Enumerable<productWhereUniqueInput>
    delete?: Enumerable<productWhereUniqueInput>
    connect?: Enumerable<productWhereUniqueInput>
    update?: Enumerable<productUpdateWithWhereUniqueWithoutType_of_priceInput>
    updateMany?: Enumerable<productUpdateManyWithWhereWithoutType_of_priceInput>
    deleteMany?: Enumerable<productScalarWhereInput>
  }

  export type productUncheckedUpdateManyWithoutType_of_priceNestedInput = {
    create?: XOR<Enumerable<productCreateWithoutType_of_priceInput>, Enumerable<productUncheckedCreateWithoutType_of_priceInput>>
    connectOrCreate?: Enumerable<productCreateOrConnectWithoutType_of_priceInput>
    upsert?: Enumerable<productUpsertWithWhereUniqueWithoutType_of_priceInput>
    createMany?: productCreateManyType_of_priceInputEnvelope
    set?: Enumerable<productWhereUniqueInput>
    disconnect?: Enumerable<productWhereUniqueInput>
    delete?: Enumerable<productWhereUniqueInput>
    connect?: Enumerable<productWhereUniqueInput>
    update?: Enumerable<productUpdateWithWhereUniqueWithoutType_of_priceInput>
    updateMany?: Enumerable<productUpdateManyWithWhereWithoutType_of_priceInput>
    deleteMany?: Enumerable<productScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type genderCreateWithoutCostumerInput = {
    name: string
    created_at?: Date | string
    updated_at: Date | string
    deliveryman?: deliverymanCreateNestedManyWithoutGenderInput
    marketer?: marketerCreateNestedManyWithoutGenderInput
  }

  export type genderUncheckedCreateWithoutCostumerInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at: Date | string
    deliveryman?: deliverymanUncheckedCreateNestedManyWithoutGenderInput
    marketer?: marketerUncheckedCreateNestedManyWithoutGenderInput
  }

  export type genderCreateOrConnectWithoutCostumerInput = {
    where: genderWhereUniqueInput
    create: XOR<genderCreateWithoutCostumerInput, genderUncheckedCreateWithoutCostumerInput>
  }

  export type costumer_addressesCreateWithoutCostumerInput = {
    created_at?: Date | string
    updated_at?: Date | string
    address: addressCreateNestedOneWithoutCostumer_addressesInput
    order?: orderCreateNestedManyWithoutCostumer_addressesInput
  }

  export type costumer_addressesUncheckedCreateWithoutCostumerInput = {
    id?: number
    addressId: number
    created_at?: Date | string
    updated_at?: Date | string
    order?: orderUncheckedCreateNestedManyWithoutCostumer_addressesInput
  }

  export type costumer_addressesCreateOrConnectWithoutCostumerInput = {
    where: costumer_addressesWhereUniqueInput
    create: XOR<costumer_addressesCreateWithoutCostumerInput, costumer_addressesUncheckedCreateWithoutCostumerInput>
  }

  export type costumer_addressesCreateManyCostumerInputEnvelope = {
    data: Enumerable<costumer_addressesCreateManyCostumerInput>
    skipDuplicates?: boolean
  }

  export type shopping_listCreateWithoutCostumerInput = {
    freight?: number | null
    total: number
    created_at?: Date | string
    updated_at?: Date | string
    order?: orderCreateNestedOneWithoutShopping_listInput
    products_in_shopping_list?: products_in_shopping_listCreateNestedManyWithoutShopping_listInput
  }

  export type shopping_listUncheckedCreateWithoutCostumerInput = {
    id?: number
    freight?: number | null
    total: number
    created_at?: Date | string
    updated_at?: Date | string
    order?: orderUncheckedCreateNestedOneWithoutShopping_listInput
    products_in_shopping_list?: products_in_shopping_listUncheckedCreateNestedManyWithoutShopping_listInput
  }

  export type shopping_listCreateOrConnectWithoutCostumerInput = {
    where: shopping_listWhereUniqueInput
    create: XOR<shopping_listCreateWithoutCostumerInput, shopping_listUncheckedCreateWithoutCostumerInput>
  }

  export type shopping_listCreateManyCostumerInputEnvelope = {
    data: Enumerable<shopping_listCreateManyCostumerInput>
    skipDuplicates?: boolean
  }

  export type genderUpsertWithoutCostumerInput = {
    update: XOR<genderUpdateWithoutCostumerInput, genderUncheckedUpdateWithoutCostumerInput>
    create: XOR<genderCreateWithoutCostumerInput, genderUncheckedCreateWithoutCostumerInput>
  }

  export type genderUpdateWithoutCostumerInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryman?: deliverymanUpdateManyWithoutGenderNestedInput
    marketer?: marketerUpdateManyWithoutGenderNestedInput
  }

  export type genderUncheckedUpdateWithoutCostumerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryman?: deliverymanUncheckedUpdateManyWithoutGenderNestedInput
    marketer?: marketerUncheckedUpdateManyWithoutGenderNestedInput
  }

  export type costumer_addressesUpsertWithWhereUniqueWithoutCostumerInput = {
    where: costumer_addressesWhereUniqueInput
    update: XOR<costumer_addressesUpdateWithoutCostumerInput, costumer_addressesUncheckedUpdateWithoutCostumerInput>
    create: XOR<costumer_addressesCreateWithoutCostumerInput, costumer_addressesUncheckedCreateWithoutCostumerInput>
  }

  export type costumer_addressesUpdateWithWhereUniqueWithoutCostumerInput = {
    where: costumer_addressesWhereUniqueInput
    data: XOR<costumer_addressesUpdateWithoutCostumerInput, costumer_addressesUncheckedUpdateWithoutCostumerInput>
  }

  export type costumer_addressesUpdateManyWithWhereWithoutCostumerInput = {
    where: costumer_addressesScalarWhereInput
    data: XOR<costumer_addressesUpdateManyMutationInput, costumer_addressesUncheckedUpdateManyWithoutCostumer_addressesInput>
  }

  export type costumer_addressesScalarWhereInput = {
    AND?: Enumerable<costumer_addressesScalarWhereInput>
    OR?: Enumerable<costumer_addressesScalarWhereInput>
    NOT?: Enumerable<costumer_addressesScalarWhereInput>
    id?: IntFilter | number
    addressId?: IntFilter | number
    costumerId?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type shopping_listUpsertWithWhereUniqueWithoutCostumerInput = {
    where: shopping_listWhereUniqueInput
    update: XOR<shopping_listUpdateWithoutCostumerInput, shopping_listUncheckedUpdateWithoutCostumerInput>
    create: XOR<shopping_listCreateWithoutCostumerInput, shopping_listUncheckedCreateWithoutCostumerInput>
  }

  export type shopping_listUpdateWithWhereUniqueWithoutCostumerInput = {
    where: shopping_listWhereUniqueInput
    data: XOR<shopping_listUpdateWithoutCostumerInput, shopping_listUncheckedUpdateWithoutCostumerInput>
  }

  export type shopping_listUpdateManyWithWhereWithoutCostumerInput = {
    where: shopping_listScalarWhereInput
    data: XOR<shopping_listUpdateManyMutationInput, shopping_listUncheckedUpdateManyWithoutShopping_listsInput>
  }

  export type shopping_listScalarWhereInput = {
    AND?: Enumerable<shopping_listScalarWhereInput>
    OR?: Enumerable<shopping_listScalarWhereInput>
    NOT?: Enumerable<shopping_listScalarWhereInput>
    id?: IntFilter | number
    freight?: FloatNullableFilter | number | null
    total?: FloatFilter | number
    costumerId?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type genderCreateWithoutDeliverymanInput = {
    name: string
    created_at?: Date | string
    updated_at: Date | string
    costumer?: costumerCreateNestedManyWithoutGenderInput
    marketer?: marketerCreateNestedManyWithoutGenderInput
  }

  export type genderUncheckedCreateWithoutDeliverymanInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at: Date | string
    costumer?: costumerUncheckedCreateNestedManyWithoutGenderInput
    marketer?: marketerUncheckedCreateNestedManyWithoutGenderInput
  }

  export type genderCreateOrConnectWithoutDeliverymanInput = {
    where: genderWhereUniqueInput
    create: XOR<genderCreateWithoutDeliverymanInput, genderUncheckedCreateWithoutDeliverymanInput>
  }

  export type locationCreateWithoutDeliverymanInput = {
    longitude: number
    latitude: number
    created_at?: Date | string
    updated_at?: Date | string
    address?: addressCreateNestedManyWithoutLocationInput
    fair?: fairCreateNestedManyWithoutLocationInput
    marketer?: marketerCreateNestedOneWithoutLocationInput
  }

  export type locationUncheckedCreateWithoutDeliverymanInput = {
    id?: number
    longitude: number
    latitude: number
    created_at?: Date | string
    updated_at?: Date | string
    address?: addressUncheckedCreateNestedManyWithoutLocationInput
    fair?: fairUncheckedCreateNestedManyWithoutLocationInput
    marketer?: marketerUncheckedCreateNestedOneWithoutLocationInput
  }

  export type locationCreateOrConnectWithoutDeliverymanInput = {
    where: locationWhereUniqueInput
    create: XOR<locationCreateWithoutDeliverymanInput, locationUncheckedCreateWithoutDeliverymanInput>
  }

  export type orderCreateWithoutDeliverymanInput = {
    accepted_status?: boolean
    delivered_status_for_client?: boolean
    retreat_products_status?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    intent_payment_id: string
    costumer_addresses: costumer_addressesCreateNestedOneWithoutOrderInput
    shopping_list: shopping_listCreateNestedOneWithoutOrderInput
    payment?: paymentCreateNestedOneWithoutOrderInput
  }

  export type orderUncheckedCreateWithoutDeliverymanInput = {
    id?: number
    accepted_status?: boolean
    delivered_status_for_client?: boolean
    retreat_products_status?: boolean
    shopping_listId: number
    created_at?: Date | string
    updated_at?: Date | string
    costumer_addressesId: number
    intent_payment_id: string
    payment?: paymentUncheckedCreateNestedOneWithoutOrderInput
  }

  export type orderCreateOrConnectWithoutDeliverymanInput = {
    where: orderWhereUniqueInput
    create: XOR<orderCreateWithoutDeliverymanInput, orderUncheckedCreateWithoutDeliverymanInput>
  }

  export type orderCreateManyDeliverymanInputEnvelope = {
    data: Enumerable<orderCreateManyDeliverymanInput>
    skipDuplicates?: boolean
  }

  export type veicule_deliverymanCreateWithoutOwnerInput = {
    created_at?: Date | string
    updated_at?: Date | string
    veicule: veiculeCreateNestedOneWithoutVeicule_deliverymanInput
  }

  export type veicule_deliverymanUncheckedCreateWithoutOwnerInput = {
    id?: number
    veiculeId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type veicule_deliverymanCreateOrConnectWithoutOwnerInput = {
    where: veicule_deliverymanWhereUniqueInput
    create: XOR<veicule_deliverymanCreateWithoutOwnerInput, veicule_deliverymanUncheckedCreateWithoutOwnerInput>
  }

  export type veicule_deliverymanCreateManyOwnerInputEnvelope = {
    data: Enumerable<veicule_deliverymanCreateManyOwnerInput>
    skipDuplicates?: boolean
  }

  export type genderUpsertWithoutDeliverymanInput = {
    update: XOR<genderUpdateWithoutDeliverymanInput, genderUncheckedUpdateWithoutDeliverymanInput>
    create: XOR<genderCreateWithoutDeliverymanInput, genderUncheckedCreateWithoutDeliverymanInput>
  }

  export type genderUpdateWithoutDeliverymanInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    costumer?: costumerUpdateManyWithoutGenderNestedInput
    marketer?: marketerUpdateManyWithoutGenderNestedInput
  }

  export type genderUncheckedUpdateWithoutDeliverymanInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    costumer?: costumerUncheckedUpdateManyWithoutGenderNestedInput
    marketer?: marketerUncheckedUpdateManyWithoutGenderNestedInput
  }

  export type locationUpsertWithoutDeliverymanInput = {
    update: XOR<locationUpdateWithoutDeliverymanInput, locationUncheckedUpdateWithoutDeliverymanInput>
    create: XOR<locationCreateWithoutDeliverymanInput, locationUncheckedCreateWithoutDeliverymanInput>
  }

  export type locationUpdateWithoutDeliverymanInput = {
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUpdateManyWithoutLocationNestedInput
    fair?: fairUpdateManyWithoutLocationNestedInput
    marketer?: marketerUpdateOneWithoutLocationNestedInput
  }

  export type locationUncheckedUpdateWithoutDeliverymanInput = {
    id?: IntFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUncheckedUpdateManyWithoutLocationNestedInput
    fair?: fairUncheckedUpdateManyWithoutLocationNestedInput
    marketer?: marketerUncheckedUpdateOneWithoutLocationNestedInput
  }

  export type orderUpsertWithWhereUniqueWithoutDeliverymanInput = {
    where: orderWhereUniqueInput
    update: XOR<orderUpdateWithoutDeliverymanInput, orderUncheckedUpdateWithoutDeliverymanInput>
    create: XOR<orderCreateWithoutDeliverymanInput, orderUncheckedCreateWithoutDeliverymanInput>
  }

  export type orderUpdateWithWhereUniqueWithoutDeliverymanInput = {
    where: orderWhereUniqueInput
    data: XOR<orderUpdateWithoutDeliverymanInput, orderUncheckedUpdateWithoutDeliverymanInput>
  }

  export type orderUpdateManyWithWhereWithoutDeliverymanInput = {
    where: orderScalarWhereInput
    data: XOR<orderUpdateManyMutationInput, orderUncheckedUpdateManyWithoutOrderInput>
  }

  export type orderScalarWhereInput = {
    AND?: Enumerable<orderScalarWhereInput>
    OR?: Enumerable<orderScalarWhereInput>
    NOT?: Enumerable<orderScalarWhereInput>
    id?: IntFilter | number
    accepted_status?: BoolFilter | boolean
    delivered_status_for_client?: BoolFilter | boolean
    retreat_products_status?: BoolFilter | boolean
    deliverymanId?: IntNullableFilter | number | null
    shopping_listId?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    costumer_addressesId?: IntFilter | number
    intent_payment_id?: StringFilter | string
  }

  export type veicule_deliverymanUpsertWithWhereUniqueWithoutOwnerInput = {
    where: veicule_deliverymanWhereUniqueInput
    update: XOR<veicule_deliverymanUpdateWithoutOwnerInput, veicule_deliverymanUncheckedUpdateWithoutOwnerInput>
    create: XOR<veicule_deliverymanCreateWithoutOwnerInput, veicule_deliverymanUncheckedCreateWithoutOwnerInput>
  }

  export type veicule_deliverymanUpdateWithWhereUniqueWithoutOwnerInput = {
    where: veicule_deliverymanWhereUniqueInput
    data: XOR<veicule_deliverymanUpdateWithoutOwnerInput, veicule_deliverymanUncheckedUpdateWithoutOwnerInput>
  }

  export type veicule_deliverymanUpdateManyWithWhereWithoutOwnerInput = {
    where: veicule_deliverymanScalarWhereInput
    data: XOR<veicule_deliverymanUpdateManyMutationInput, veicule_deliverymanUncheckedUpdateManyWithoutVeicule_deliverymanInput>
  }

  export type veicule_deliverymanScalarWhereInput = {
    AND?: Enumerable<veicule_deliverymanScalarWhereInput>
    OR?: Enumerable<veicule_deliverymanScalarWhereInput>
    NOT?: Enumerable<veicule_deliverymanScalarWhereInput>
    id?: IntFilter | number
    veiculeId?: IntFilter | number
    deliverymanId?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type deliverymanCreateWithoutVeicule_deliverymanInput = {
    name: string
    email: string
    password_hash: string
    picture_uri: string
    online?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    birthday: string
    gender: genderCreateNestedOneWithoutDeliverymanInput
    location: locationCreateNestedOneWithoutDeliverymanInput
    order?: orderCreateNestedManyWithoutDeliverymanInput
  }

  export type deliverymanUncheckedCreateWithoutVeicule_deliverymanInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    picture_uri: string
    locationId: number
    online?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    genderId: number
    birthday: string
    order?: orderUncheckedCreateNestedManyWithoutDeliverymanInput
  }

  export type deliverymanCreateOrConnectWithoutVeicule_deliverymanInput = {
    where: deliverymanWhereUniqueInput
    create: XOR<deliverymanCreateWithoutVeicule_deliverymanInput, deliverymanUncheckedCreateWithoutVeicule_deliverymanInput>
  }

  export type veiculeCreateWithoutVeicule_deliverymanInput = {
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type veiculeUncheckedCreateWithoutVeicule_deliverymanInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type veiculeCreateOrConnectWithoutVeicule_deliverymanInput = {
    where: veiculeWhereUniqueInput
    create: XOR<veiculeCreateWithoutVeicule_deliverymanInput, veiculeUncheckedCreateWithoutVeicule_deliverymanInput>
  }

  export type deliverymanUpsertWithoutVeicule_deliverymanInput = {
    update: XOR<deliverymanUpdateWithoutVeicule_deliverymanInput, deliverymanUncheckedUpdateWithoutVeicule_deliverymanInput>
    create: XOR<deliverymanCreateWithoutVeicule_deliverymanInput, deliverymanUncheckedCreateWithoutVeicule_deliverymanInput>
  }

  export type deliverymanUpdateWithoutVeicule_deliverymanInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: StringFieldUpdateOperationsInput | string
    online?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    birthday?: StringFieldUpdateOperationsInput | string
    gender?: genderUpdateOneRequiredWithoutDeliverymanNestedInput
    location?: locationUpdateOneRequiredWithoutDeliverymanNestedInput
    order?: orderUpdateManyWithoutDeliverymanNestedInput
  }

  export type deliverymanUncheckedUpdateWithoutVeicule_deliverymanInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: StringFieldUpdateOperationsInput | string
    locationId?: IntFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    genderId?: IntFieldUpdateOperationsInput | number
    birthday?: StringFieldUpdateOperationsInput | string
    order?: orderUncheckedUpdateManyWithoutDeliverymanNestedInput
  }

  export type veiculeUpsertWithoutVeicule_deliverymanInput = {
    update: XOR<veiculeUpdateWithoutVeicule_deliverymanInput, veiculeUncheckedUpdateWithoutVeicule_deliverymanInput>
    create: XOR<veiculeCreateWithoutVeicule_deliverymanInput, veiculeUncheckedCreateWithoutVeicule_deliverymanInput>
  }

  export type veiculeUpdateWithoutVeicule_deliverymanInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type veiculeUncheckedUpdateWithoutVeicule_deliverymanInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type orderCreateWithoutPaymentInput = {
    accepted_status?: boolean
    delivered_status_for_client?: boolean
    retreat_products_status?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    intent_payment_id: string
    costumer_addresses: costumer_addressesCreateNestedOneWithoutOrderInput
    deliveryman?: deliverymanCreateNestedOneWithoutOrderInput
    shopping_list: shopping_listCreateNestedOneWithoutOrderInput
  }

  export type orderUncheckedCreateWithoutPaymentInput = {
    id?: number
    accepted_status?: boolean
    delivered_status_for_client?: boolean
    retreat_products_status?: boolean
    deliverymanId?: number | null
    shopping_listId: number
    created_at?: Date | string
    updated_at?: Date | string
    costumer_addressesId: number
    intent_payment_id: string
  }

  export type orderCreateOrConnectWithoutPaymentInput = {
    where: orderWhereUniqueInput
    create: XOR<orderCreateWithoutPaymentInput, orderUncheckedCreateWithoutPaymentInput>
  }

  export type payment_methodCreateWithoutPaymentInput = {
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type payment_methodUncheckedCreateWithoutPaymentInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type payment_methodCreateOrConnectWithoutPaymentInput = {
    where: payment_methodWhereUniqueInput
    create: XOR<payment_methodCreateWithoutPaymentInput, payment_methodUncheckedCreateWithoutPaymentInput>
  }

  export type orderUpsertWithoutPaymentInput = {
    update: XOR<orderUpdateWithoutPaymentInput, orderUncheckedUpdateWithoutPaymentInput>
    create: XOR<orderCreateWithoutPaymentInput, orderUncheckedCreateWithoutPaymentInput>
  }

  export type orderUpdateWithoutPaymentInput = {
    accepted_status?: BoolFieldUpdateOperationsInput | boolean
    delivered_status_for_client?: BoolFieldUpdateOperationsInput | boolean
    retreat_products_status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    intent_payment_id?: StringFieldUpdateOperationsInput | string
    costumer_addresses?: costumer_addressesUpdateOneRequiredWithoutOrderNestedInput
    deliveryman?: deliverymanUpdateOneWithoutOrderNestedInput
    shopping_list?: shopping_listUpdateOneRequiredWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    accepted_status?: BoolFieldUpdateOperationsInput | boolean
    delivered_status_for_client?: BoolFieldUpdateOperationsInput | boolean
    retreat_products_status?: BoolFieldUpdateOperationsInput | boolean
    deliverymanId?: NullableIntFieldUpdateOperationsInput | number | null
    shopping_listId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    costumer_addressesId?: IntFieldUpdateOperationsInput | number
    intent_payment_id?: StringFieldUpdateOperationsInput | string
  }

  export type payment_methodUpsertWithoutPaymentInput = {
    update: XOR<payment_methodUpdateWithoutPaymentInput, payment_methodUncheckedUpdateWithoutPaymentInput>
    create: XOR<payment_methodCreateWithoutPaymentInput, payment_methodUncheckedCreateWithoutPaymentInput>
  }

  export type payment_methodUpdateWithoutPaymentInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_methodUncheckedUpdateWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type costumer_addressesCreateWithoutOrderInput = {
    created_at?: Date | string
    updated_at?: Date | string
    address: addressCreateNestedOneWithoutCostumer_addressesInput
    costumer: costumerCreateNestedOneWithoutCostumer_addressesInput
  }

  export type costumer_addressesUncheckedCreateWithoutOrderInput = {
    id?: number
    addressId: number
    costumerId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type costumer_addressesCreateOrConnectWithoutOrderInput = {
    where: costumer_addressesWhereUniqueInput
    create: XOR<costumer_addressesCreateWithoutOrderInput, costumer_addressesUncheckedCreateWithoutOrderInput>
  }

  export type deliverymanCreateWithoutOrderInput = {
    name: string
    email: string
    password_hash: string
    picture_uri: string
    online?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    birthday: string
    gender: genderCreateNestedOneWithoutDeliverymanInput
    location: locationCreateNestedOneWithoutDeliverymanInput
    veicule_deliveryman?: veicule_deliverymanCreateNestedManyWithoutOwnerInput
  }

  export type deliverymanUncheckedCreateWithoutOrderInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    picture_uri: string
    locationId: number
    online?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    genderId: number
    birthday: string
    veicule_deliveryman?: veicule_deliverymanUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type deliverymanCreateOrConnectWithoutOrderInput = {
    where: deliverymanWhereUniqueInput
    create: XOR<deliverymanCreateWithoutOrderInput, deliverymanUncheckedCreateWithoutOrderInput>
  }

  export type shopping_listCreateWithoutOrderInput = {
    freight?: number | null
    total: number
    created_at?: Date | string
    updated_at?: Date | string
    products_in_shopping_list?: products_in_shopping_listCreateNestedManyWithoutShopping_listInput
    costumer: costumerCreateNestedOneWithoutShopping_listsInput
  }

  export type shopping_listUncheckedCreateWithoutOrderInput = {
    id?: number
    freight?: number | null
    total: number
    costumerId: number
    created_at?: Date | string
    updated_at?: Date | string
    products_in_shopping_list?: products_in_shopping_listUncheckedCreateNestedManyWithoutShopping_listInput
  }

  export type shopping_listCreateOrConnectWithoutOrderInput = {
    where: shopping_listWhereUniqueInput
    create: XOR<shopping_listCreateWithoutOrderInput, shopping_listUncheckedCreateWithoutOrderInput>
  }

  export type paymentCreateWithoutOrderInput = {
    status?: boolean
    details: string
    created_at?: Date | string
    updated_at?: Date | string
    payment_method: payment_methodCreateNestedOneWithoutPaymentInput
  }

  export type paymentUncheckedCreateWithoutOrderInput = {
    id?: number
    status?: boolean
    details: string
    payment_methodId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type paymentCreateOrConnectWithoutOrderInput = {
    where: paymentWhereUniqueInput
    create: XOR<paymentCreateWithoutOrderInput, paymentUncheckedCreateWithoutOrderInput>
  }

  export type costumer_addressesUpsertWithoutOrderInput = {
    update: XOR<costumer_addressesUpdateWithoutOrderInput, costumer_addressesUncheckedUpdateWithoutOrderInput>
    create: XOR<costumer_addressesCreateWithoutOrderInput, costumer_addressesUncheckedCreateWithoutOrderInput>
  }

  export type costumer_addressesUpdateWithoutOrderInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUpdateOneRequiredWithoutCostumer_addressesNestedInput
    costumer?: costumerUpdateOneRequiredWithoutCostumer_addressesNestedInput
  }

  export type costumer_addressesUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    addressId?: IntFieldUpdateOperationsInput | number
    costumerId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type deliverymanUpsertWithoutOrderInput = {
    update: XOR<deliverymanUpdateWithoutOrderInput, deliverymanUncheckedUpdateWithoutOrderInput>
    create: XOR<deliverymanCreateWithoutOrderInput, deliverymanUncheckedCreateWithoutOrderInput>
  }

  export type deliverymanUpdateWithoutOrderInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: StringFieldUpdateOperationsInput | string
    online?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    birthday?: StringFieldUpdateOperationsInput | string
    gender?: genderUpdateOneRequiredWithoutDeliverymanNestedInput
    location?: locationUpdateOneRequiredWithoutDeliverymanNestedInput
    veicule_deliveryman?: veicule_deliverymanUpdateManyWithoutOwnerNestedInput
  }

  export type deliverymanUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: StringFieldUpdateOperationsInput | string
    locationId?: IntFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    genderId?: IntFieldUpdateOperationsInput | number
    birthday?: StringFieldUpdateOperationsInput | string
    veicule_deliveryman?: veicule_deliverymanUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type shopping_listUpsertWithoutOrderInput = {
    update: XOR<shopping_listUpdateWithoutOrderInput, shopping_listUncheckedUpdateWithoutOrderInput>
    create: XOR<shopping_listCreateWithoutOrderInput, shopping_listUncheckedCreateWithoutOrderInput>
  }

  export type shopping_listUpdateWithoutOrderInput = {
    freight?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    products_in_shopping_list?: products_in_shopping_listUpdateManyWithoutShopping_listNestedInput
    costumer?: costumerUpdateOneRequiredWithoutShopping_listsNestedInput
  }

  export type shopping_listUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    freight?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: FloatFieldUpdateOperationsInput | number
    costumerId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    products_in_shopping_list?: products_in_shopping_listUncheckedUpdateManyWithoutShopping_listNestedInput
  }

  export type paymentUpsertWithoutOrderInput = {
    update: XOR<paymentUpdateWithoutOrderInput, paymentUncheckedUpdateWithoutOrderInput>
    create: XOR<paymentCreateWithoutOrderInput, paymentUncheckedCreateWithoutOrderInput>
  }

  export type paymentUpdateWithoutOrderInput = {
    status?: BoolFieldUpdateOperationsInput | boolean
    details?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: payment_methodUpdateOneRequiredWithoutPaymentNestedInput
  }

  export type paymentUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    details?: StringFieldUpdateOperationsInput | string
    payment_methodId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type orderCreateWithoutShopping_listInput = {
    accepted_status?: boolean
    delivered_status_for_client?: boolean
    retreat_products_status?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    intent_payment_id: string
    costumer_addresses: costumer_addressesCreateNestedOneWithoutOrderInput
    deliveryman?: deliverymanCreateNestedOneWithoutOrderInput
    payment?: paymentCreateNestedOneWithoutOrderInput
  }

  export type orderUncheckedCreateWithoutShopping_listInput = {
    id?: number
    accepted_status?: boolean
    delivered_status_for_client?: boolean
    retreat_products_status?: boolean
    deliverymanId?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    costumer_addressesId: number
    intent_payment_id: string
    payment?: paymentUncheckedCreateNestedOneWithoutOrderInput
  }

  export type orderCreateOrConnectWithoutShopping_listInput = {
    where: orderWhereUniqueInput
    create: XOR<orderCreateWithoutShopping_listInput, orderUncheckedCreateWithoutShopping_listInput>
  }

  export type products_in_shopping_listCreateWithoutShopping_listInput = {
    created_at?: Date | string
    updated_at?: Date | string
    product: productCreateNestedOneWithoutProducts_in_shopping_listInput
  }

  export type products_in_shopping_listUncheckedCreateWithoutShopping_listInput = {
    id?: number
    productId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type products_in_shopping_listCreateOrConnectWithoutShopping_listInput = {
    where: products_in_shopping_listWhereUniqueInput
    create: XOR<products_in_shopping_listCreateWithoutShopping_listInput, products_in_shopping_listUncheckedCreateWithoutShopping_listInput>
  }

  export type products_in_shopping_listCreateManyShopping_listInputEnvelope = {
    data: Enumerable<products_in_shopping_listCreateManyShopping_listInput>
    skipDuplicates?: boolean
  }

  export type costumerCreateWithoutShopping_listsInput = {
    name: string
    email: string
    password_hash: string
    picture_uri?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    birthday: string
    cpf?: string | null
    gender: genderCreateNestedOneWithoutCostumerInput
    costumer_addresses?: costumer_addressesCreateNestedManyWithoutCostumerInput
  }

  export type costumerUncheckedCreateWithoutShopping_listsInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    picture_uri?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    genderId: number
    birthday: string
    cpf?: string | null
    costumer_addresses?: costumer_addressesUncheckedCreateNestedManyWithoutCostumerInput
  }

  export type costumerCreateOrConnectWithoutShopping_listsInput = {
    where: costumerWhereUniqueInput
    create: XOR<costumerCreateWithoutShopping_listsInput, costumerUncheckedCreateWithoutShopping_listsInput>
  }

  export type orderUpsertWithoutShopping_listInput = {
    update: XOR<orderUpdateWithoutShopping_listInput, orderUncheckedUpdateWithoutShopping_listInput>
    create: XOR<orderCreateWithoutShopping_listInput, orderUncheckedCreateWithoutShopping_listInput>
  }

  export type orderUpdateWithoutShopping_listInput = {
    accepted_status?: BoolFieldUpdateOperationsInput | boolean
    delivered_status_for_client?: BoolFieldUpdateOperationsInput | boolean
    retreat_products_status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    intent_payment_id?: StringFieldUpdateOperationsInput | string
    costumer_addresses?: costumer_addressesUpdateOneRequiredWithoutOrderNestedInput
    deliveryman?: deliverymanUpdateOneWithoutOrderNestedInput
    payment?: paymentUpdateOneWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateWithoutShopping_listInput = {
    id?: IntFieldUpdateOperationsInput | number
    accepted_status?: BoolFieldUpdateOperationsInput | boolean
    delivered_status_for_client?: BoolFieldUpdateOperationsInput | boolean
    retreat_products_status?: BoolFieldUpdateOperationsInput | boolean
    deliverymanId?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    costumer_addressesId?: IntFieldUpdateOperationsInput | number
    intent_payment_id?: StringFieldUpdateOperationsInput | string
    payment?: paymentUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type products_in_shopping_listUpsertWithWhereUniqueWithoutShopping_listInput = {
    where: products_in_shopping_listWhereUniqueInput
    update: XOR<products_in_shopping_listUpdateWithoutShopping_listInput, products_in_shopping_listUncheckedUpdateWithoutShopping_listInput>
    create: XOR<products_in_shopping_listCreateWithoutShopping_listInput, products_in_shopping_listUncheckedCreateWithoutShopping_listInput>
  }

  export type products_in_shopping_listUpdateWithWhereUniqueWithoutShopping_listInput = {
    where: products_in_shopping_listWhereUniqueInput
    data: XOR<products_in_shopping_listUpdateWithoutShopping_listInput, products_in_shopping_listUncheckedUpdateWithoutShopping_listInput>
  }

  export type products_in_shopping_listUpdateManyWithWhereWithoutShopping_listInput = {
    where: products_in_shopping_listScalarWhereInput
    data: XOR<products_in_shopping_listUpdateManyMutationInput, products_in_shopping_listUncheckedUpdateManyWithoutProducts_in_shopping_listInput>
  }

  export type products_in_shopping_listScalarWhereInput = {
    AND?: Enumerable<products_in_shopping_listScalarWhereInput>
    OR?: Enumerable<products_in_shopping_listScalarWhereInput>
    NOT?: Enumerable<products_in_shopping_listScalarWhereInput>
    id?: IntFilter | number
    shopping_listId?: IntFilter | number
    productId?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type costumerUpsertWithoutShopping_listsInput = {
    update: XOR<costumerUpdateWithoutShopping_listsInput, costumerUncheckedUpdateWithoutShopping_listsInput>
    create: XOR<costumerCreateWithoutShopping_listsInput, costumerUncheckedCreateWithoutShopping_listsInput>
  }

  export type costumerUpdateWithoutShopping_listsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    birthday?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: genderUpdateOneRequiredWithoutCostumerNestedInput
    costumer_addresses?: costumer_addressesUpdateManyWithoutCostumerNestedInput
  }

  export type costumerUncheckedUpdateWithoutShopping_listsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    genderId?: IntFieldUpdateOperationsInput | number
    birthday?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    costumer_addresses?: costumer_addressesUncheckedUpdateManyWithoutCostumerNestedInput
  }

  export type productCreateWithoutProducts_in_shopping_listInput = {
    name: string
    price: number
    quantity?: number | null
    review?: number
    active_for_selling?: boolean
    available_quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    description: string
    image_of_product?: image_of_productCreateNestedManyWithoutProductInput
    category_of_product: category_of_productCreateNestedOneWithoutProductInput
    marketer: marketerCreateNestedOneWithoutProductsInput
    type_of_price: type_of_priceCreateNestedOneWithoutProductInput
    sale_off?: sale_offCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutProducts_in_shopping_listInput = {
    id?: number
    name: string
    price: number
    quantity?: number | null
    review?: number
    active_for_selling?: boolean
    available_quantity: number
    marketerId: number
    created_at?: Date | string
    updated_at?: Date | string
    description: string
    category_of_productId: number
    type_of_productId: number
    image_of_product?: image_of_productUncheckedCreateNestedManyWithoutProductInput
    sale_off?: sale_offUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutProducts_in_shopping_listInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutProducts_in_shopping_listInput, productUncheckedCreateWithoutProducts_in_shopping_listInput>
  }

  export type shopping_listCreateWithoutProducts_in_shopping_listInput = {
    freight?: number | null
    total: number
    created_at?: Date | string
    updated_at?: Date | string
    order?: orderCreateNestedOneWithoutShopping_listInput
    costumer: costumerCreateNestedOneWithoutShopping_listsInput
  }

  export type shopping_listUncheckedCreateWithoutProducts_in_shopping_listInput = {
    id?: number
    freight?: number | null
    total: number
    costumerId: number
    created_at?: Date | string
    updated_at?: Date | string
    order?: orderUncheckedCreateNestedOneWithoutShopping_listInput
  }

  export type shopping_listCreateOrConnectWithoutProducts_in_shopping_listInput = {
    where: shopping_listWhereUniqueInput
    create: XOR<shopping_listCreateWithoutProducts_in_shopping_listInput, shopping_listUncheckedCreateWithoutProducts_in_shopping_listInput>
  }

  export type productUpsertWithoutProducts_in_shopping_listInput = {
    update: XOR<productUpdateWithoutProducts_in_shopping_listInput, productUncheckedUpdateWithoutProducts_in_shopping_listInput>
    create: XOR<productCreateWithoutProducts_in_shopping_listInput, productUncheckedCreateWithoutProducts_in_shopping_listInput>
  }

  export type productUpdateWithoutProducts_in_shopping_listInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    review?: FloatFieldUpdateOperationsInput | number
    active_for_selling?: BoolFieldUpdateOperationsInput | boolean
    available_quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    image_of_product?: image_of_productUpdateManyWithoutProductNestedInput
    category_of_product?: category_of_productUpdateOneRequiredWithoutProductNestedInput
    marketer?: marketerUpdateOneRequiredWithoutProductsNestedInput
    type_of_price?: type_of_priceUpdateOneRequiredWithoutProductNestedInput
    sale_off?: sale_offUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutProducts_in_shopping_listInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    review?: FloatFieldUpdateOperationsInput | number
    active_for_selling?: BoolFieldUpdateOperationsInput | boolean
    available_quantity?: IntFieldUpdateOperationsInput | number
    marketerId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    category_of_productId?: IntFieldUpdateOperationsInput | number
    type_of_productId?: IntFieldUpdateOperationsInput | number
    image_of_product?: image_of_productUncheckedUpdateManyWithoutProductNestedInput
    sale_off?: sale_offUncheckedUpdateManyWithoutProductNestedInput
  }

  export type shopping_listUpsertWithoutProducts_in_shopping_listInput = {
    update: XOR<shopping_listUpdateWithoutProducts_in_shopping_listInput, shopping_listUncheckedUpdateWithoutProducts_in_shopping_listInput>
    create: XOR<shopping_listCreateWithoutProducts_in_shopping_listInput, shopping_listUncheckedCreateWithoutProducts_in_shopping_listInput>
  }

  export type shopping_listUpdateWithoutProducts_in_shopping_listInput = {
    freight?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: orderUpdateOneWithoutShopping_listNestedInput
    costumer?: costumerUpdateOneRequiredWithoutShopping_listsNestedInput
  }

  export type shopping_listUncheckedUpdateWithoutProducts_in_shopping_listInput = {
    id?: IntFieldUpdateOperationsInput | number
    freight?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: FloatFieldUpdateOperationsInput | number
    costumerId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: orderUncheckedUpdateOneWithoutShopping_listNestedInput
  }

  export type image_of_productCreateWithoutProductInput = {
    created_at?: Date | string
    updated_at?: Date | string
    image: imageCreateNestedOneWithoutImage_of_productInput
  }

  export type image_of_productUncheckedCreateWithoutProductInput = {
    id?: number
    imageId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type image_of_productCreateOrConnectWithoutProductInput = {
    where: image_of_productWhereUniqueInput
    create: XOR<image_of_productCreateWithoutProductInput, image_of_productUncheckedCreateWithoutProductInput>
  }

  export type image_of_productCreateManyProductInputEnvelope = {
    data: Enumerable<image_of_productCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type category_of_productCreateWithoutProductInput = {
    name: string
    image: imageCreateNestedOneWithoutCategory_of_productInput
  }

  export type category_of_productUncheckedCreateWithoutProductInput = {
    id?: number
    imageId: number
    name: string
  }

  export type category_of_productCreateOrConnectWithoutProductInput = {
    where: category_of_productWhereUniqueInput
    create: XOR<category_of_productCreateWithoutProductInput, category_of_productUncheckedCreateWithoutProductInput>
  }

  export type marketerCreateWithoutProductsInput = {
    name: string
    email: string
    password_hash: string
    picture_uri?: string | null
    review?: number
    online?: boolean
    created_at?: Date | string
    birthday: string
    updated_at?: Date | string
    cnpj?: string | null
    cpf?: string | null
    phone: string
    tent_name: string
    fair_marketers?: fair_marketersCreateNestedManyWithoutMarketerInput
    gender: genderCreateNestedOneWithoutMarketerInput
    location: locationCreateNestedOneWithoutMarketerInput
  }

  export type marketerUncheckedCreateWithoutProductsInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    picture_uri?: string | null
    review?: number
    online?: boolean
    locationId: number
    created_at?: Date | string
    birthday: string
    updated_at?: Date | string
    genderId: number
    cnpj?: string | null
    cpf?: string | null
    phone: string
    tent_name: string
    fair_marketers?: fair_marketersUncheckedCreateNestedManyWithoutMarketerInput
  }

  export type marketerCreateOrConnectWithoutProductsInput = {
    where: marketerWhereUniqueInput
    create: XOR<marketerCreateWithoutProductsInput, marketerUncheckedCreateWithoutProductsInput>
  }

  export type type_of_priceCreateWithoutProductInput = {
    name: string
  }

  export type type_of_priceUncheckedCreateWithoutProductInput = {
    id?: number
    name: string
  }

  export type type_of_priceCreateOrConnectWithoutProductInput = {
    where: type_of_priceWhereUniqueInput
    create: XOR<type_of_priceCreateWithoutProductInput, type_of_priceUncheckedCreateWithoutProductInput>
  }

  export type products_in_shopping_listCreateWithoutProductInput = {
    created_at?: Date | string
    updated_at?: Date | string
    shopping_list: shopping_listCreateNestedOneWithoutProducts_in_shopping_listInput
  }

  export type products_in_shopping_listUncheckedCreateWithoutProductInput = {
    id?: number
    shopping_listId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type products_in_shopping_listCreateOrConnectWithoutProductInput = {
    where: products_in_shopping_listWhereUniqueInput
    create: XOR<products_in_shopping_listCreateWithoutProductInput, products_in_shopping_listUncheckedCreateWithoutProductInput>
  }

  export type products_in_shopping_listCreateManyProductInputEnvelope = {
    data: Enumerable<products_in_shopping_listCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type sale_offCreateWithoutProductInput = {
    value: number
  }

  export type sale_offUncheckedCreateWithoutProductInput = {
    id?: number
    value: number
  }

  export type sale_offCreateOrConnectWithoutProductInput = {
    where: sale_offWhereUniqueInput
    create: XOR<sale_offCreateWithoutProductInput, sale_offUncheckedCreateWithoutProductInput>
  }

  export type sale_offCreateManyProductInputEnvelope = {
    data: Enumerable<sale_offCreateManyProductInput>
    skipDuplicates?: boolean
  }

  export type image_of_productUpsertWithWhereUniqueWithoutProductInput = {
    where: image_of_productWhereUniqueInput
    update: XOR<image_of_productUpdateWithoutProductInput, image_of_productUncheckedUpdateWithoutProductInput>
    create: XOR<image_of_productCreateWithoutProductInput, image_of_productUncheckedCreateWithoutProductInput>
  }

  export type image_of_productUpdateWithWhereUniqueWithoutProductInput = {
    where: image_of_productWhereUniqueInput
    data: XOR<image_of_productUpdateWithoutProductInput, image_of_productUncheckedUpdateWithoutProductInput>
  }

  export type image_of_productUpdateManyWithWhereWithoutProductInput = {
    where: image_of_productScalarWhereInput
    data: XOR<image_of_productUpdateManyMutationInput, image_of_productUncheckedUpdateManyWithoutImage_of_productInput>
  }

  export type image_of_productScalarWhereInput = {
    AND?: Enumerable<image_of_productScalarWhereInput>
    OR?: Enumerable<image_of_productScalarWhereInput>
    NOT?: Enumerable<image_of_productScalarWhereInput>
    id?: IntFilter | number
    imageId?: IntFilter | number
    productId?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type category_of_productUpsertWithoutProductInput = {
    update: XOR<category_of_productUpdateWithoutProductInput, category_of_productUncheckedUpdateWithoutProductInput>
    create: XOR<category_of_productCreateWithoutProductInput, category_of_productUncheckedCreateWithoutProductInput>
  }

  export type category_of_productUpdateWithoutProductInput = {
    name?: StringFieldUpdateOperationsInput | string
    image?: imageUpdateOneRequiredWithoutCategory_of_productNestedInput
  }

  export type category_of_productUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    imageId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type marketerUpsertWithoutProductsInput = {
    update: XOR<marketerUpdateWithoutProductsInput, marketerUncheckedUpdateWithoutProductsInput>
    create: XOR<marketerCreateWithoutProductsInput, marketerUncheckedCreateWithoutProductsInput>
  }

  export type marketerUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: NullableStringFieldUpdateOperationsInput | string | null
    review?: FloatFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    birthday?: StringFieldUpdateOperationsInput | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    tent_name?: StringFieldUpdateOperationsInput | string
    fair_marketers?: fair_marketersUpdateManyWithoutMarketerNestedInput
    gender?: genderUpdateOneRequiredWithoutMarketerNestedInput
    location?: locationUpdateOneRequiredWithoutMarketerNestedInput
  }

  export type marketerUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: NullableStringFieldUpdateOperationsInput | string | null
    review?: FloatFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    locationId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    birthday?: StringFieldUpdateOperationsInput | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    genderId?: IntFieldUpdateOperationsInput | number
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    tent_name?: StringFieldUpdateOperationsInput | string
    fair_marketers?: fair_marketersUncheckedUpdateManyWithoutMarketerNestedInput
  }

  export type type_of_priceUpsertWithoutProductInput = {
    update: XOR<type_of_priceUpdateWithoutProductInput, type_of_priceUncheckedUpdateWithoutProductInput>
    create: XOR<type_of_priceCreateWithoutProductInput, type_of_priceUncheckedCreateWithoutProductInput>
  }

  export type type_of_priceUpdateWithoutProductInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type type_of_priceUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type products_in_shopping_listUpsertWithWhereUniqueWithoutProductInput = {
    where: products_in_shopping_listWhereUniqueInput
    update: XOR<products_in_shopping_listUpdateWithoutProductInput, products_in_shopping_listUncheckedUpdateWithoutProductInput>
    create: XOR<products_in_shopping_listCreateWithoutProductInput, products_in_shopping_listUncheckedCreateWithoutProductInput>
  }

  export type products_in_shopping_listUpdateWithWhereUniqueWithoutProductInput = {
    where: products_in_shopping_listWhereUniqueInput
    data: XOR<products_in_shopping_listUpdateWithoutProductInput, products_in_shopping_listUncheckedUpdateWithoutProductInput>
  }

  export type products_in_shopping_listUpdateManyWithWhereWithoutProductInput = {
    where: products_in_shopping_listScalarWhereInput
    data: XOR<products_in_shopping_listUpdateManyMutationInput, products_in_shopping_listUncheckedUpdateManyWithoutProducts_in_shopping_listInput>
  }

  export type sale_offUpsertWithWhereUniqueWithoutProductInput = {
    where: sale_offWhereUniqueInput
    update: XOR<sale_offUpdateWithoutProductInput, sale_offUncheckedUpdateWithoutProductInput>
    create: XOR<sale_offCreateWithoutProductInput, sale_offUncheckedCreateWithoutProductInput>
  }

  export type sale_offUpdateWithWhereUniqueWithoutProductInput = {
    where: sale_offWhereUniqueInput
    data: XOR<sale_offUpdateWithoutProductInput, sale_offUncheckedUpdateWithoutProductInput>
  }

  export type sale_offUpdateManyWithWhereWithoutProductInput = {
    where: sale_offScalarWhereInput
    data: XOR<sale_offUpdateManyMutationInput, sale_offUncheckedUpdateManyWithoutSale_offInput>
  }

  export type sale_offScalarWhereInput = {
    AND?: Enumerable<sale_offScalarWhereInput>
    OR?: Enumerable<sale_offScalarWhereInput>
    NOT?: Enumerable<sale_offScalarWhereInput>
    id?: IntFilter | number
    value?: FloatFilter | number
    productId?: IntFilter | number
  }

  export type fair_marketersCreateWithoutMarketerInput = {
    created_at?: Date | string
    updated_at?: Date | string
    fair: fairCreateNestedOneWithoutFair_marketersInput
  }

  export type fair_marketersUncheckedCreateWithoutMarketerInput = {
    id?: number
    fairId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type fair_marketersCreateOrConnectWithoutMarketerInput = {
    where: fair_marketersWhereUniqueInput
    create: XOR<fair_marketersCreateWithoutMarketerInput, fair_marketersUncheckedCreateWithoutMarketerInput>
  }

  export type fair_marketersCreateManyMarketerInputEnvelope = {
    data: Enumerable<fair_marketersCreateManyMarketerInput>
    skipDuplicates?: boolean
  }

  export type genderCreateWithoutMarketerInput = {
    name: string
    created_at?: Date | string
    updated_at: Date | string
    costumer?: costumerCreateNestedManyWithoutGenderInput
    deliveryman?: deliverymanCreateNestedManyWithoutGenderInput
  }

  export type genderUncheckedCreateWithoutMarketerInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at: Date | string
    costumer?: costumerUncheckedCreateNestedManyWithoutGenderInput
    deliveryman?: deliverymanUncheckedCreateNestedManyWithoutGenderInput
  }

  export type genderCreateOrConnectWithoutMarketerInput = {
    where: genderWhereUniqueInput
    create: XOR<genderCreateWithoutMarketerInput, genderUncheckedCreateWithoutMarketerInput>
  }

  export type locationCreateWithoutMarketerInput = {
    longitude: number
    latitude: number
    created_at?: Date | string
    updated_at?: Date | string
    address?: addressCreateNestedManyWithoutLocationInput
    deliveryman?: deliverymanCreateNestedOneWithoutLocationInput
    fair?: fairCreateNestedManyWithoutLocationInput
  }

  export type locationUncheckedCreateWithoutMarketerInput = {
    id?: number
    longitude: number
    latitude: number
    created_at?: Date | string
    updated_at?: Date | string
    address?: addressUncheckedCreateNestedManyWithoutLocationInput
    deliveryman?: deliverymanUncheckedCreateNestedOneWithoutLocationInput
    fair?: fairUncheckedCreateNestedManyWithoutLocationInput
  }

  export type locationCreateOrConnectWithoutMarketerInput = {
    where: locationWhereUniqueInput
    create: XOR<locationCreateWithoutMarketerInput, locationUncheckedCreateWithoutMarketerInput>
  }

  export type productCreateWithoutMarketerInput = {
    name: string
    price: number
    quantity?: number | null
    review?: number
    active_for_selling?: boolean
    available_quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    description: string
    image_of_product?: image_of_productCreateNestedManyWithoutProductInput
    category_of_product: category_of_productCreateNestedOneWithoutProductInput
    type_of_price: type_of_priceCreateNestedOneWithoutProductInput
    products_in_shopping_list?: products_in_shopping_listCreateNestedManyWithoutProductInput
    sale_off?: sale_offCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutMarketerInput = {
    id?: number
    name: string
    price: number
    quantity?: number | null
    review?: number
    active_for_selling?: boolean
    available_quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    description: string
    category_of_productId: number
    type_of_productId: number
    image_of_product?: image_of_productUncheckedCreateNestedManyWithoutProductInput
    products_in_shopping_list?: products_in_shopping_listUncheckedCreateNestedManyWithoutProductInput
    sale_off?: sale_offUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutMarketerInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutMarketerInput, productUncheckedCreateWithoutMarketerInput>
  }

  export type productCreateManyMarketerInputEnvelope = {
    data: Enumerable<productCreateManyMarketerInput>
    skipDuplicates?: boolean
  }

  export type fair_marketersUpsertWithWhereUniqueWithoutMarketerInput = {
    where: fair_marketersWhereUniqueInput
    update: XOR<fair_marketersUpdateWithoutMarketerInput, fair_marketersUncheckedUpdateWithoutMarketerInput>
    create: XOR<fair_marketersCreateWithoutMarketerInput, fair_marketersUncheckedCreateWithoutMarketerInput>
  }

  export type fair_marketersUpdateWithWhereUniqueWithoutMarketerInput = {
    where: fair_marketersWhereUniqueInput
    data: XOR<fair_marketersUpdateWithoutMarketerInput, fair_marketersUncheckedUpdateWithoutMarketerInput>
  }

  export type fair_marketersUpdateManyWithWhereWithoutMarketerInput = {
    where: fair_marketersScalarWhereInput
    data: XOR<fair_marketersUpdateManyMutationInput, fair_marketersUncheckedUpdateManyWithoutFair_marketersInput>
  }

  export type fair_marketersScalarWhereInput = {
    AND?: Enumerable<fair_marketersScalarWhereInput>
    OR?: Enumerable<fair_marketersScalarWhereInput>
    NOT?: Enumerable<fair_marketersScalarWhereInput>
    id?: IntFilter | number
    fairId?: IntFilter | number
    marketerId?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type genderUpsertWithoutMarketerInput = {
    update: XOR<genderUpdateWithoutMarketerInput, genderUncheckedUpdateWithoutMarketerInput>
    create: XOR<genderCreateWithoutMarketerInput, genderUncheckedCreateWithoutMarketerInput>
  }

  export type genderUpdateWithoutMarketerInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    costumer?: costumerUpdateManyWithoutGenderNestedInput
    deliveryman?: deliverymanUpdateManyWithoutGenderNestedInput
  }

  export type genderUncheckedUpdateWithoutMarketerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    costumer?: costumerUncheckedUpdateManyWithoutGenderNestedInput
    deliveryman?: deliverymanUncheckedUpdateManyWithoutGenderNestedInput
  }

  export type locationUpsertWithoutMarketerInput = {
    update: XOR<locationUpdateWithoutMarketerInput, locationUncheckedUpdateWithoutMarketerInput>
    create: XOR<locationCreateWithoutMarketerInput, locationUncheckedCreateWithoutMarketerInput>
  }

  export type locationUpdateWithoutMarketerInput = {
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUpdateManyWithoutLocationNestedInput
    deliveryman?: deliverymanUpdateOneWithoutLocationNestedInput
    fair?: fairUpdateManyWithoutLocationNestedInput
  }

  export type locationUncheckedUpdateWithoutMarketerInput = {
    id?: IntFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUncheckedUpdateManyWithoutLocationNestedInput
    deliveryman?: deliverymanUncheckedUpdateOneWithoutLocationNestedInput
    fair?: fairUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type productUpsertWithWhereUniqueWithoutMarketerInput = {
    where: productWhereUniqueInput
    update: XOR<productUpdateWithoutMarketerInput, productUncheckedUpdateWithoutMarketerInput>
    create: XOR<productCreateWithoutMarketerInput, productUncheckedCreateWithoutMarketerInput>
  }

  export type productUpdateWithWhereUniqueWithoutMarketerInput = {
    where: productWhereUniqueInput
    data: XOR<productUpdateWithoutMarketerInput, productUncheckedUpdateWithoutMarketerInput>
  }

  export type productUpdateManyWithWhereWithoutMarketerInput = {
    where: productScalarWhereInput
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyWithoutProductsInput>
  }

  export type productScalarWhereInput = {
    AND?: Enumerable<productScalarWhereInput>
    OR?: Enumerable<productScalarWhereInput>
    NOT?: Enumerable<productScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    price?: FloatFilter | number
    quantity?: FloatNullableFilter | number | null
    review?: FloatFilter | number
    active_for_selling?: BoolFilter | boolean
    available_quantity?: IntFilter | number
    marketerId?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    description?: StringFilter | string
    category_of_productId?: IntFilter | number
    type_of_productId?: IntFilter | number
  }

  export type addressCreateWithoutFairInput = {
    cep: string
    logradouro: string
    number: number
    created_at?: Date | string
    updated_at?: Date | string
    complemento: string
    type: address_typeCreateNestedOneWithoutAddressInput
    city: cityCreateNestedOneWithoutAddressInput
    location: locationCreateNestedOneWithoutAddressInput
    neighborhood: neighborhoodCreateNestedOneWithoutAddressInput
    uf: ufCreateNestedOneWithoutAddressInput
    costumer_addresses?: costumer_addressesCreateNestedManyWithoutAddressInput
  }

  export type addressUncheckedCreateWithoutFairInput = {
    id?: number
    cep: string
    logradouro: string
    number: number
    created_at?: Date | string
    updated_at?: Date | string
    address_typeId: number
    complemento: string
    cityId: number
    uFId: number
    neighborhoodId: number
    locationId: number
    costumer_addresses?: costumer_addressesUncheckedCreateNestedManyWithoutAddressInput
  }

  export type addressCreateOrConnectWithoutFairInput = {
    where: addressWhereUniqueInput
    create: XOR<addressCreateWithoutFairInput, addressUncheckedCreateWithoutFairInput>
  }

  export type locationCreateWithoutFairInput = {
    longitude: number
    latitude: number
    created_at?: Date | string
    updated_at?: Date | string
    address?: addressCreateNestedManyWithoutLocationInput
    deliveryman?: deliverymanCreateNestedOneWithoutLocationInput
    marketer?: marketerCreateNestedOneWithoutLocationInput
  }

  export type locationUncheckedCreateWithoutFairInput = {
    id?: number
    longitude: number
    latitude: number
    created_at?: Date | string
    updated_at?: Date | string
    address?: addressUncheckedCreateNestedManyWithoutLocationInput
    deliveryman?: deliverymanUncheckedCreateNestedOneWithoutLocationInput
    marketer?: marketerUncheckedCreateNestedOneWithoutLocationInput
  }

  export type locationCreateOrConnectWithoutFairInput = {
    where: locationWhereUniqueInput
    create: XOR<locationCreateWithoutFairInput, locationUncheckedCreateWithoutFairInput>
  }

  export type fair_date_hour_of_workCreateWithoutFairInput = {
    created_at?: Date | string
    updated_at?: Date | string
    dates: date_and_hour_of_workCreateNestedOneWithoutFair_date_hour_of_workInput
  }

  export type fair_date_hour_of_workUncheckedCreateWithoutFairInput = {
    id?: number
    date_and_hour_of_workId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type fair_date_hour_of_workCreateOrConnectWithoutFairInput = {
    where: fair_date_hour_of_workWhereUniqueInput
    create: XOR<fair_date_hour_of_workCreateWithoutFairInput, fair_date_hour_of_workUncheckedCreateWithoutFairInput>
  }

  export type fair_date_hour_of_workCreateManyFairInputEnvelope = {
    data: Enumerable<fair_date_hour_of_workCreateManyFairInput>
    skipDuplicates?: boolean
  }

  export type fair_marketersCreateWithoutFairInput = {
    created_at?: Date | string
    updated_at?: Date | string
    marketer: marketerCreateNestedOneWithoutFair_marketersInput
  }

  export type fair_marketersUncheckedCreateWithoutFairInput = {
    id?: number
    marketerId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type fair_marketersCreateOrConnectWithoutFairInput = {
    where: fair_marketersWhereUniqueInput
    create: XOR<fair_marketersCreateWithoutFairInput, fair_marketersUncheckedCreateWithoutFairInput>
  }

  export type fair_marketersCreateManyFairInputEnvelope = {
    data: Enumerable<fair_marketersCreateManyFairInput>
    skipDuplicates?: boolean
  }

  export type imageCreateWithoutFairInput = {
    uri: string
    created_at?: Date | string
    updated_at?: Date | string
    category_of_product?: category_of_productCreateNestedManyWithoutImageInput
    image_of_product?: image_of_productCreateNestedManyWithoutImageInput
  }

  export type imageUncheckedCreateWithoutFairInput = {
    id?: number
    uri: string
    created_at?: Date | string
    updated_at?: Date | string
    category_of_product?: category_of_productUncheckedCreateNestedManyWithoutImageInput
    image_of_product?: image_of_productUncheckedCreateNestedManyWithoutImageInput
  }

  export type imageCreateOrConnectWithoutFairInput = {
    where: imageWhereUniqueInput
    create: XOR<imageCreateWithoutFairInput, imageUncheckedCreateWithoutFairInput>
  }

  export type imageCreateManyFairInputEnvelope = {
    data: Enumerable<imageCreateManyFairInput>
    skipDuplicates?: boolean
  }

  export type addressUpsertWithoutFairInput = {
    update: XOR<addressUpdateWithoutFairInput, addressUncheckedUpdateWithoutFairInput>
    create: XOR<addressCreateWithoutFairInput, addressUncheckedCreateWithoutFairInput>
  }

  export type addressUpdateWithoutFairInput = {
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    complemento?: StringFieldUpdateOperationsInput | string
    type?: address_typeUpdateOneRequiredWithoutAddressNestedInput
    city?: cityUpdateOneRequiredWithoutAddressNestedInput
    location?: locationUpdateOneRequiredWithoutAddressNestedInput
    neighborhood?: neighborhoodUpdateOneRequiredWithoutAddressNestedInput
    uf?: ufUpdateOneRequiredWithoutAddressNestedInput
    costumer_addresses?: costumer_addressesUpdateManyWithoutAddressNestedInput
  }

  export type addressUncheckedUpdateWithoutFairInput = {
    id?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address_typeId?: IntFieldUpdateOperationsInput | number
    complemento?: StringFieldUpdateOperationsInput | string
    cityId?: IntFieldUpdateOperationsInput | number
    uFId?: IntFieldUpdateOperationsInput | number
    neighborhoodId?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    costumer_addresses?: costumer_addressesUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type locationUpsertWithoutFairInput = {
    update: XOR<locationUpdateWithoutFairInput, locationUncheckedUpdateWithoutFairInput>
    create: XOR<locationCreateWithoutFairInput, locationUncheckedCreateWithoutFairInput>
  }

  export type locationUpdateWithoutFairInput = {
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUpdateManyWithoutLocationNestedInput
    deliveryman?: deliverymanUpdateOneWithoutLocationNestedInput
    marketer?: marketerUpdateOneWithoutLocationNestedInput
  }

  export type locationUncheckedUpdateWithoutFairInput = {
    id?: IntFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUncheckedUpdateManyWithoutLocationNestedInput
    deliveryman?: deliverymanUncheckedUpdateOneWithoutLocationNestedInput
    marketer?: marketerUncheckedUpdateOneWithoutLocationNestedInput
  }

  export type fair_date_hour_of_workUpsertWithWhereUniqueWithoutFairInput = {
    where: fair_date_hour_of_workWhereUniqueInput
    update: XOR<fair_date_hour_of_workUpdateWithoutFairInput, fair_date_hour_of_workUncheckedUpdateWithoutFairInput>
    create: XOR<fair_date_hour_of_workCreateWithoutFairInput, fair_date_hour_of_workUncheckedCreateWithoutFairInput>
  }

  export type fair_date_hour_of_workUpdateWithWhereUniqueWithoutFairInput = {
    where: fair_date_hour_of_workWhereUniqueInput
    data: XOR<fair_date_hour_of_workUpdateWithoutFairInput, fair_date_hour_of_workUncheckedUpdateWithoutFairInput>
  }

  export type fair_date_hour_of_workUpdateManyWithWhereWithoutFairInput = {
    where: fair_date_hour_of_workScalarWhereInput
    data: XOR<fair_date_hour_of_workUpdateManyMutationInput, fair_date_hour_of_workUncheckedUpdateManyWithoutFair_date_hour_of_workInput>
  }

  export type fair_date_hour_of_workScalarWhereInput = {
    AND?: Enumerable<fair_date_hour_of_workScalarWhereInput>
    OR?: Enumerable<fair_date_hour_of_workScalarWhereInput>
    NOT?: Enumerable<fair_date_hour_of_workScalarWhereInput>
    id?: IntFilter | number
    fairId?: IntFilter | number
    date_and_hour_of_workId?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type fair_marketersUpsertWithWhereUniqueWithoutFairInput = {
    where: fair_marketersWhereUniqueInput
    update: XOR<fair_marketersUpdateWithoutFairInput, fair_marketersUncheckedUpdateWithoutFairInput>
    create: XOR<fair_marketersCreateWithoutFairInput, fair_marketersUncheckedCreateWithoutFairInput>
  }

  export type fair_marketersUpdateWithWhereUniqueWithoutFairInput = {
    where: fair_marketersWhereUniqueInput
    data: XOR<fair_marketersUpdateWithoutFairInput, fair_marketersUncheckedUpdateWithoutFairInput>
  }

  export type fair_marketersUpdateManyWithWhereWithoutFairInput = {
    where: fair_marketersScalarWhereInput
    data: XOR<fair_marketersUpdateManyMutationInput, fair_marketersUncheckedUpdateManyWithoutFair_marketersInput>
  }

  export type imageUpsertWithWhereUniqueWithoutFairInput = {
    where: imageWhereUniqueInput
    update: XOR<imageUpdateWithoutFairInput, imageUncheckedUpdateWithoutFairInput>
    create: XOR<imageCreateWithoutFairInput, imageUncheckedCreateWithoutFairInput>
  }

  export type imageUpdateWithWhereUniqueWithoutFairInput = {
    where: imageWhereUniqueInput
    data: XOR<imageUpdateWithoutFairInput, imageUncheckedUpdateWithoutFairInput>
  }

  export type imageUpdateManyWithWhereWithoutFairInput = {
    where: imageScalarWhereInput
    data: XOR<imageUpdateManyMutationInput, imageUncheckedUpdateManyWithoutImageInput>
  }

  export type imageScalarWhereInput = {
    AND?: Enumerable<imageScalarWhereInput>
    OR?: Enumerable<imageScalarWhereInput>
    NOT?: Enumerable<imageScalarWhereInput>
    id?: IntFilter | number
    uri?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    fairId?: IntNullableFilter | number | null
  }

  export type fairCreateWithoutFair_marketersInput = {
    name: string
    review?: number
    created_at?: Date | string
    updated_at?: Date | string
    address: addressCreateNestedOneWithoutFairInput
    location: locationCreateNestedOneWithoutFairInput
    fair_date_hour_of_work?: fair_date_hour_of_workCreateNestedManyWithoutFairInput
    image?: imageCreateNestedManyWithoutFairInput
  }

  export type fairUncheckedCreateWithoutFair_marketersInput = {
    name: string
    id?: number
    review?: number
    addressId: number
    created_at?: Date | string
    updated_at?: Date | string
    locationId: number
    fair_date_hour_of_work?: fair_date_hour_of_workUncheckedCreateNestedManyWithoutFairInput
    image?: imageUncheckedCreateNestedManyWithoutFairInput
  }

  export type fairCreateOrConnectWithoutFair_marketersInput = {
    where: fairWhereUniqueInput
    create: XOR<fairCreateWithoutFair_marketersInput, fairUncheckedCreateWithoutFair_marketersInput>
  }

  export type marketerCreateWithoutFair_marketersInput = {
    name: string
    email: string
    password_hash: string
    picture_uri?: string | null
    review?: number
    online?: boolean
    created_at?: Date | string
    birthday: string
    updated_at?: Date | string
    cnpj?: string | null
    cpf?: string | null
    phone: string
    tent_name: string
    gender: genderCreateNestedOneWithoutMarketerInput
    location: locationCreateNestedOneWithoutMarketerInput
    products?: productCreateNestedManyWithoutMarketerInput
  }

  export type marketerUncheckedCreateWithoutFair_marketersInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    picture_uri?: string | null
    review?: number
    online?: boolean
    locationId: number
    created_at?: Date | string
    birthday: string
    updated_at?: Date | string
    genderId: number
    cnpj?: string | null
    cpf?: string | null
    phone: string
    tent_name: string
    products?: productUncheckedCreateNestedManyWithoutMarketerInput
  }

  export type marketerCreateOrConnectWithoutFair_marketersInput = {
    where: marketerWhereUniqueInput
    create: XOR<marketerCreateWithoutFair_marketersInput, marketerUncheckedCreateWithoutFair_marketersInput>
  }

  export type fairUpsertWithoutFair_marketersInput = {
    update: XOR<fairUpdateWithoutFair_marketersInput, fairUncheckedUpdateWithoutFair_marketersInput>
    create: XOR<fairCreateWithoutFair_marketersInput, fairUncheckedCreateWithoutFair_marketersInput>
  }

  export type fairUpdateWithoutFair_marketersInput = {
    name?: StringFieldUpdateOperationsInput | string
    review?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUpdateOneRequiredWithoutFairNestedInput
    location?: locationUpdateOneRequiredWithoutFairNestedInput
    fair_date_hour_of_work?: fair_date_hour_of_workUpdateManyWithoutFairNestedInput
    image?: imageUpdateManyWithoutFairNestedInput
  }

  export type fairUncheckedUpdateWithoutFair_marketersInput = {
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    review?: FloatFieldUpdateOperationsInput | number
    addressId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: IntFieldUpdateOperationsInput | number
    fair_date_hour_of_work?: fair_date_hour_of_workUncheckedUpdateManyWithoutFairNestedInput
    image?: imageUncheckedUpdateManyWithoutFairNestedInput
  }

  export type marketerUpsertWithoutFair_marketersInput = {
    update: XOR<marketerUpdateWithoutFair_marketersInput, marketerUncheckedUpdateWithoutFair_marketersInput>
    create: XOR<marketerCreateWithoutFair_marketersInput, marketerUncheckedCreateWithoutFair_marketersInput>
  }

  export type marketerUpdateWithoutFair_marketersInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: NullableStringFieldUpdateOperationsInput | string | null
    review?: FloatFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    birthday?: StringFieldUpdateOperationsInput | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    tent_name?: StringFieldUpdateOperationsInput | string
    gender?: genderUpdateOneRequiredWithoutMarketerNestedInput
    location?: locationUpdateOneRequiredWithoutMarketerNestedInput
    products?: productUpdateManyWithoutMarketerNestedInput
  }

  export type marketerUncheckedUpdateWithoutFair_marketersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: NullableStringFieldUpdateOperationsInput | string | null
    review?: FloatFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    locationId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    birthday?: StringFieldUpdateOperationsInput | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    genderId?: IntFieldUpdateOperationsInput | number
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    tent_name?: StringFieldUpdateOperationsInput | string
    products?: productUncheckedUpdateManyWithoutMarketerNestedInput
  }

  export type addressCreateWithoutCostumer_addressesInput = {
    cep: string
    logradouro: string
    number: number
    created_at?: Date | string
    updated_at?: Date | string
    complemento: string
    type: address_typeCreateNestedOneWithoutAddressInput
    city: cityCreateNestedOneWithoutAddressInput
    location: locationCreateNestedOneWithoutAddressInput
    neighborhood: neighborhoodCreateNestedOneWithoutAddressInput
    uf: ufCreateNestedOneWithoutAddressInput
    fair?: fairCreateNestedOneWithoutAddressInput
  }

  export type addressUncheckedCreateWithoutCostumer_addressesInput = {
    id?: number
    cep: string
    logradouro: string
    number: number
    created_at?: Date | string
    updated_at?: Date | string
    address_typeId: number
    complemento: string
    cityId: number
    uFId: number
    neighborhoodId: number
    locationId: number
    fair?: fairUncheckedCreateNestedOneWithoutAddressInput
  }

  export type addressCreateOrConnectWithoutCostumer_addressesInput = {
    where: addressWhereUniqueInput
    create: XOR<addressCreateWithoutCostumer_addressesInput, addressUncheckedCreateWithoutCostumer_addressesInput>
  }

  export type costumerCreateWithoutCostumer_addressesInput = {
    name: string
    email: string
    password_hash: string
    picture_uri?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    birthday: string
    cpf?: string | null
    gender: genderCreateNestedOneWithoutCostumerInput
    shopping_lists?: shopping_listCreateNestedManyWithoutCostumerInput
  }

  export type costumerUncheckedCreateWithoutCostumer_addressesInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    picture_uri?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    genderId: number
    birthday: string
    cpf?: string | null
    shopping_lists?: shopping_listUncheckedCreateNestedManyWithoutCostumerInput
  }

  export type costumerCreateOrConnectWithoutCostumer_addressesInput = {
    where: costumerWhereUniqueInput
    create: XOR<costumerCreateWithoutCostumer_addressesInput, costumerUncheckedCreateWithoutCostumer_addressesInput>
  }

  export type orderCreateWithoutCostumer_addressesInput = {
    accepted_status?: boolean
    delivered_status_for_client?: boolean
    retreat_products_status?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    intent_payment_id: string
    deliveryman?: deliverymanCreateNestedOneWithoutOrderInput
    shopping_list: shopping_listCreateNestedOneWithoutOrderInput
    payment?: paymentCreateNestedOneWithoutOrderInput
  }

  export type orderUncheckedCreateWithoutCostumer_addressesInput = {
    id?: number
    accepted_status?: boolean
    delivered_status_for_client?: boolean
    retreat_products_status?: boolean
    deliverymanId?: number | null
    shopping_listId: number
    created_at?: Date | string
    updated_at?: Date | string
    intent_payment_id: string
    payment?: paymentUncheckedCreateNestedOneWithoutOrderInput
  }

  export type orderCreateOrConnectWithoutCostumer_addressesInput = {
    where: orderWhereUniqueInput
    create: XOR<orderCreateWithoutCostumer_addressesInput, orderUncheckedCreateWithoutCostumer_addressesInput>
  }

  export type orderCreateManyCostumer_addressesInputEnvelope = {
    data: Enumerable<orderCreateManyCostumer_addressesInput>
    skipDuplicates?: boolean
  }

  export type addressUpsertWithoutCostumer_addressesInput = {
    update: XOR<addressUpdateWithoutCostumer_addressesInput, addressUncheckedUpdateWithoutCostumer_addressesInput>
    create: XOR<addressCreateWithoutCostumer_addressesInput, addressUncheckedCreateWithoutCostumer_addressesInput>
  }

  export type addressUpdateWithoutCostumer_addressesInput = {
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    complemento?: StringFieldUpdateOperationsInput | string
    type?: address_typeUpdateOneRequiredWithoutAddressNestedInput
    city?: cityUpdateOneRequiredWithoutAddressNestedInput
    location?: locationUpdateOneRequiredWithoutAddressNestedInput
    neighborhood?: neighborhoodUpdateOneRequiredWithoutAddressNestedInput
    uf?: ufUpdateOneRequiredWithoutAddressNestedInput
    fair?: fairUpdateOneWithoutAddressNestedInput
  }

  export type addressUncheckedUpdateWithoutCostumer_addressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address_typeId?: IntFieldUpdateOperationsInput | number
    complemento?: StringFieldUpdateOperationsInput | string
    cityId?: IntFieldUpdateOperationsInput | number
    uFId?: IntFieldUpdateOperationsInput | number
    neighborhoodId?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    fair?: fairUncheckedUpdateOneWithoutAddressNestedInput
  }

  export type costumerUpsertWithoutCostumer_addressesInput = {
    update: XOR<costumerUpdateWithoutCostumer_addressesInput, costumerUncheckedUpdateWithoutCostumer_addressesInput>
    create: XOR<costumerCreateWithoutCostumer_addressesInput, costumerUncheckedCreateWithoutCostumer_addressesInput>
  }

  export type costumerUpdateWithoutCostumer_addressesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    birthday?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: genderUpdateOneRequiredWithoutCostumerNestedInput
    shopping_lists?: shopping_listUpdateManyWithoutCostumerNestedInput
  }

  export type costumerUncheckedUpdateWithoutCostumer_addressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    genderId?: IntFieldUpdateOperationsInput | number
    birthday?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    shopping_lists?: shopping_listUncheckedUpdateManyWithoutCostumerNestedInput
  }

  export type orderUpsertWithWhereUniqueWithoutCostumer_addressesInput = {
    where: orderWhereUniqueInput
    update: XOR<orderUpdateWithoutCostumer_addressesInput, orderUncheckedUpdateWithoutCostumer_addressesInput>
    create: XOR<orderCreateWithoutCostumer_addressesInput, orderUncheckedCreateWithoutCostumer_addressesInput>
  }

  export type orderUpdateWithWhereUniqueWithoutCostumer_addressesInput = {
    where: orderWhereUniqueInput
    data: XOR<orderUpdateWithoutCostumer_addressesInput, orderUncheckedUpdateWithoutCostumer_addressesInput>
  }

  export type orderUpdateManyWithWhereWithoutCostumer_addressesInput = {
    where: orderScalarWhereInput
    data: XOR<orderUpdateManyMutationInput, orderUncheckedUpdateManyWithoutOrderInput>
  }

  export type addressCreateWithoutLocationInput = {
    cep: string
    logradouro: string
    number: number
    created_at?: Date | string
    updated_at?: Date | string
    complemento: string
    type: address_typeCreateNestedOneWithoutAddressInput
    city: cityCreateNestedOneWithoutAddressInput
    neighborhood: neighborhoodCreateNestedOneWithoutAddressInput
    uf: ufCreateNestedOneWithoutAddressInput
    costumer_addresses?: costumer_addressesCreateNestedManyWithoutAddressInput
    fair?: fairCreateNestedOneWithoutAddressInput
  }

  export type addressUncheckedCreateWithoutLocationInput = {
    id?: number
    cep: string
    logradouro: string
    number: number
    created_at?: Date | string
    updated_at?: Date | string
    address_typeId: number
    complemento: string
    cityId: number
    uFId: number
    neighborhoodId: number
    costumer_addresses?: costumer_addressesUncheckedCreateNestedManyWithoutAddressInput
    fair?: fairUncheckedCreateNestedOneWithoutAddressInput
  }

  export type addressCreateOrConnectWithoutLocationInput = {
    where: addressWhereUniqueInput
    create: XOR<addressCreateWithoutLocationInput, addressUncheckedCreateWithoutLocationInput>
  }

  export type addressCreateManyLocationInputEnvelope = {
    data: Enumerable<addressCreateManyLocationInput>
    skipDuplicates?: boolean
  }

  export type deliverymanCreateWithoutLocationInput = {
    name: string
    email: string
    password_hash: string
    picture_uri: string
    online?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    birthday: string
    gender: genderCreateNestedOneWithoutDeliverymanInput
    order?: orderCreateNestedManyWithoutDeliverymanInput
    veicule_deliveryman?: veicule_deliverymanCreateNestedManyWithoutOwnerInput
  }

  export type deliverymanUncheckedCreateWithoutLocationInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    picture_uri: string
    online?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    genderId: number
    birthday: string
    order?: orderUncheckedCreateNestedManyWithoutDeliverymanInput
    veicule_deliveryman?: veicule_deliverymanUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type deliverymanCreateOrConnectWithoutLocationInput = {
    where: deliverymanWhereUniqueInput
    create: XOR<deliverymanCreateWithoutLocationInput, deliverymanUncheckedCreateWithoutLocationInput>
  }

  export type fairCreateWithoutLocationInput = {
    name: string
    review?: number
    created_at?: Date | string
    updated_at?: Date | string
    address: addressCreateNestedOneWithoutFairInput
    fair_date_hour_of_work?: fair_date_hour_of_workCreateNestedManyWithoutFairInput
    fair_marketers?: fair_marketersCreateNestedManyWithoutFairInput
    image?: imageCreateNestedManyWithoutFairInput
  }

  export type fairUncheckedCreateWithoutLocationInput = {
    name: string
    id?: number
    review?: number
    addressId: number
    created_at?: Date | string
    updated_at?: Date | string
    fair_date_hour_of_work?: fair_date_hour_of_workUncheckedCreateNestedManyWithoutFairInput
    fair_marketers?: fair_marketersUncheckedCreateNestedManyWithoutFairInput
    image?: imageUncheckedCreateNestedManyWithoutFairInput
  }

  export type fairCreateOrConnectWithoutLocationInput = {
    where: fairWhereUniqueInput
    create: XOR<fairCreateWithoutLocationInput, fairUncheckedCreateWithoutLocationInput>
  }

  export type fairCreateManyLocationInputEnvelope = {
    data: Enumerable<fairCreateManyLocationInput>
    skipDuplicates?: boolean
  }

  export type marketerCreateWithoutLocationInput = {
    name: string
    email: string
    password_hash: string
    picture_uri?: string | null
    review?: number
    online?: boolean
    created_at?: Date | string
    birthday: string
    updated_at?: Date | string
    cnpj?: string | null
    cpf?: string | null
    phone: string
    tent_name: string
    fair_marketers?: fair_marketersCreateNestedManyWithoutMarketerInput
    gender: genderCreateNestedOneWithoutMarketerInput
    products?: productCreateNestedManyWithoutMarketerInput
  }

  export type marketerUncheckedCreateWithoutLocationInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    picture_uri?: string | null
    review?: number
    online?: boolean
    created_at?: Date | string
    birthday: string
    updated_at?: Date | string
    genderId: number
    cnpj?: string | null
    cpf?: string | null
    phone: string
    tent_name: string
    fair_marketers?: fair_marketersUncheckedCreateNestedManyWithoutMarketerInput
    products?: productUncheckedCreateNestedManyWithoutMarketerInput
  }

  export type marketerCreateOrConnectWithoutLocationInput = {
    where: marketerWhereUniqueInput
    create: XOR<marketerCreateWithoutLocationInput, marketerUncheckedCreateWithoutLocationInput>
  }

  export type addressUpsertWithWhereUniqueWithoutLocationInput = {
    where: addressWhereUniqueInput
    update: XOR<addressUpdateWithoutLocationInput, addressUncheckedUpdateWithoutLocationInput>
    create: XOR<addressCreateWithoutLocationInput, addressUncheckedCreateWithoutLocationInput>
  }

  export type addressUpdateWithWhereUniqueWithoutLocationInput = {
    where: addressWhereUniqueInput
    data: XOR<addressUpdateWithoutLocationInput, addressUncheckedUpdateWithoutLocationInput>
  }

  export type addressUpdateManyWithWhereWithoutLocationInput = {
    where: addressScalarWhereInput
    data: XOR<addressUpdateManyMutationInput, addressUncheckedUpdateManyWithoutAddressInput>
  }

  export type addressScalarWhereInput = {
    AND?: Enumerable<addressScalarWhereInput>
    OR?: Enumerable<addressScalarWhereInput>
    NOT?: Enumerable<addressScalarWhereInput>
    id?: IntFilter | number
    cep?: StringFilter | string
    logradouro?: StringFilter | string
    number?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    address_typeId?: IntFilter | number
    complemento?: StringFilter | string
    cityId?: IntFilter | number
    uFId?: IntFilter | number
    neighborhoodId?: IntFilter | number
    locationId?: IntFilter | number
  }

  export type deliverymanUpsertWithoutLocationInput = {
    update: XOR<deliverymanUpdateWithoutLocationInput, deliverymanUncheckedUpdateWithoutLocationInput>
    create: XOR<deliverymanCreateWithoutLocationInput, deliverymanUncheckedCreateWithoutLocationInput>
  }

  export type deliverymanUpdateWithoutLocationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: StringFieldUpdateOperationsInput | string
    online?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    birthday?: StringFieldUpdateOperationsInput | string
    gender?: genderUpdateOneRequiredWithoutDeliverymanNestedInput
    order?: orderUpdateManyWithoutDeliverymanNestedInput
    veicule_deliveryman?: veicule_deliverymanUpdateManyWithoutOwnerNestedInput
  }

  export type deliverymanUncheckedUpdateWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: StringFieldUpdateOperationsInput | string
    online?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    genderId?: IntFieldUpdateOperationsInput | number
    birthday?: StringFieldUpdateOperationsInput | string
    order?: orderUncheckedUpdateManyWithoutDeliverymanNestedInput
    veicule_deliveryman?: veicule_deliverymanUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type fairUpsertWithWhereUniqueWithoutLocationInput = {
    where: fairWhereUniqueInput
    update: XOR<fairUpdateWithoutLocationInput, fairUncheckedUpdateWithoutLocationInput>
    create: XOR<fairCreateWithoutLocationInput, fairUncheckedCreateWithoutLocationInput>
  }

  export type fairUpdateWithWhereUniqueWithoutLocationInput = {
    where: fairWhereUniqueInput
    data: XOR<fairUpdateWithoutLocationInput, fairUncheckedUpdateWithoutLocationInput>
  }

  export type fairUpdateManyWithWhereWithoutLocationInput = {
    where: fairScalarWhereInput
    data: XOR<fairUpdateManyMutationInput, fairUncheckedUpdateManyWithoutFairInput>
  }

  export type fairScalarWhereInput = {
    AND?: Enumerable<fairScalarWhereInput>
    OR?: Enumerable<fairScalarWhereInput>
    NOT?: Enumerable<fairScalarWhereInput>
    name?: StringFilter | string
    id?: IntFilter | number
    review?: FloatFilter | number
    addressId?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    locationId?: IntFilter | number
  }

  export type marketerUpsertWithoutLocationInput = {
    update: XOR<marketerUpdateWithoutLocationInput, marketerUncheckedUpdateWithoutLocationInput>
    create: XOR<marketerCreateWithoutLocationInput, marketerUncheckedCreateWithoutLocationInput>
  }

  export type marketerUpdateWithoutLocationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: NullableStringFieldUpdateOperationsInput | string | null
    review?: FloatFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    birthday?: StringFieldUpdateOperationsInput | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    tent_name?: StringFieldUpdateOperationsInput | string
    fair_marketers?: fair_marketersUpdateManyWithoutMarketerNestedInput
    gender?: genderUpdateOneRequiredWithoutMarketerNestedInput
    products?: productUpdateManyWithoutMarketerNestedInput
  }

  export type marketerUncheckedUpdateWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: NullableStringFieldUpdateOperationsInput | string | null
    review?: FloatFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    birthday?: StringFieldUpdateOperationsInput | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    genderId?: IntFieldUpdateOperationsInput | number
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    tent_name?: StringFieldUpdateOperationsInput | string
    fair_marketers?: fair_marketersUncheckedUpdateManyWithoutMarketerNestedInput
    products?: productUncheckedUpdateManyWithoutMarketerNestedInput
  }

  export type address_typeCreateWithoutAddressInput = {
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type address_typeUncheckedCreateWithoutAddressInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type address_typeCreateOrConnectWithoutAddressInput = {
    where: address_typeWhereUniqueInput
    create: XOR<address_typeCreateWithoutAddressInput, address_typeUncheckedCreateWithoutAddressInput>
  }

  export type cityCreateWithoutAddressInput = {
    name: string
  }

  export type cityUncheckedCreateWithoutAddressInput = {
    id?: number
    name: string
  }

  export type cityCreateOrConnectWithoutAddressInput = {
    where: cityWhereUniqueInput
    create: XOR<cityCreateWithoutAddressInput, cityUncheckedCreateWithoutAddressInput>
  }

  export type locationCreateWithoutAddressInput = {
    longitude: number
    latitude: number
    created_at?: Date | string
    updated_at?: Date | string
    deliveryman?: deliverymanCreateNestedOneWithoutLocationInput
    fair?: fairCreateNestedManyWithoutLocationInput
    marketer?: marketerCreateNestedOneWithoutLocationInput
  }

  export type locationUncheckedCreateWithoutAddressInput = {
    id?: number
    longitude: number
    latitude: number
    created_at?: Date | string
    updated_at?: Date | string
    deliveryman?: deliverymanUncheckedCreateNestedOneWithoutLocationInput
    fair?: fairUncheckedCreateNestedManyWithoutLocationInput
    marketer?: marketerUncheckedCreateNestedOneWithoutLocationInput
  }

  export type locationCreateOrConnectWithoutAddressInput = {
    where: locationWhereUniqueInput
    create: XOR<locationCreateWithoutAddressInput, locationUncheckedCreateWithoutAddressInput>
  }

  export type neighborhoodCreateWithoutAddressInput = {
    name: string
  }

  export type neighborhoodUncheckedCreateWithoutAddressInput = {
    id?: number
    name: string
  }

  export type neighborhoodCreateOrConnectWithoutAddressInput = {
    where: neighborhoodWhereUniqueInput
    create: XOR<neighborhoodCreateWithoutAddressInput, neighborhoodUncheckedCreateWithoutAddressInput>
  }

  export type ufCreateWithoutAddressInput = {
    name: string
  }

  export type ufUncheckedCreateWithoutAddressInput = {
    id?: number
    name: string
  }

  export type ufCreateOrConnectWithoutAddressInput = {
    where: ufWhereUniqueInput
    create: XOR<ufCreateWithoutAddressInput, ufUncheckedCreateWithoutAddressInput>
  }

  export type costumer_addressesCreateWithoutAddressInput = {
    created_at?: Date | string
    updated_at?: Date | string
    costumer: costumerCreateNestedOneWithoutCostumer_addressesInput
    order?: orderCreateNestedManyWithoutCostumer_addressesInput
  }

  export type costumer_addressesUncheckedCreateWithoutAddressInput = {
    id?: number
    costumerId: number
    created_at?: Date | string
    updated_at?: Date | string
    order?: orderUncheckedCreateNestedManyWithoutCostumer_addressesInput
  }

  export type costumer_addressesCreateOrConnectWithoutAddressInput = {
    where: costumer_addressesWhereUniqueInput
    create: XOR<costumer_addressesCreateWithoutAddressInput, costumer_addressesUncheckedCreateWithoutAddressInput>
  }

  export type costumer_addressesCreateManyAddressInputEnvelope = {
    data: Enumerable<costumer_addressesCreateManyAddressInput>
    skipDuplicates?: boolean
  }

  export type fairCreateWithoutAddressInput = {
    name: string
    review?: number
    created_at?: Date | string
    updated_at?: Date | string
    location: locationCreateNestedOneWithoutFairInput
    fair_date_hour_of_work?: fair_date_hour_of_workCreateNestedManyWithoutFairInput
    fair_marketers?: fair_marketersCreateNestedManyWithoutFairInput
    image?: imageCreateNestedManyWithoutFairInput
  }

  export type fairUncheckedCreateWithoutAddressInput = {
    name: string
    id?: number
    review?: number
    created_at?: Date | string
    updated_at?: Date | string
    locationId: number
    fair_date_hour_of_work?: fair_date_hour_of_workUncheckedCreateNestedManyWithoutFairInput
    fair_marketers?: fair_marketersUncheckedCreateNestedManyWithoutFairInput
    image?: imageUncheckedCreateNestedManyWithoutFairInput
  }

  export type fairCreateOrConnectWithoutAddressInput = {
    where: fairWhereUniqueInput
    create: XOR<fairCreateWithoutAddressInput, fairUncheckedCreateWithoutAddressInput>
  }

  export type address_typeUpsertWithoutAddressInput = {
    update: XOR<address_typeUpdateWithoutAddressInput, address_typeUncheckedUpdateWithoutAddressInput>
    create: XOR<address_typeCreateWithoutAddressInput, address_typeUncheckedCreateWithoutAddressInput>
  }

  export type address_typeUpdateWithoutAddressInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type address_typeUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cityUpsertWithoutAddressInput = {
    update: XOR<cityUpdateWithoutAddressInput, cityUncheckedUpdateWithoutAddressInput>
    create: XOR<cityCreateWithoutAddressInput, cityUncheckedCreateWithoutAddressInput>
  }

  export type cityUpdateWithoutAddressInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type cityUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type locationUpsertWithoutAddressInput = {
    update: XOR<locationUpdateWithoutAddressInput, locationUncheckedUpdateWithoutAddressInput>
    create: XOR<locationCreateWithoutAddressInput, locationUncheckedCreateWithoutAddressInput>
  }

  export type locationUpdateWithoutAddressInput = {
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryman?: deliverymanUpdateOneWithoutLocationNestedInput
    fair?: fairUpdateManyWithoutLocationNestedInput
    marketer?: marketerUpdateOneWithoutLocationNestedInput
  }

  export type locationUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryman?: deliverymanUncheckedUpdateOneWithoutLocationNestedInput
    fair?: fairUncheckedUpdateManyWithoutLocationNestedInput
    marketer?: marketerUncheckedUpdateOneWithoutLocationNestedInput
  }

  export type neighborhoodUpsertWithoutAddressInput = {
    update: XOR<neighborhoodUpdateWithoutAddressInput, neighborhoodUncheckedUpdateWithoutAddressInput>
    create: XOR<neighborhoodCreateWithoutAddressInput, neighborhoodUncheckedCreateWithoutAddressInput>
  }

  export type neighborhoodUpdateWithoutAddressInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type neighborhoodUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ufUpsertWithoutAddressInput = {
    update: XOR<ufUpdateWithoutAddressInput, ufUncheckedUpdateWithoutAddressInput>
    create: XOR<ufCreateWithoutAddressInput, ufUncheckedCreateWithoutAddressInput>
  }

  export type ufUpdateWithoutAddressInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ufUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type costumer_addressesUpsertWithWhereUniqueWithoutAddressInput = {
    where: costumer_addressesWhereUniqueInput
    update: XOR<costumer_addressesUpdateWithoutAddressInput, costumer_addressesUncheckedUpdateWithoutAddressInput>
    create: XOR<costumer_addressesCreateWithoutAddressInput, costumer_addressesUncheckedCreateWithoutAddressInput>
  }

  export type costumer_addressesUpdateWithWhereUniqueWithoutAddressInput = {
    where: costumer_addressesWhereUniqueInput
    data: XOR<costumer_addressesUpdateWithoutAddressInput, costumer_addressesUncheckedUpdateWithoutAddressInput>
  }

  export type costumer_addressesUpdateManyWithWhereWithoutAddressInput = {
    where: costumer_addressesScalarWhereInput
    data: XOR<costumer_addressesUpdateManyMutationInput, costumer_addressesUncheckedUpdateManyWithoutCostumer_addressesInput>
  }

  export type fairUpsertWithoutAddressInput = {
    update: XOR<fairUpdateWithoutAddressInput, fairUncheckedUpdateWithoutAddressInput>
    create: XOR<fairCreateWithoutAddressInput, fairUncheckedCreateWithoutAddressInput>
  }

  export type fairUpdateWithoutAddressInput = {
    name?: StringFieldUpdateOperationsInput | string
    review?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: locationUpdateOneRequiredWithoutFairNestedInput
    fair_date_hour_of_work?: fair_date_hour_of_workUpdateManyWithoutFairNestedInput
    fair_marketers?: fair_marketersUpdateManyWithoutFairNestedInput
    image?: imageUpdateManyWithoutFairNestedInput
  }

  export type fairUncheckedUpdateWithoutAddressInput = {
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    review?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: IntFieldUpdateOperationsInput | number
    fair_date_hour_of_work?: fair_date_hour_of_workUncheckedUpdateManyWithoutFairNestedInput
    fair_marketers?: fair_marketersUncheckedUpdateManyWithoutFairNestedInput
    image?: imageUncheckedUpdateManyWithoutFairNestedInput
  }

  export type addressCreateWithoutTypeInput = {
    cep: string
    logradouro: string
    number: number
    created_at?: Date | string
    updated_at?: Date | string
    complemento: string
    city: cityCreateNestedOneWithoutAddressInput
    location: locationCreateNestedOneWithoutAddressInput
    neighborhood: neighborhoodCreateNestedOneWithoutAddressInput
    uf: ufCreateNestedOneWithoutAddressInput
    costumer_addresses?: costumer_addressesCreateNestedManyWithoutAddressInput
    fair?: fairCreateNestedOneWithoutAddressInput
  }

  export type addressUncheckedCreateWithoutTypeInput = {
    id?: number
    cep: string
    logradouro: string
    number: number
    created_at?: Date | string
    updated_at?: Date | string
    complemento: string
    cityId: number
    uFId: number
    neighborhoodId: number
    locationId: number
    costumer_addresses?: costumer_addressesUncheckedCreateNestedManyWithoutAddressInput
    fair?: fairUncheckedCreateNestedOneWithoutAddressInput
  }

  export type addressCreateOrConnectWithoutTypeInput = {
    where: addressWhereUniqueInput
    create: XOR<addressCreateWithoutTypeInput, addressUncheckedCreateWithoutTypeInput>
  }

  export type addressCreateManyTypeInputEnvelope = {
    data: Enumerable<addressCreateManyTypeInput>
    skipDuplicates?: boolean
  }

  export type addressUpsertWithWhereUniqueWithoutTypeInput = {
    where: addressWhereUniqueInput
    update: XOR<addressUpdateWithoutTypeInput, addressUncheckedUpdateWithoutTypeInput>
    create: XOR<addressCreateWithoutTypeInput, addressUncheckedCreateWithoutTypeInput>
  }

  export type addressUpdateWithWhereUniqueWithoutTypeInput = {
    where: addressWhereUniqueInput
    data: XOR<addressUpdateWithoutTypeInput, addressUncheckedUpdateWithoutTypeInput>
  }

  export type addressUpdateManyWithWhereWithoutTypeInput = {
    where: addressScalarWhereInput
    data: XOR<addressUpdateManyMutationInput, addressUncheckedUpdateManyWithoutAddressInput>
  }

  export type veicule_deliverymanCreateWithoutVeiculeInput = {
    created_at?: Date | string
    updated_at?: Date | string
    owner: deliverymanCreateNestedOneWithoutVeicule_deliverymanInput
  }

  export type veicule_deliverymanUncheckedCreateWithoutVeiculeInput = {
    id?: number
    deliverymanId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type veicule_deliverymanCreateOrConnectWithoutVeiculeInput = {
    where: veicule_deliverymanWhereUniqueInput
    create: XOR<veicule_deliverymanCreateWithoutVeiculeInput, veicule_deliverymanUncheckedCreateWithoutVeiculeInput>
  }

  export type veicule_deliverymanCreateManyVeiculeInputEnvelope = {
    data: Enumerable<veicule_deliverymanCreateManyVeiculeInput>
    skipDuplicates?: boolean
  }

  export type veicule_deliverymanUpsertWithWhereUniqueWithoutVeiculeInput = {
    where: veicule_deliverymanWhereUniqueInput
    update: XOR<veicule_deliverymanUpdateWithoutVeiculeInput, veicule_deliverymanUncheckedUpdateWithoutVeiculeInput>
    create: XOR<veicule_deliverymanCreateWithoutVeiculeInput, veicule_deliverymanUncheckedCreateWithoutVeiculeInput>
  }

  export type veicule_deliverymanUpdateWithWhereUniqueWithoutVeiculeInput = {
    where: veicule_deliverymanWhereUniqueInput
    data: XOR<veicule_deliverymanUpdateWithoutVeiculeInput, veicule_deliverymanUncheckedUpdateWithoutVeiculeInput>
  }

  export type veicule_deliverymanUpdateManyWithWhereWithoutVeiculeInput = {
    where: veicule_deliverymanScalarWhereInput
    data: XOR<veicule_deliverymanUpdateManyMutationInput, veicule_deliverymanUncheckedUpdateManyWithoutVeicule_deliverymanInput>
  }

  export type imageCreateWithoutImage_of_productInput = {
    uri: string
    created_at?: Date | string
    updated_at?: Date | string
    category_of_product?: category_of_productCreateNestedManyWithoutImageInput
    fair?: fairCreateNestedOneWithoutImageInput
  }

  export type imageUncheckedCreateWithoutImage_of_productInput = {
    id?: number
    uri: string
    created_at?: Date | string
    updated_at?: Date | string
    fairId?: number | null
    category_of_product?: category_of_productUncheckedCreateNestedManyWithoutImageInput
  }

  export type imageCreateOrConnectWithoutImage_of_productInput = {
    where: imageWhereUniqueInput
    create: XOR<imageCreateWithoutImage_of_productInput, imageUncheckedCreateWithoutImage_of_productInput>
  }

  export type productCreateWithoutImage_of_productInput = {
    name: string
    price: number
    quantity?: number | null
    review?: number
    active_for_selling?: boolean
    available_quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    description: string
    category_of_product: category_of_productCreateNestedOneWithoutProductInput
    marketer: marketerCreateNestedOneWithoutProductsInput
    type_of_price: type_of_priceCreateNestedOneWithoutProductInput
    products_in_shopping_list?: products_in_shopping_listCreateNestedManyWithoutProductInput
    sale_off?: sale_offCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutImage_of_productInput = {
    id?: number
    name: string
    price: number
    quantity?: number | null
    review?: number
    active_for_selling?: boolean
    available_quantity: number
    marketerId: number
    created_at?: Date | string
    updated_at?: Date | string
    description: string
    category_of_productId: number
    type_of_productId: number
    products_in_shopping_list?: products_in_shopping_listUncheckedCreateNestedManyWithoutProductInput
    sale_off?: sale_offUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutImage_of_productInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutImage_of_productInput, productUncheckedCreateWithoutImage_of_productInput>
  }

  export type imageUpsertWithoutImage_of_productInput = {
    update: XOR<imageUpdateWithoutImage_of_productInput, imageUncheckedUpdateWithoutImage_of_productInput>
    create: XOR<imageCreateWithoutImage_of_productInput, imageUncheckedCreateWithoutImage_of_productInput>
  }

  export type imageUpdateWithoutImage_of_productInput = {
    uri?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_of_product?: category_of_productUpdateManyWithoutImageNestedInput
    fair?: fairUpdateOneWithoutImageNestedInput
  }

  export type imageUncheckedUpdateWithoutImage_of_productInput = {
    id?: IntFieldUpdateOperationsInput | number
    uri?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fairId?: NullableIntFieldUpdateOperationsInput | number | null
    category_of_product?: category_of_productUncheckedUpdateManyWithoutImageNestedInput
  }

  export type productUpsertWithoutImage_of_productInput = {
    update: XOR<productUpdateWithoutImage_of_productInput, productUncheckedUpdateWithoutImage_of_productInput>
    create: XOR<productCreateWithoutImage_of_productInput, productUncheckedCreateWithoutImage_of_productInput>
  }

  export type productUpdateWithoutImage_of_productInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    review?: FloatFieldUpdateOperationsInput | number
    active_for_selling?: BoolFieldUpdateOperationsInput | boolean
    available_quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    category_of_product?: category_of_productUpdateOneRequiredWithoutProductNestedInput
    marketer?: marketerUpdateOneRequiredWithoutProductsNestedInput
    type_of_price?: type_of_priceUpdateOneRequiredWithoutProductNestedInput
    products_in_shopping_list?: products_in_shopping_listUpdateManyWithoutProductNestedInput
    sale_off?: sale_offUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutImage_of_productInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    review?: FloatFieldUpdateOperationsInput | number
    active_for_selling?: BoolFieldUpdateOperationsInput | boolean
    available_quantity?: IntFieldUpdateOperationsInput | number
    marketerId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    category_of_productId?: IntFieldUpdateOperationsInput | number
    type_of_productId?: IntFieldUpdateOperationsInput | number
    products_in_shopping_list?: products_in_shopping_listUncheckedUpdateManyWithoutProductNestedInput
    sale_off?: sale_offUncheckedUpdateManyWithoutProductNestedInput
  }

  export type category_of_productCreateWithoutImageInput = {
    name: string
    product?: productCreateNestedManyWithoutCategory_of_productInput
  }

  export type category_of_productUncheckedCreateWithoutImageInput = {
    id?: number
    name: string
    product?: productUncheckedCreateNestedManyWithoutCategory_of_productInput
  }

  export type category_of_productCreateOrConnectWithoutImageInput = {
    where: category_of_productWhereUniqueInput
    create: XOR<category_of_productCreateWithoutImageInput, category_of_productUncheckedCreateWithoutImageInput>
  }

  export type category_of_productCreateManyImageInputEnvelope = {
    data: Enumerable<category_of_productCreateManyImageInput>
    skipDuplicates?: boolean
  }

  export type fairCreateWithoutImageInput = {
    name: string
    review?: number
    created_at?: Date | string
    updated_at?: Date | string
    address: addressCreateNestedOneWithoutFairInput
    location: locationCreateNestedOneWithoutFairInput
    fair_date_hour_of_work?: fair_date_hour_of_workCreateNestedManyWithoutFairInput
    fair_marketers?: fair_marketersCreateNestedManyWithoutFairInput
  }

  export type fairUncheckedCreateWithoutImageInput = {
    name: string
    id?: number
    review?: number
    addressId: number
    created_at?: Date | string
    updated_at?: Date | string
    locationId: number
    fair_date_hour_of_work?: fair_date_hour_of_workUncheckedCreateNestedManyWithoutFairInput
    fair_marketers?: fair_marketersUncheckedCreateNestedManyWithoutFairInput
  }

  export type fairCreateOrConnectWithoutImageInput = {
    where: fairWhereUniqueInput
    create: XOR<fairCreateWithoutImageInput, fairUncheckedCreateWithoutImageInput>
  }

  export type image_of_productCreateWithoutImageInput = {
    created_at?: Date | string
    updated_at?: Date | string
    product: productCreateNestedOneWithoutImage_of_productInput
  }

  export type image_of_productUncheckedCreateWithoutImageInput = {
    id?: number
    productId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type image_of_productCreateOrConnectWithoutImageInput = {
    where: image_of_productWhereUniqueInput
    create: XOR<image_of_productCreateWithoutImageInput, image_of_productUncheckedCreateWithoutImageInput>
  }

  export type image_of_productCreateManyImageInputEnvelope = {
    data: Enumerable<image_of_productCreateManyImageInput>
    skipDuplicates?: boolean
  }

  export type category_of_productUpsertWithWhereUniqueWithoutImageInput = {
    where: category_of_productWhereUniqueInput
    update: XOR<category_of_productUpdateWithoutImageInput, category_of_productUncheckedUpdateWithoutImageInput>
    create: XOR<category_of_productCreateWithoutImageInput, category_of_productUncheckedCreateWithoutImageInput>
  }

  export type category_of_productUpdateWithWhereUniqueWithoutImageInput = {
    where: category_of_productWhereUniqueInput
    data: XOR<category_of_productUpdateWithoutImageInput, category_of_productUncheckedUpdateWithoutImageInput>
  }

  export type category_of_productUpdateManyWithWhereWithoutImageInput = {
    where: category_of_productScalarWhereInput
    data: XOR<category_of_productUpdateManyMutationInput, category_of_productUncheckedUpdateManyWithoutCategory_of_productInput>
  }

  export type category_of_productScalarWhereInput = {
    AND?: Enumerable<category_of_productScalarWhereInput>
    OR?: Enumerable<category_of_productScalarWhereInput>
    NOT?: Enumerable<category_of_productScalarWhereInput>
    id?: IntFilter | number
    imageId?: IntFilter | number
    name?: StringFilter | string
  }

  export type fairUpsertWithoutImageInput = {
    update: XOR<fairUpdateWithoutImageInput, fairUncheckedUpdateWithoutImageInput>
    create: XOR<fairCreateWithoutImageInput, fairUncheckedCreateWithoutImageInput>
  }

  export type fairUpdateWithoutImageInput = {
    name?: StringFieldUpdateOperationsInput | string
    review?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUpdateOneRequiredWithoutFairNestedInput
    location?: locationUpdateOneRequiredWithoutFairNestedInput
    fair_date_hour_of_work?: fair_date_hour_of_workUpdateManyWithoutFairNestedInput
    fair_marketers?: fair_marketersUpdateManyWithoutFairNestedInput
  }

  export type fairUncheckedUpdateWithoutImageInput = {
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    review?: FloatFieldUpdateOperationsInput | number
    addressId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: IntFieldUpdateOperationsInput | number
    fair_date_hour_of_work?: fair_date_hour_of_workUncheckedUpdateManyWithoutFairNestedInput
    fair_marketers?: fair_marketersUncheckedUpdateManyWithoutFairNestedInput
  }

  export type image_of_productUpsertWithWhereUniqueWithoutImageInput = {
    where: image_of_productWhereUniqueInput
    update: XOR<image_of_productUpdateWithoutImageInput, image_of_productUncheckedUpdateWithoutImageInput>
    create: XOR<image_of_productCreateWithoutImageInput, image_of_productUncheckedCreateWithoutImageInput>
  }

  export type image_of_productUpdateWithWhereUniqueWithoutImageInput = {
    where: image_of_productWhereUniqueInput
    data: XOR<image_of_productUpdateWithoutImageInput, image_of_productUncheckedUpdateWithoutImageInput>
  }

  export type image_of_productUpdateManyWithWhereWithoutImageInput = {
    where: image_of_productScalarWhereInput
    data: XOR<image_of_productUpdateManyMutationInput, image_of_productUncheckedUpdateManyWithoutImage_of_productInput>
  }

  export type paymentCreateWithoutPayment_methodInput = {
    status?: boolean
    details: string
    created_at?: Date | string
    updated_at?: Date | string
    order: orderCreateNestedOneWithoutPaymentInput
  }

  export type paymentUncheckedCreateWithoutPayment_methodInput = {
    id?: number
    status?: boolean
    details: string
    orderId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type paymentCreateOrConnectWithoutPayment_methodInput = {
    where: paymentWhereUniqueInput
    create: XOR<paymentCreateWithoutPayment_methodInput, paymentUncheckedCreateWithoutPayment_methodInput>
  }

  export type paymentCreateManyPayment_methodInputEnvelope = {
    data: Enumerable<paymentCreateManyPayment_methodInput>
    skipDuplicates?: boolean
  }

  export type paymentUpsertWithWhereUniqueWithoutPayment_methodInput = {
    where: paymentWhereUniqueInput
    update: XOR<paymentUpdateWithoutPayment_methodInput, paymentUncheckedUpdateWithoutPayment_methodInput>
    create: XOR<paymentCreateWithoutPayment_methodInput, paymentUncheckedCreateWithoutPayment_methodInput>
  }

  export type paymentUpdateWithWhereUniqueWithoutPayment_methodInput = {
    where: paymentWhereUniqueInput
    data: XOR<paymentUpdateWithoutPayment_methodInput, paymentUncheckedUpdateWithoutPayment_methodInput>
  }

  export type paymentUpdateManyWithWhereWithoutPayment_methodInput = {
    where: paymentScalarWhereInput
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyWithoutPaymentInput>
  }

  export type paymentScalarWhereInput = {
    AND?: Enumerable<paymentScalarWhereInput>
    OR?: Enumerable<paymentScalarWhereInput>
    NOT?: Enumerable<paymentScalarWhereInput>
    id?: IntFilter | number
    status?: BoolFilter | boolean
    details?: StringFilter | string
    payment_methodId?: IntFilter | number
    orderId?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
  }

  export type date_and_hour_of_workCreateWithoutFair_date_hour_of_workInput = {
    open_datetime: Date | string
    close_datetime: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    day_of_week: day_of_weekCreateNestedOneWithoutDate_and_hour_of_workInput
  }

  export type date_and_hour_of_workUncheckedCreateWithoutFair_date_hour_of_workInput = {
    id?: number
    open_datetime: Date | string
    close_datetime: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    day_of_weekId: number
  }

  export type date_and_hour_of_workCreateOrConnectWithoutFair_date_hour_of_workInput = {
    where: date_and_hour_of_workWhereUniqueInput
    create: XOR<date_and_hour_of_workCreateWithoutFair_date_hour_of_workInput, date_and_hour_of_workUncheckedCreateWithoutFair_date_hour_of_workInput>
  }

  export type fairCreateWithoutFair_date_hour_of_workInput = {
    name: string
    review?: number
    created_at?: Date | string
    updated_at?: Date | string
    address: addressCreateNestedOneWithoutFairInput
    location: locationCreateNestedOneWithoutFairInput
    fair_marketers?: fair_marketersCreateNestedManyWithoutFairInput
    image?: imageCreateNestedManyWithoutFairInput
  }

  export type fairUncheckedCreateWithoutFair_date_hour_of_workInput = {
    name: string
    id?: number
    review?: number
    addressId: number
    created_at?: Date | string
    updated_at?: Date | string
    locationId: number
    fair_marketers?: fair_marketersUncheckedCreateNestedManyWithoutFairInput
    image?: imageUncheckedCreateNestedManyWithoutFairInput
  }

  export type fairCreateOrConnectWithoutFair_date_hour_of_workInput = {
    where: fairWhereUniqueInput
    create: XOR<fairCreateWithoutFair_date_hour_of_workInput, fairUncheckedCreateWithoutFair_date_hour_of_workInput>
  }

  export type date_and_hour_of_workUpsertWithoutFair_date_hour_of_workInput = {
    update: XOR<date_and_hour_of_workUpdateWithoutFair_date_hour_of_workInput, date_and_hour_of_workUncheckedUpdateWithoutFair_date_hour_of_workInput>
    create: XOR<date_and_hour_of_workCreateWithoutFair_date_hour_of_workInput, date_and_hour_of_workUncheckedCreateWithoutFair_date_hour_of_workInput>
  }

  export type date_and_hour_of_workUpdateWithoutFair_date_hour_of_workInput = {
    open_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    close_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    day_of_week?: day_of_weekUpdateOneRequiredWithoutDate_and_hour_of_workNestedInput
  }

  export type date_and_hour_of_workUncheckedUpdateWithoutFair_date_hour_of_workInput = {
    id?: IntFieldUpdateOperationsInput | number
    open_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    close_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    day_of_weekId?: IntFieldUpdateOperationsInput | number
  }

  export type fairUpsertWithoutFair_date_hour_of_workInput = {
    update: XOR<fairUpdateWithoutFair_date_hour_of_workInput, fairUncheckedUpdateWithoutFair_date_hour_of_workInput>
    create: XOR<fairCreateWithoutFair_date_hour_of_workInput, fairUncheckedCreateWithoutFair_date_hour_of_workInput>
  }

  export type fairUpdateWithoutFair_date_hour_of_workInput = {
    name?: StringFieldUpdateOperationsInput | string
    review?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUpdateOneRequiredWithoutFairNestedInput
    location?: locationUpdateOneRequiredWithoutFairNestedInput
    fair_marketers?: fair_marketersUpdateManyWithoutFairNestedInput
    image?: imageUpdateManyWithoutFairNestedInput
  }

  export type fairUncheckedUpdateWithoutFair_date_hour_of_workInput = {
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    review?: FloatFieldUpdateOperationsInput | number
    addressId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    locationId?: IntFieldUpdateOperationsInput | number
    fair_marketers?: fair_marketersUncheckedUpdateManyWithoutFairNestedInput
    image?: imageUncheckedUpdateManyWithoutFairNestedInput
  }

  export type day_of_weekCreateWithoutDate_and_hour_of_workInput = {
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type day_of_weekUncheckedCreateWithoutDate_and_hour_of_workInput = {
    id?: number
    name: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type day_of_weekCreateOrConnectWithoutDate_and_hour_of_workInput = {
    where: day_of_weekWhereUniqueInput
    create: XOR<day_of_weekCreateWithoutDate_and_hour_of_workInput, day_of_weekUncheckedCreateWithoutDate_and_hour_of_workInput>
  }

  export type fair_date_hour_of_workCreateWithoutDatesInput = {
    created_at?: Date | string
    updated_at?: Date | string
    fair: fairCreateNestedOneWithoutFair_date_hour_of_workInput
  }

  export type fair_date_hour_of_workUncheckedCreateWithoutDatesInput = {
    id?: number
    fairId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type fair_date_hour_of_workCreateOrConnectWithoutDatesInput = {
    where: fair_date_hour_of_workWhereUniqueInput
    create: XOR<fair_date_hour_of_workCreateWithoutDatesInput, fair_date_hour_of_workUncheckedCreateWithoutDatesInput>
  }

  export type fair_date_hour_of_workCreateManyDatesInputEnvelope = {
    data: Enumerable<fair_date_hour_of_workCreateManyDatesInput>
    skipDuplicates?: boolean
  }

  export type day_of_weekUpsertWithoutDate_and_hour_of_workInput = {
    update: XOR<day_of_weekUpdateWithoutDate_and_hour_of_workInput, day_of_weekUncheckedUpdateWithoutDate_and_hour_of_workInput>
    create: XOR<day_of_weekCreateWithoutDate_and_hour_of_workInput, day_of_weekUncheckedCreateWithoutDate_and_hour_of_workInput>
  }

  export type day_of_weekUpdateWithoutDate_and_hour_of_workInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type day_of_weekUncheckedUpdateWithoutDate_and_hour_of_workInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fair_date_hour_of_workUpsertWithWhereUniqueWithoutDatesInput = {
    where: fair_date_hour_of_workWhereUniqueInput
    update: XOR<fair_date_hour_of_workUpdateWithoutDatesInput, fair_date_hour_of_workUncheckedUpdateWithoutDatesInput>
    create: XOR<fair_date_hour_of_workCreateWithoutDatesInput, fair_date_hour_of_workUncheckedCreateWithoutDatesInput>
  }

  export type fair_date_hour_of_workUpdateWithWhereUniqueWithoutDatesInput = {
    where: fair_date_hour_of_workWhereUniqueInput
    data: XOR<fair_date_hour_of_workUpdateWithoutDatesInput, fair_date_hour_of_workUncheckedUpdateWithoutDatesInput>
  }

  export type fair_date_hour_of_workUpdateManyWithWhereWithoutDatesInput = {
    where: fair_date_hour_of_workScalarWhereInput
    data: XOR<fair_date_hour_of_workUpdateManyMutationInput, fair_date_hour_of_workUncheckedUpdateManyWithoutFair_date_hour_of_workInput>
  }

  export type date_and_hour_of_workCreateWithoutDay_of_weekInput = {
    open_datetime: Date | string
    close_datetime: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    fair_date_hour_of_work?: fair_date_hour_of_workCreateNestedManyWithoutDatesInput
  }

  export type date_and_hour_of_workUncheckedCreateWithoutDay_of_weekInput = {
    id?: number
    open_datetime: Date | string
    close_datetime: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    fair_date_hour_of_work?: fair_date_hour_of_workUncheckedCreateNestedManyWithoutDatesInput
  }

  export type date_and_hour_of_workCreateOrConnectWithoutDay_of_weekInput = {
    where: date_and_hour_of_workWhereUniqueInput
    create: XOR<date_and_hour_of_workCreateWithoutDay_of_weekInput, date_and_hour_of_workUncheckedCreateWithoutDay_of_weekInput>
  }

  export type date_and_hour_of_workCreateManyDay_of_weekInputEnvelope = {
    data: Enumerable<date_and_hour_of_workCreateManyDay_of_weekInput>
    skipDuplicates?: boolean
  }

  export type date_and_hour_of_workUpsertWithWhereUniqueWithoutDay_of_weekInput = {
    where: date_and_hour_of_workWhereUniqueInput
    update: XOR<date_and_hour_of_workUpdateWithoutDay_of_weekInput, date_and_hour_of_workUncheckedUpdateWithoutDay_of_weekInput>
    create: XOR<date_and_hour_of_workCreateWithoutDay_of_weekInput, date_and_hour_of_workUncheckedCreateWithoutDay_of_weekInput>
  }

  export type date_and_hour_of_workUpdateWithWhereUniqueWithoutDay_of_weekInput = {
    where: date_and_hour_of_workWhereUniqueInput
    data: XOR<date_and_hour_of_workUpdateWithoutDay_of_weekInput, date_and_hour_of_workUncheckedUpdateWithoutDay_of_weekInput>
  }

  export type date_and_hour_of_workUpdateManyWithWhereWithoutDay_of_weekInput = {
    where: date_and_hour_of_workScalarWhereInput
    data: XOR<date_and_hour_of_workUpdateManyMutationInput, date_and_hour_of_workUncheckedUpdateManyWithoutDate_and_hour_of_workInput>
  }

  export type date_and_hour_of_workScalarWhereInput = {
    AND?: Enumerable<date_and_hour_of_workScalarWhereInput>
    OR?: Enumerable<date_and_hour_of_workScalarWhereInput>
    NOT?: Enumerable<date_and_hour_of_workScalarWhereInput>
    id?: IntFilter | number
    open_datetime?: DateTimeFilter | Date | string
    close_datetime?: DateTimeFilter | Date | string
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    day_of_weekId?: IntFilter | number
  }

  export type costumerCreateWithoutGenderInput = {
    name: string
    email: string
    password_hash: string
    picture_uri?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    birthday: string
    cpf?: string | null
    costumer_addresses?: costumer_addressesCreateNestedManyWithoutCostumerInput
    shopping_lists?: shopping_listCreateNestedManyWithoutCostumerInput
  }

  export type costumerUncheckedCreateWithoutGenderInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    picture_uri?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    birthday: string
    cpf?: string | null
    costumer_addresses?: costumer_addressesUncheckedCreateNestedManyWithoutCostumerInput
    shopping_lists?: shopping_listUncheckedCreateNestedManyWithoutCostumerInput
  }

  export type costumerCreateOrConnectWithoutGenderInput = {
    where: costumerWhereUniqueInput
    create: XOR<costumerCreateWithoutGenderInput, costumerUncheckedCreateWithoutGenderInput>
  }

  export type costumerCreateManyGenderInputEnvelope = {
    data: Enumerable<costumerCreateManyGenderInput>
    skipDuplicates?: boolean
  }

  export type deliverymanCreateWithoutGenderInput = {
    name: string
    email: string
    password_hash: string
    picture_uri: string
    online?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    birthday: string
    location: locationCreateNestedOneWithoutDeliverymanInput
    order?: orderCreateNestedManyWithoutDeliverymanInput
    veicule_deliveryman?: veicule_deliverymanCreateNestedManyWithoutOwnerInput
  }

  export type deliverymanUncheckedCreateWithoutGenderInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    picture_uri: string
    locationId: number
    online?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    birthday: string
    order?: orderUncheckedCreateNestedManyWithoutDeliverymanInput
    veicule_deliveryman?: veicule_deliverymanUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type deliverymanCreateOrConnectWithoutGenderInput = {
    where: deliverymanWhereUniqueInput
    create: XOR<deliverymanCreateWithoutGenderInput, deliverymanUncheckedCreateWithoutGenderInput>
  }

  export type deliverymanCreateManyGenderInputEnvelope = {
    data: Enumerable<deliverymanCreateManyGenderInput>
    skipDuplicates?: boolean
  }

  export type marketerCreateWithoutGenderInput = {
    name: string
    email: string
    password_hash: string
    picture_uri?: string | null
    review?: number
    online?: boolean
    created_at?: Date | string
    birthday: string
    updated_at?: Date | string
    cnpj?: string | null
    cpf?: string | null
    phone: string
    tent_name: string
    fair_marketers?: fair_marketersCreateNestedManyWithoutMarketerInput
    location: locationCreateNestedOneWithoutMarketerInput
    products?: productCreateNestedManyWithoutMarketerInput
  }

  export type marketerUncheckedCreateWithoutGenderInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    picture_uri?: string | null
    review?: number
    online?: boolean
    locationId: number
    created_at?: Date | string
    birthday: string
    updated_at?: Date | string
    cnpj?: string | null
    cpf?: string | null
    phone: string
    tent_name: string
    fair_marketers?: fair_marketersUncheckedCreateNestedManyWithoutMarketerInput
    products?: productUncheckedCreateNestedManyWithoutMarketerInput
  }

  export type marketerCreateOrConnectWithoutGenderInput = {
    where: marketerWhereUniqueInput
    create: XOR<marketerCreateWithoutGenderInput, marketerUncheckedCreateWithoutGenderInput>
  }

  export type marketerCreateManyGenderInputEnvelope = {
    data: Enumerable<marketerCreateManyGenderInput>
    skipDuplicates?: boolean
  }

  export type costumerUpsertWithWhereUniqueWithoutGenderInput = {
    where: costumerWhereUniqueInput
    update: XOR<costumerUpdateWithoutGenderInput, costumerUncheckedUpdateWithoutGenderInput>
    create: XOR<costumerCreateWithoutGenderInput, costumerUncheckedCreateWithoutGenderInput>
  }

  export type costumerUpdateWithWhereUniqueWithoutGenderInput = {
    where: costumerWhereUniqueInput
    data: XOR<costumerUpdateWithoutGenderInput, costumerUncheckedUpdateWithoutGenderInput>
  }

  export type costumerUpdateManyWithWhereWithoutGenderInput = {
    where: costumerScalarWhereInput
    data: XOR<costumerUpdateManyMutationInput, costumerUncheckedUpdateManyWithoutCostumerInput>
  }

  export type costumerScalarWhereInput = {
    AND?: Enumerable<costumerScalarWhereInput>
    OR?: Enumerable<costumerScalarWhereInput>
    NOT?: Enumerable<costumerScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    email?: StringFilter | string
    password_hash?: StringFilter | string
    picture_uri?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    genderId?: IntFilter | number
    birthday?: StringFilter | string
    cpf?: StringNullableFilter | string | null
  }

  export type deliverymanUpsertWithWhereUniqueWithoutGenderInput = {
    where: deliverymanWhereUniqueInput
    update: XOR<deliverymanUpdateWithoutGenderInput, deliverymanUncheckedUpdateWithoutGenderInput>
    create: XOR<deliverymanCreateWithoutGenderInput, deliverymanUncheckedCreateWithoutGenderInput>
  }

  export type deliverymanUpdateWithWhereUniqueWithoutGenderInput = {
    where: deliverymanWhereUniqueInput
    data: XOR<deliverymanUpdateWithoutGenderInput, deliverymanUncheckedUpdateWithoutGenderInput>
  }

  export type deliverymanUpdateManyWithWhereWithoutGenderInput = {
    where: deliverymanScalarWhereInput
    data: XOR<deliverymanUpdateManyMutationInput, deliverymanUncheckedUpdateManyWithoutDeliverymanInput>
  }

  export type deliverymanScalarWhereInput = {
    AND?: Enumerable<deliverymanScalarWhereInput>
    OR?: Enumerable<deliverymanScalarWhereInput>
    NOT?: Enumerable<deliverymanScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    email?: StringFilter | string
    password_hash?: StringFilter | string
    picture_uri?: StringFilter | string
    locationId?: IntFilter | number
    online?: BoolFilter | boolean
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeFilter | Date | string
    genderId?: IntFilter | number
    birthday?: StringFilter | string
  }

  export type marketerUpsertWithWhereUniqueWithoutGenderInput = {
    where: marketerWhereUniqueInput
    update: XOR<marketerUpdateWithoutGenderInput, marketerUncheckedUpdateWithoutGenderInput>
    create: XOR<marketerCreateWithoutGenderInput, marketerUncheckedCreateWithoutGenderInput>
  }

  export type marketerUpdateWithWhereUniqueWithoutGenderInput = {
    where: marketerWhereUniqueInput
    data: XOR<marketerUpdateWithoutGenderInput, marketerUncheckedUpdateWithoutGenderInput>
  }

  export type marketerUpdateManyWithWhereWithoutGenderInput = {
    where: marketerScalarWhereInput
    data: XOR<marketerUpdateManyMutationInput, marketerUncheckedUpdateManyWithoutMarketerInput>
  }

  export type marketerScalarWhereInput = {
    AND?: Enumerable<marketerScalarWhereInput>
    OR?: Enumerable<marketerScalarWhereInput>
    NOT?: Enumerable<marketerScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    email?: StringFilter | string
    password_hash?: StringFilter | string
    picture_uri?: StringNullableFilter | string | null
    review?: FloatFilter | number
    online?: BoolFilter | boolean
    locationId?: IntFilter | number
    created_at?: DateTimeFilter | Date | string
    birthday?: StringFilter | string
    updated_at?: DateTimeFilter | Date | string
    genderId?: IntFilter | number
    cnpj?: StringNullableFilter | string | null
    cpf?: StringNullableFilter | string | null
    phone?: StringFilter | string
    tent_name?: StringFilter | string
  }

  export type addressCreateWithoutCityInput = {
    cep: string
    logradouro: string
    number: number
    created_at?: Date | string
    updated_at?: Date | string
    complemento: string
    type: address_typeCreateNestedOneWithoutAddressInput
    location: locationCreateNestedOneWithoutAddressInput
    neighborhood: neighborhoodCreateNestedOneWithoutAddressInput
    uf: ufCreateNestedOneWithoutAddressInput
    costumer_addresses?: costumer_addressesCreateNestedManyWithoutAddressInput
    fair?: fairCreateNestedOneWithoutAddressInput
  }

  export type addressUncheckedCreateWithoutCityInput = {
    id?: number
    cep: string
    logradouro: string
    number: number
    created_at?: Date | string
    updated_at?: Date | string
    address_typeId: number
    complemento: string
    uFId: number
    neighborhoodId: number
    locationId: number
    costumer_addresses?: costumer_addressesUncheckedCreateNestedManyWithoutAddressInput
    fair?: fairUncheckedCreateNestedOneWithoutAddressInput
  }

  export type addressCreateOrConnectWithoutCityInput = {
    where: addressWhereUniqueInput
    create: XOR<addressCreateWithoutCityInput, addressUncheckedCreateWithoutCityInput>
  }

  export type addressCreateManyCityInputEnvelope = {
    data: Enumerable<addressCreateManyCityInput>
    skipDuplicates?: boolean
  }

  export type addressUpsertWithWhereUniqueWithoutCityInput = {
    where: addressWhereUniqueInput
    update: XOR<addressUpdateWithoutCityInput, addressUncheckedUpdateWithoutCityInput>
    create: XOR<addressCreateWithoutCityInput, addressUncheckedCreateWithoutCityInput>
  }

  export type addressUpdateWithWhereUniqueWithoutCityInput = {
    where: addressWhereUniqueInput
    data: XOR<addressUpdateWithoutCityInput, addressUncheckedUpdateWithoutCityInput>
  }

  export type addressUpdateManyWithWhereWithoutCityInput = {
    where: addressScalarWhereInput
    data: XOR<addressUpdateManyMutationInput, addressUncheckedUpdateManyWithoutAddressInput>
  }

  export type addressCreateWithoutNeighborhoodInput = {
    cep: string
    logradouro: string
    number: number
    created_at?: Date | string
    updated_at?: Date | string
    complemento: string
    type: address_typeCreateNestedOneWithoutAddressInput
    city: cityCreateNestedOneWithoutAddressInput
    location: locationCreateNestedOneWithoutAddressInput
    uf: ufCreateNestedOneWithoutAddressInput
    costumer_addresses?: costumer_addressesCreateNestedManyWithoutAddressInput
    fair?: fairCreateNestedOneWithoutAddressInput
  }

  export type addressUncheckedCreateWithoutNeighborhoodInput = {
    id?: number
    cep: string
    logradouro: string
    number: number
    created_at?: Date | string
    updated_at?: Date | string
    address_typeId: number
    complemento: string
    cityId: number
    uFId: number
    locationId: number
    costumer_addresses?: costumer_addressesUncheckedCreateNestedManyWithoutAddressInput
    fair?: fairUncheckedCreateNestedOneWithoutAddressInput
  }

  export type addressCreateOrConnectWithoutNeighborhoodInput = {
    where: addressWhereUniqueInput
    create: XOR<addressCreateWithoutNeighborhoodInput, addressUncheckedCreateWithoutNeighborhoodInput>
  }

  export type addressCreateManyNeighborhoodInputEnvelope = {
    data: Enumerable<addressCreateManyNeighborhoodInput>
    skipDuplicates?: boolean
  }

  export type addressUpsertWithWhereUniqueWithoutNeighborhoodInput = {
    where: addressWhereUniqueInput
    update: XOR<addressUpdateWithoutNeighborhoodInput, addressUncheckedUpdateWithoutNeighborhoodInput>
    create: XOR<addressCreateWithoutNeighborhoodInput, addressUncheckedCreateWithoutNeighborhoodInput>
  }

  export type addressUpdateWithWhereUniqueWithoutNeighborhoodInput = {
    where: addressWhereUniqueInput
    data: XOR<addressUpdateWithoutNeighborhoodInput, addressUncheckedUpdateWithoutNeighborhoodInput>
  }

  export type addressUpdateManyWithWhereWithoutNeighborhoodInput = {
    where: addressScalarWhereInput
    data: XOR<addressUpdateManyMutationInput, addressUncheckedUpdateManyWithoutAddressInput>
  }

  export type addressCreateWithoutUfInput = {
    cep: string
    logradouro: string
    number: number
    created_at?: Date | string
    updated_at?: Date | string
    complemento: string
    type: address_typeCreateNestedOneWithoutAddressInput
    city: cityCreateNestedOneWithoutAddressInput
    location: locationCreateNestedOneWithoutAddressInput
    neighborhood: neighborhoodCreateNestedOneWithoutAddressInput
    costumer_addresses?: costumer_addressesCreateNestedManyWithoutAddressInput
    fair?: fairCreateNestedOneWithoutAddressInput
  }

  export type addressUncheckedCreateWithoutUfInput = {
    id?: number
    cep: string
    logradouro: string
    number: number
    created_at?: Date | string
    updated_at?: Date | string
    address_typeId: number
    complemento: string
    cityId: number
    neighborhoodId: number
    locationId: number
    costumer_addresses?: costumer_addressesUncheckedCreateNestedManyWithoutAddressInput
    fair?: fairUncheckedCreateNestedOneWithoutAddressInput
  }

  export type addressCreateOrConnectWithoutUfInput = {
    where: addressWhereUniqueInput
    create: XOR<addressCreateWithoutUfInput, addressUncheckedCreateWithoutUfInput>
  }

  export type addressCreateManyUfInputEnvelope = {
    data: Enumerable<addressCreateManyUfInput>
    skipDuplicates?: boolean
  }

  export type addressUpsertWithWhereUniqueWithoutUfInput = {
    where: addressWhereUniqueInput
    update: XOR<addressUpdateWithoutUfInput, addressUncheckedUpdateWithoutUfInput>
    create: XOR<addressCreateWithoutUfInput, addressUncheckedCreateWithoutUfInput>
  }

  export type addressUpdateWithWhereUniqueWithoutUfInput = {
    where: addressWhereUniqueInput
    data: XOR<addressUpdateWithoutUfInput, addressUncheckedUpdateWithoutUfInput>
  }

  export type addressUpdateManyWithWhereWithoutUfInput = {
    where: addressScalarWhereInput
    data: XOR<addressUpdateManyMutationInput, addressUncheckedUpdateManyWithoutAddressInput>
  }

  export type imageCreateWithoutCategory_of_productInput = {
    uri: string
    created_at?: Date | string
    updated_at?: Date | string
    fair?: fairCreateNestedOneWithoutImageInput
    image_of_product?: image_of_productCreateNestedManyWithoutImageInput
  }

  export type imageUncheckedCreateWithoutCategory_of_productInput = {
    id?: number
    uri: string
    created_at?: Date | string
    updated_at?: Date | string
    fairId?: number | null
    image_of_product?: image_of_productUncheckedCreateNestedManyWithoutImageInput
  }

  export type imageCreateOrConnectWithoutCategory_of_productInput = {
    where: imageWhereUniqueInput
    create: XOR<imageCreateWithoutCategory_of_productInput, imageUncheckedCreateWithoutCategory_of_productInput>
  }

  export type productCreateWithoutCategory_of_productInput = {
    name: string
    price: number
    quantity?: number | null
    review?: number
    active_for_selling?: boolean
    available_quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    description: string
    image_of_product?: image_of_productCreateNestedManyWithoutProductInput
    marketer: marketerCreateNestedOneWithoutProductsInput
    type_of_price: type_of_priceCreateNestedOneWithoutProductInput
    products_in_shopping_list?: products_in_shopping_listCreateNestedManyWithoutProductInput
    sale_off?: sale_offCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutCategory_of_productInput = {
    id?: number
    name: string
    price: number
    quantity?: number | null
    review?: number
    active_for_selling?: boolean
    available_quantity: number
    marketerId: number
    created_at?: Date | string
    updated_at?: Date | string
    description: string
    type_of_productId: number
    image_of_product?: image_of_productUncheckedCreateNestedManyWithoutProductInput
    products_in_shopping_list?: products_in_shopping_listUncheckedCreateNestedManyWithoutProductInput
    sale_off?: sale_offUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutCategory_of_productInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutCategory_of_productInput, productUncheckedCreateWithoutCategory_of_productInput>
  }

  export type productCreateManyCategory_of_productInputEnvelope = {
    data: Enumerable<productCreateManyCategory_of_productInput>
    skipDuplicates?: boolean
  }

  export type imageUpsertWithoutCategory_of_productInput = {
    update: XOR<imageUpdateWithoutCategory_of_productInput, imageUncheckedUpdateWithoutCategory_of_productInput>
    create: XOR<imageCreateWithoutCategory_of_productInput, imageUncheckedCreateWithoutCategory_of_productInput>
  }

  export type imageUpdateWithoutCategory_of_productInput = {
    uri?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fair?: fairUpdateOneWithoutImageNestedInput
    image_of_product?: image_of_productUpdateManyWithoutImageNestedInput
  }

  export type imageUncheckedUpdateWithoutCategory_of_productInput = {
    id?: IntFieldUpdateOperationsInput | number
    uri?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fairId?: NullableIntFieldUpdateOperationsInput | number | null
    image_of_product?: image_of_productUncheckedUpdateManyWithoutImageNestedInput
  }

  export type productUpsertWithWhereUniqueWithoutCategory_of_productInput = {
    where: productWhereUniqueInput
    update: XOR<productUpdateWithoutCategory_of_productInput, productUncheckedUpdateWithoutCategory_of_productInput>
    create: XOR<productCreateWithoutCategory_of_productInput, productUncheckedCreateWithoutCategory_of_productInput>
  }

  export type productUpdateWithWhereUniqueWithoutCategory_of_productInput = {
    where: productWhereUniqueInput
    data: XOR<productUpdateWithoutCategory_of_productInput, productUncheckedUpdateWithoutCategory_of_productInput>
  }

  export type productUpdateManyWithWhereWithoutCategory_of_productInput = {
    where: productScalarWhereInput
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyWithoutProductInput>
  }

  export type productCreateWithoutSale_offInput = {
    name: string
    price: number
    quantity?: number | null
    review?: number
    active_for_selling?: boolean
    available_quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    description: string
    image_of_product?: image_of_productCreateNestedManyWithoutProductInput
    category_of_product: category_of_productCreateNestedOneWithoutProductInput
    marketer: marketerCreateNestedOneWithoutProductsInput
    type_of_price: type_of_priceCreateNestedOneWithoutProductInput
    products_in_shopping_list?: products_in_shopping_listCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutSale_offInput = {
    id?: number
    name: string
    price: number
    quantity?: number | null
    review?: number
    active_for_selling?: boolean
    available_quantity: number
    marketerId: number
    created_at?: Date | string
    updated_at?: Date | string
    description: string
    category_of_productId: number
    type_of_productId: number
    image_of_product?: image_of_productUncheckedCreateNestedManyWithoutProductInput
    products_in_shopping_list?: products_in_shopping_listUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutSale_offInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutSale_offInput, productUncheckedCreateWithoutSale_offInput>
  }

  export type productUpsertWithoutSale_offInput = {
    update: XOR<productUpdateWithoutSale_offInput, productUncheckedUpdateWithoutSale_offInput>
    create: XOR<productCreateWithoutSale_offInput, productUncheckedCreateWithoutSale_offInput>
  }

  export type productUpdateWithoutSale_offInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    review?: FloatFieldUpdateOperationsInput | number
    active_for_selling?: BoolFieldUpdateOperationsInput | boolean
    available_quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    image_of_product?: image_of_productUpdateManyWithoutProductNestedInput
    category_of_product?: category_of_productUpdateOneRequiredWithoutProductNestedInput
    marketer?: marketerUpdateOneRequiredWithoutProductsNestedInput
    type_of_price?: type_of_priceUpdateOneRequiredWithoutProductNestedInput
    products_in_shopping_list?: products_in_shopping_listUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutSale_offInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    review?: FloatFieldUpdateOperationsInput | number
    active_for_selling?: BoolFieldUpdateOperationsInput | boolean
    available_quantity?: IntFieldUpdateOperationsInput | number
    marketerId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    category_of_productId?: IntFieldUpdateOperationsInput | number
    type_of_productId?: IntFieldUpdateOperationsInput | number
    image_of_product?: image_of_productUncheckedUpdateManyWithoutProductNestedInput
    products_in_shopping_list?: products_in_shopping_listUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productCreateWithoutType_of_priceInput = {
    name: string
    price: number
    quantity?: number | null
    review?: number
    active_for_selling?: boolean
    available_quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    description: string
    image_of_product?: image_of_productCreateNestedManyWithoutProductInput
    category_of_product: category_of_productCreateNestedOneWithoutProductInput
    marketer: marketerCreateNestedOneWithoutProductsInput
    products_in_shopping_list?: products_in_shopping_listCreateNestedManyWithoutProductInput
    sale_off?: sale_offCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutType_of_priceInput = {
    id?: number
    name: string
    price: number
    quantity?: number | null
    review?: number
    active_for_selling?: boolean
    available_quantity: number
    marketerId: number
    created_at?: Date | string
    updated_at?: Date | string
    description: string
    category_of_productId: number
    image_of_product?: image_of_productUncheckedCreateNestedManyWithoutProductInput
    products_in_shopping_list?: products_in_shopping_listUncheckedCreateNestedManyWithoutProductInput
    sale_off?: sale_offUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutType_of_priceInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutType_of_priceInput, productUncheckedCreateWithoutType_of_priceInput>
  }

  export type productCreateManyType_of_priceInputEnvelope = {
    data: Enumerable<productCreateManyType_of_priceInput>
    skipDuplicates?: boolean
  }

  export type productUpsertWithWhereUniqueWithoutType_of_priceInput = {
    where: productWhereUniqueInput
    update: XOR<productUpdateWithoutType_of_priceInput, productUncheckedUpdateWithoutType_of_priceInput>
    create: XOR<productCreateWithoutType_of_priceInput, productUncheckedCreateWithoutType_of_priceInput>
  }

  export type productUpdateWithWhereUniqueWithoutType_of_priceInput = {
    where: productWhereUniqueInput
    data: XOR<productUpdateWithoutType_of_priceInput, productUncheckedUpdateWithoutType_of_priceInput>
  }

  export type productUpdateManyWithWhereWithoutType_of_priceInput = {
    where: productScalarWhereInput
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyWithoutProductInput>
  }

  export type costumer_addressesCreateManyCostumerInput = {
    id?: number
    addressId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type shopping_listCreateManyCostumerInput = {
    id?: number
    freight?: number | null
    total: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type costumer_addressesUpdateWithoutCostumerInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUpdateOneRequiredWithoutCostumer_addressesNestedInput
    order?: orderUpdateManyWithoutCostumer_addressesNestedInput
  }

  export type costumer_addressesUncheckedUpdateWithoutCostumerInput = {
    id?: IntFieldUpdateOperationsInput | number
    addressId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: orderUncheckedUpdateManyWithoutCostumer_addressesNestedInput
  }

  export type costumer_addressesUncheckedUpdateManyWithoutCostumer_addressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    addressId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type shopping_listUpdateWithoutCostumerInput = {
    freight?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: orderUpdateOneWithoutShopping_listNestedInput
    products_in_shopping_list?: products_in_shopping_listUpdateManyWithoutShopping_listNestedInput
  }

  export type shopping_listUncheckedUpdateWithoutCostumerInput = {
    id?: IntFieldUpdateOperationsInput | number
    freight?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: orderUncheckedUpdateOneWithoutShopping_listNestedInput
    products_in_shopping_list?: products_in_shopping_listUncheckedUpdateManyWithoutShopping_listNestedInput
  }

  export type shopping_listUncheckedUpdateManyWithoutShopping_listsInput = {
    id?: IntFieldUpdateOperationsInput | number
    freight?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type orderCreateManyDeliverymanInput = {
    id?: number
    accepted_status?: boolean
    delivered_status_for_client?: boolean
    retreat_products_status?: boolean
    shopping_listId: number
    created_at?: Date | string
    updated_at?: Date | string
    costumer_addressesId: number
    intent_payment_id: string
  }

  export type veicule_deliverymanCreateManyOwnerInput = {
    id?: number
    veiculeId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type orderUpdateWithoutDeliverymanInput = {
    accepted_status?: BoolFieldUpdateOperationsInput | boolean
    delivered_status_for_client?: BoolFieldUpdateOperationsInput | boolean
    retreat_products_status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    intent_payment_id?: StringFieldUpdateOperationsInput | string
    costumer_addresses?: costumer_addressesUpdateOneRequiredWithoutOrderNestedInput
    shopping_list?: shopping_listUpdateOneRequiredWithoutOrderNestedInput
    payment?: paymentUpdateOneWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateWithoutDeliverymanInput = {
    id?: IntFieldUpdateOperationsInput | number
    accepted_status?: BoolFieldUpdateOperationsInput | boolean
    delivered_status_for_client?: BoolFieldUpdateOperationsInput | boolean
    retreat_products_status?: BoolFieldUpdateOperationsInput | boolean
    shopping_listId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    costumer_addressesId?: IntFieldUpdateOperationsInput | number
    intent_payment_id?: StringFieldUpdateOperationsInput | string
    payment?: paymentUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    accepted_status?: BoolFieldUpdateOperationsInput | boolean
    delivered_status_for_client?: BoolFieldUpdateOperationsInput | boolean
    retreat_products_status?: BoolFieldUpdateOperationsInput | boolean
    shopping_listId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    costumer_addressesId?: IntFieldUpdateOperationsInput | number
    intent_payment_id?: StringFieldUpdateOperationsInput | string
  }

  export type veicule_deliverymanUpdateWithoutOwnerInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    veicule?: veiculeUpdateOneRequiredWithoutVeicule_deliverymanNestedInput
  }

  export type veicule_deliverymanUncheckedUpdateWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    veiculeId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type veicule_deliverymanUncheckedUpdateManyWithoutVeicule_deliverymanInput = {
    id?: IntFieldUpdateOperationsInput | number
    veiculeId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type products_in_shopping_listCreateManyShopping_listInput = {
    id?: number
    productId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type products_in_shopping_listUpdateWithoutShopping_listInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productUpdateOneRequiredWithoutProducts_in_shopping_listNestedInput
  }

  export type products_in_shopping_listUncheckedUpdateWithoutShopping_listInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type products_in_shopping_listUncheckedUpdateManyWithoutProducts_in_shopping_listInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type image_of_productCreateManyProductInput = {
    id?: number
    imageId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type products_in_shopping_listCreateManyProductInput = {
    id?: number
    shopping_listId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type sale_offCreateManyProductInput = {
    id?: number
    value: number
  }

  export type image_of_productUpdateWithoutProductInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: imageUpdateOneRequiredWithoutImage_of_productNestedInput
  }

  export type image_of_productUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    imageId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type image_of_productUncheckedUpdateManyWithoutImage_of_productInput = {
    id?: IntFieldUpdateOperationsInput | number
    imageId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type products_in_shopping_listUpdateWithoutProductInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    shopping_list?: shopping_listUpdateOneRequiredWithoutProducts_in_shopping_listNestedInput
  }

  export type products_in_shopping_listUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    shopping_listId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sale_offUpdateWithoutProductInput = {
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type sale_offUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type sale_offUncheckedUpdateManyWithoutSale_offInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type fair_marketersCreateManyMarketerInput = {
    id?: number
    fairId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type productCreateManyMarketerInput = {
    id?: number
    name: string
    price: number
    quantity?: number | null
    review?: number
    active_for_selling?: boolean
    available_quantity: number
    created_at?: Date | string
    updated_at?: Date | string
    description: string
    category_of_productId: number
    type_of_productId: number
  }

  export type fair_marketersUpdateWithoutMarketerInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fair?: fairUpdateOneRequiredWithoutFair_marketersNestedInput
  }

  export type fair_marketersUncheckedUpdateWithoutMarketerInput = {
    id?: IntFieldUpdateOperationsInput | number
    fairId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fair_marketersUncheckedUpdateManyWithoutFair_marketersInput = {
    id?: IntFieldUpdateOperationsInput | number
    fairId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productUpdateWithoutMarketerInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    review?: FloatFieldUpdateOperationsInput | number
    active_for_selling?: BoolFieldUpdateOperationsInput | boolean
    available_quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    image_of_product?: image_of_productUpdateManyWithoutProductNestedInput
    category_of_product?: category_of_productUpdateOneRequiredWithoutProductNestedInput
    type_of_price?: type_of_priceUpdateOneRequiredWithoutProductNestedInput
    products_in_shopping_list?: products_in_shopping_listUpdateManyWithoutProductNestedInput
    sale_off?: sale_offUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutMarketerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    review?: FloatFieldUpdateOperationsInput | number
    active_for_selling?: BoolFieldUpdateOperationsInput | boolean
    available_quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    category_of_productId?: IntFieldUpdateOperationsInput | number
    type_of_productId?: IntFieldUpdateOperationsInput | number
    image_of_product?: image_of_productUncheckedUpdateManyWithoutProductNestedInput
    products_in_shopping_list?: products_in_shopping_listUncheckedUpdateManyWithoutProductNestedInput
    sale_off?: sale_offUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateManyWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    review?: FloatFieldUpdateOperationsInput | number
    active_for_selling?: BoolFieldUpdateOperationsInput | boolean
    available_quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    category_of_productId?: IntFieldUpdateOperationsInput | number
    type_of_productId?: IntFieldUpdateOperationsInput | number
  }

  export type fair_date_hour_of_workCreateManyFairInput = {
    id?: number
    date_and_hour_of_workId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type fair_marketersCreateManyFairInput = {
    id?: number
    marketerId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type imageCreateManyFairInput = {
    id?: number
    uri: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type fair_date_hour_of_workUpdateWithoutFairInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    dates?: date_and_hour_of_workUpdateOneRequiredWithoutFair_date_hour_of_workNestedInput
  }

  export type fair_date_hour_of_workUncheckedUpdateWithoutFairInput = {
    id?: IntFieldUpdateOperationsInput | number
    date_and_hour_of_workId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fair_date_hour_of_workUncheckedUpdateManyWithoutFair_date_hour_of_workInput = {
    id?: IntFieldUpdateOperationsInput | number
    date_and_hour_of_workId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fair_marketersUpdateWithoutFairInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    marketer?: marketerUpdateOneRequiredWithoutFair_marketersNestedInput
  }

  export type fair_marketersUncheckedUpdateWithoutFairInput = {
    id?: IntFieldUpdateOperationsInput | number
    marketerId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type imageUpdateWithoutFairInput = {
    uri?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_of_product?: category_of_productUpdateManyWithoutImageNestedInput
    image_of_product?: image_of_productUpdateManyWithoutImageNestedInput
  }

  export type imageUncheckedUpdateWithoutFairInput = {
    id?: IntFieldUpdateOperationsInput | number
    uri?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_of_product?: category_of_productUncheckedUpdateManyWithoutImageNestedInput
    image_of_product?: image_of_productUncheckedUpdateManyWithoutImageNestedInput
  }

  export type imageUncheckedUpdateManyWithoutImageInput = {
    id?: IntFieldUpdateOperationsInput | number
    uri?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type orderCreateManyCostumer_addressesInput = {
    id?: number
    accepted_status?: boolean
    delivered_status_for_client?: boolean
    retreat_products_status?: boolean
    deliverymanId?: number | null
    shopping_listId: number
    created_at?: Date | string
    updated_at?: Date | string
    intent_payment_id: string
  }

  export type orderUpdateWithoutCostumer_addressesInput = {
    accepted_status?: BoolFieldUpdateOperationsInput | boolean
    delivered_status_for_client?: BoolFieldUpdateOperationsInput | boolean
    retreat_products_status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    intent_payment_id?: StringFieldUpdateOperationsInput | string
    deliveryman?: deliverymanUpdateOneWithoutOrderNestedInput
    shopping_list?: shopping_listUpdateOneRequiredWithoutOrderNestedInput
    payment?: paymentUpdateOneWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateWithoutCostumer_addressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    accepted_status?: BoolFieldUpdateOperationsInput | boolean
    delivered_status_for_client?: BoolFieldUpdateOperationsInput | boolean
    retreat_products_status?: BoolFieldUpdateOperationsInput | boolean
    deliverymanId?: NullableIntFieldUpdateOperationsInput | number | null
    shopping_listId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    intent_payment_id?: StringFieldUpdateOperationsInput | string
    payment?: paymentUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type addressCreateManyLocationInput = {
    id?: number
    cep: string
    logradouro: string
    number: number
    created_at?: Date | string
    updated_at?: Date | string
    address_typeId: number
    complemento: string
    cityId: number
    uFId: number
    neighborhoodId: number
  }

  export type fairCreateManyLocationInput = {
    name: string
    id?: number
    review?: number
    addressId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type addressUpdateWithoutLocationInput = {
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    complemento?: StringFieldUpdateOperationsInput | string
    type?: address_typeUpdateOneRequiredWithoutAddressNestedInput
    city?: cityUpdateOneRequiredWithoutAddressNestedInput
    neighborhood?: neighborhoodUpdateOneRequiredWithoutAddressNestedInput
    uf?: ufUpdateOneRequiredWithoutAddressNestedInput
    costumer_addresses?: costumer_addressesUpdateManyWithoutAddressNestedInput
    fair?: fairUpdateOneWithoutAddressNestedInput
  }

  export type addressUncheckedUpdateWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address_typeId?: IntFieldUpdateOperationsInput | number
    complemento?: StringFieldUpdateOperationsInput | string
    cityId?: IntFieldUpdateOperationsInput | number
    uFId?: IntFieldUpdateOperationsInput | number
    neighborhoodId?: IntFieldUpdateOperationsInput | number
    costumer_addresses?: costumer_addressesUncheckedUpdateManyWithoutAddressNestedInput
    fair?: fairUncheckedUpdateOneWithoutAddressNestedInput
  }

  export type addressUncheckedUpdateManyWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address_typeId?: IntFieldUpdateOperationsInput | number
    complemento?: StringFieldUpdateOperationsInput | string
    cityId?: IntFieldUpdateOperationsInput | number
    uFId?: IntFieldUpdateOperationsInput | number
    neighborhoodId?: IntFieldUpdateOperationsInput | number
  }

  export type fairUpdateWithoutLocationInput = {
    name?: StringFieldUpdateOperationsInput | string
    review?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: addressUpdateOneRequiredWithoutFairNestedInput
    fair_date_hour_of_work?: fair_date_hour_of_workUpdateManyWithoutFairNestedInput
    fair_marketers?: fair_marketersUpdateManyWithoutFairNestedInput
    image?: imageUpdateManyWithoutFairNestedInput
  }

  export type fairUncheckedUpdateWithoutLocationInput = {
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    review?: FloatFieldUpdateOperationsInput | number
    addressId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fair_date_hour_of_work?: fair_date_hour_of_workUncheckedUpdateManyWithoutFairNestedInput
    fair_marketers?: fair_marketersUncheckedUpdateManyWithoutFairNestedInput
    image?: imageUncheckedUpdateManyWithoutFairNestedInput
  }

  export type fairUncheckedUpdateManyWithoutFairInput = {
    name?: StringFieldUpdateOperationsInput | string
    id?: IntFieldUpdateOperationsInput | number
    review?: FloatFieldUpdateOperationsInput | number
    addressId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type costumer_addressesCreateManyAddressInput = {
    id?: number
    costumerId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type costumer_addressesUpdateWithoutAddressInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    costumer?: costumerUpdateOneRequiredWithoutCostumer_addressesNestedInput
    order?: orderUpdateManyWithoutCostumer_addressesNestedInput
  }

  export type costumer_addressesUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    costumerId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: orderUncheckedUpdateManyWithoutCostumer_addressesNestedInput
  }

  export type addressCreateManyTypeInput = {
    id?: number
    cep: string
    logradouro: string
    number: number
    created_at?: Date | string
    updated_at?: Date | string
    complemento: string
    cityId: number
    uFId: number
    neighborhoodId: number
    locationId: number
  }

  export type addressUpdateWithoutTypeInput = {
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    complemento?: StringFieldUpdateOperationsInput | string
    city?: cityUpdateOneRequiredWithoutAddressNestedInput
    location?: locationUpdateOneRequiredWithoutAddressNestedInput
    neighborhood?: neighborhoodUpdateOneRequiredWithoutAddressNestedInput
    uf?: ufUpdateOneRequiredWithoutAddressNestedInput
    costumer_addresses?: costumer_addressesUpdateManyWithoutAddressNestedInput
    fair?: fairUpdateOneWithoutAddressNestedInput
  }

  export type addressUncheckedUpdateWithoutTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    complemento?: StringFieldUpdateOperationsInput | string
    cityId?: IntFieldUpdateOperationsInput | number
    uFId?: IntFieldUpdateOperationsInput | number
    neighborhoodId?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    costumer_addresses?: costumer_addressesUncheckedUpdateManyWithoutAddressNestedInput
    fair?: fairUncheckedUpdateOneWithoutAddressNestedInput
  }

  export type veicule_deliverymanCreateManyVeiculeInput = {
    id?: number
    deliverymanId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type veicule_deliverymanUpdateWithoutVeiculeInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: deliverymanUpdateOneRequiredWithoutVeicule_deliverymanNestedInput
  }

  export type veicule_deliverymanUncheckedUpdateWithoutVeiculeInput = {
    id?: IntFieldUpdateOperationsInput | number
    deliverymanId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type category_of_productCreateManyImageInput = {
    id?: number
    name: string
  }

  export type image_of_productCreateManyImageInput = {
    id?: number
    productId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type category_of_productUpdateWithoutImageInput = {
    name?: StringFieldUpdateOperationsInput | string
    product?: productUpdateManyWithoutCategory_of_productNestedInput
  }

  export type category_of_productUncheckedUpdateWithoutImageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    product?: productUncheckedUpdateManyWithoutCategory_of_productNestedInput
  }

  export type category_of_productUncheckedUpdateManyWithoutCategory_of_productInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type image_of_productUpdateWithoutImageInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productUpdateOneRequiredWithoutImage_of_productNestedInput
  }

  export type image_of_productUncheckedUpdateWithoutImageInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentCreateManyPayment_methodInput = {
    id?: number
    status?: boolean
    details: string
    orderId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type paymentUpdateWithoutPayment_methodInput = {
    status?: BoolFieldUpdateOperationsInput | boolean
    details?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: orderUpdateOneRequiredWithoutPaymentNestedInput
  }

  export type paymentUncheckedUpdateWithoutPayment_methodInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    details?: StringFieldUpdateOperationsInput | string
    orderId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentUncheckedUpdateManyWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    details?: StringFieldUpdateOperationsInput | string
    orderId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fair_date_hour_of_workCreateManyDatesInput = {
    id?: number
    fairId: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type fair_date_hour_of_workUpdateWithoutDatesInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fair?: fairUpdateOneRequiredWithoutFair_date_hour_of_workNestedInput
  }

  export type fair_date_hour_of_workUncheckedUpdateWithoutDatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    fairId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type date_and_hour_of_workCreateManyDay_of_weekInput = {
    id?: number
    open_datetime: Date | string
    close_datetime: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type date_and_hour_of_workUpdateWithoutDay_of_weekInput = {
    open_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    close_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fair_date_hour_of_work?: fair_date_hour_of_workUpdateManyWithoutDatesNestedInput
  }

  export type date_and_hour_of_workUncheckedUpdateWithoutDay_of_weekInput = {
    id?: IntFieldUpdateOperationsInput | number
    open_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    close_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fair_date_hour_of_work?: fair_date_hour_of_workUncheckedUpdateManyWithoutDatesNestedInput
  }

  export type date_and_hour_of_workUncheckedUpdateManyWithoutDate_and_hour_of_workInput = {
    id?: IntFieldUpdateOperationsInput | number
    open_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    close_datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type costumerCreateManyGenderInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    picture_uri?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    birthday: string
    cpf?: string | null
  }

  export type deliverymanCreateManyGenderInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    picture_uri: string
    locationId: number
    online?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    birthday: string
  }

  export type marketerCreateManyGenderInput = {
    id?: number
    name: string
    email: string
    password_hash: string
    picture_uri?: string | null
    review?: number
    online?: boolean
    locationId: number
    created_at?: Date | string
    birthday: string
    updated_at?: Date | string
    cnpj?: string | null
    cpf?: string | null
    phone: string
    tent_name: string
  }

  export type costumerUpdateWithoutGenderInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    birthday?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    costumer_addresses?: costumer_addressesUpdateManyWithoutCostumerNestedInput
    shopping_lists?: shopping_listUpdateManyWithoutCostumerNestedInput
  }

  export type costumerUncheckedUpdateWithoutGenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    birthday?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    costumer_addresses?: costumer_addressesUncheckedUpdateManyWithoutCostumerNestedInput
    shopping_lists?: shopping_listUncheckedUpdateManyWithoutCostumerNestedInput
  }

  export type costumerUncheckedUpdateManyWithoutCostumerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    birthday?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type deliverymanUpdateWithoutGenderInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: StringFieldUpdateOperationsInput | string
    online?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    birthday?: StringFieldUpdateOperationsInput | string
    location?: locationUpdateOneRequiredWithoutDeliverymanNestedInput
    order?: orderUpdateManyWithoutDeliverymanNestedInput
    veicule_deliveryman?: veicule_deliverymanUpdateManyWithoutOwnerNestedInput
  }

  export type deliverymanUncheckedUpdateWithoutGenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: StringFieldUpdateOperationsInput | string
    locationId?: IntFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    birthday?: StringFieldUpdateOperationsInput | string
    order?: orderUncheckedUpdateManyWithoutDeliverymanNestedInput
    veicule_deliveryman?: veicule_deliverymanUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type deliverymanUncheckedUpdateManyWithoutDeliverymanInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: StringFieldUpdateOperationsInput | string
    locationId?: IntFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    birthday?: StringFieldUpdateOperationsInput | string
  }

  export type marketerUpdateWithoutGenderInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: NullableStringFieldUpdateOperationsInput | string | null
    review?: FloatFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    birthday?: StringFieldUpdateOperationsInput | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    tent_name?: StringFieldUpdateOperationsInput | string
    fair_marketers?: fair_marketersUpdateManyWithoutMarketerNestedInput
    location?: locationUpdateOneRequiredWithoutMarketerNestedInput
    products?: productUpdateManyWithoutMarketerNestedInput
  }

  export type marketerUncheckedUpdateWithoutGenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: NullableStringFieldUpdateOperationsInput | string | null
    review?: FloatFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    locationId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    birthday?: StringFieldUpdateOperationsInput | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    tent_name?: StringFieldUpdateOperationsInput | string
    fair_marketers?: fair_marketersUncheckedUpdateManyWithoutMarketerNestedInput
    products?: productUncheckedUpdateManyWithoutMarketerNestedInput
  }

  export type marketerUncheckedUpdateManyWithoutMarketerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    picture_uri?: NullableStringFieldUpdateOperationsInput | string | null
    review?: FloatFieldUpdateOperationsInput | number
    online?: BoolFieldUpdateOperationsInput | boolean
    locationId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    birthday?: StringFieldUpdateOperationsInput | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    tent_name?: StringFieldUpdateOperationsInput | string
  }

  export type addressCreateManyCityInput = {
    id?: number
    cep: string
    logradouro: string
    number: number
    created_at?: Date | string
    updated_at?: Date | string
    address_typeId: number
    complemento: string
    uFId: number
    neighborhoodId: number
    locationId: number
  }

  export type addressUpdateWithoutCityInput = {
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    complemento?: StringFieldUpdateOperationsInput | string
    type?: address_typeUpdateOneRequiredWithoutAddressNestedInput
    location?: locationUpdateOneRequiredWithoutAddressNestedInput
    neighborhood?: neighborhoodUpdateOneRequiredWithoutAddressNestedInput
    uf?: ufUpdateOneRequiredWithoutAddressNestedInput
    costumer_addresses?: costumer_addressesUpdateManyWithoutAddressNestedInput
    fair?: fairUpdateOneWithoutAddressNestedInput
  }

  export type addressUncheckedUpdateWithoutCityInput = {
    id?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address_typeId?: IntFieldUpdateOperationsInput | number
    complemento?: StringFieldUpdateOperationsInput | string
    uFId?: IntFieldUpdateOperationsInput | number
    neighborhoodId?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    costumer_addresses?: costumer_addressesUncheckedUpdateManyWithoutAddressNestedInput
    fair?: fairUncheckedUpdateOneWithoutAddressNestedInput
  }

  export type addressCreateManyNeighborhoodInput = {
    id?: number
    cep: string
    logradouro: string
    number: number
    created_at?: Date | string
    updated_at?: Date | string
    address_typeId: number
    complemento: string
    cityId: number
    uFId: number
    locationId: number
  }

  export type addressUpdateWithoutNeighborhoodInput = {
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    complemento?: StringFieldUpdateOperationsInput | string
    type?: address_typeUpdateOneRequiredWithoutAddressNestedInput
    city?: cityUpdateOneRequiredWithoutAddressNestedInput
    location?: locationUpdateOneRequiredWithoutAddressNestedInput
    uf?: ufUpdateOneRequiredWithoutAddressNestedInput
    costumer_addresses?: costumer_addressesUpdateManyWithoutAddressNestedInput
    fair?: fairUpdateOneWithoutAddressNestedInput
  }

  export type addressUncheckedUpdateWithoutNeighborhoodInput = {
    id?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address_typeId?: IntFieldUpdateOperationsInput | number
    complemento?: StringFieldUpdateOperationsInput | string
    cityId?: IntFieldUpdateOperationsInput | number
    uFId?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    costumer_addresses?: costumer_addressesUncheckedUpdateManyWithoutAddressNestedInput
    fair?: fairUncheckedUpdateOneWithoutAddressNestedInput
  }

  export type addressCreateManyUfInput = {
    id?: number
    cep: string
    logradouro: string
    number: number
    created_at?: Date | string
    updated_at?: Date | string
    address_typeId: number
    complemento: string
    cityId: number
    neighborhoodId: number
    locationId: number
  }

  export type addressUpdateWithoutUfInput = {
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    complemento?: StringFieldUpdateOperationsInput | string
    type?: address_typeUpdateOneRequiredWithoutAddressNestedInput
    city?: cityUpdateOneRequiredWithoutAddressNestedInput
    location?: locationUpdateOneRequiredWithoutAddressNestedInput
    neighborhood?: neighborhoodUpdateOneRequiredWithoutAddressNestedInput
    costumer_addresses?: costumer_addressesUpdateManyWithoutAddressNestedInput
    fair?: fairUpdateOneWithoutAddressNestedInput
  }

  export type addressUncheckedUpdateWithoutUfInput = {
    id?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    address_typeId?: IntFieldUpdateOperationsInput | number
    complemento?: StringFieldUpdateOperationsInput | string
    cityId?: IntFieldUpdateOperationsInput | number
    neighborhoodId?: IntFieldUpdateOperationsInput | number
    locationId?: IntFieldUpdateOperationsInput | number
    costumer_addresses?: costumer_addressesUncheckedUpdateManyWithoutAddressNestedInput
    fair?: fairUncheckedUpdateOneWithoutAddressNestedInput
  }

  export type productCreateManyCategory_of_productInput = {
    id?: number
    name: string
    price: number
    quantity?: number | null
    review?: number
    active_for_selling?: boolean
    available_quantity: number
    marketerId: number
    created_at?: Date | string
    updated_at?: Date | string
    description: string
    type_of_productId: number
  }

  export type productUpdateWithoutCategory_of_productInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    review?: FloatFieldUpdateOperationsInput | number
    active_for_selling?: BoolFieldUpdateOperationsInput | boolean
    available_quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    image_of_product?: image_of_productUpdateManyWithoutProductNestedInput
    marketer?: marketerUpdateOneRequiredWithoutProductsNestedInput
    type_of_price?: type_of_priceUpdateOneRequiredWithoutProductNestedInput
    products_in_shopping_list?: products_in_shopping_listUpdateManyWithoutProductNestedInput
    sale_off?: sale_offUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutCategory_of_productInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    review?: FloatFieldUpdateOperationsInput | number
    active_for_selling?: BoolFieldUpdateOperationsInput | boolean
    available_quantity?: IntFieldUpdateOperationsInput | number
    marketerId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    type_of_productId?: IntFieldUpdateOperationsInput | number
    image_of_product?: image_of_productUncheckedUpdateManyWithoutProductNestedInput
    products_in_shopping_list?: products_in_shopping_listUncheckedUpdateManyWithoutProductNestedInput
    sale_off?: sale_offUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    review?: FloatFieldUpdateOperationsInput | number
    active_for_selling?: BoolFieldUpdateOperationsInput | boolean
    available_quantity?: IntFieldUpdateOperationsInput | number
    marketerId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    type_of_productId?: IntFieldUpdateOperationsInput | number
  }

  export type productCreateManyType_of_priceInput = {
    id?: number
    name: string
    price: number
    quantity?: number | null
    review?: number
    active_for_selling?: boolean
    available_quantity: number
    marketerId: number
    created_at?: Date | string
    updated_at?: Date | string
    description: string
    category_of_productId: number
  }

  export type productUpdateWithoutType_of_priceInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    review?: FloatFieldUpdateOperationsInput | number
    active_for_selling?: BoolFieldUpdateOperationsInput | boolean
    available_quantity?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    image_of_product?: image_of_productUpdateManyWithoutProductNestedInput
    category_of_product?: category_of_productUpdateOneRequiredWithoutProductNestedInput
    marketer?: marketerUpdateOneRequiredWithoutProductsNestedInput
    products_in_shopping_list?: products_in_shopping_listUpdateManyWithoutProductNestedInput
    sale_off?: sale_offUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutType_of_priceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    review?: FloatFieldUpdateOperationsInput | number
    active_for_selling?: BoolFieldUpdateOperationsInput | boolean
    available_quantity?: IntFieldUpdateOperationsInput | number
    marketerId?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    category_of_productId?: IntFieldUpdateOperationsInput | number
    image_of_product?: image_of_productUncheckedUpdateManyWithoutProductNestedInput
    products_in_shopping_list?: products_in_shopping_listUncheckedUpdateManyWithoutProductNestedInput
    sale_off?: sale_offUncheckedUpdateManyWithoutProductNestedInput
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}